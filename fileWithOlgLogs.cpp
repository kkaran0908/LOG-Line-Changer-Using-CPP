host_exec_if.cpp     ALGO_ILOG("[algo:%s] InternalInitiateAction=%s, state=%s", inst_id().to_string(), algoif::ALGO_ACTION_STR[action], ALGO_STATE_STR[get_state()]);
host_exec_if.cpp             ALGO_ILOG("Pausing: %s", m_algo_bin.report_statistics());
host_exec_if.cpp         ALGO_WLOG("[algo:%s] ScheduleAction: Invalid or redundant action. Skip. state=%s action=%s", inst_id().to_string(), ALGO_STATE_STR[state], ALGO_ACTION_STR[action]);
host_exec_if.cpp         ALGO_ILOG( "[algo:%s] ScheduleAction=%s state=%s", inst_id().to_string(), ALGO_ACTION_STR[action], ALGO_STATE_STR[state] );
host_exec_if.cpp         ALGO_ILOG("InitiateNextAction pop=%s, state=%s,", ALGO_ACTION_STR[nextAction], ALGO_STATE_STR[get_state()]);
host_exec_if.cpp             ALGO_ELOG("Action Invalid, dropping.");
host_exec_if.cpp     ALGO_ILOG( "DownloadOrder: order_id=%s, ttuuid=%s", order_id, order_uuid.to_string());
host_exec_if.cpp         ALGO_ELOG( "[algo:%s]: Download request failed(%s) for order_id=%s request_id=%d ", m_algo_bin.inst_id().to_string(), TTSDK_ERROR_STR[result], order_id, request_id );
host_exec_if.cpp         ALGO_ILOG( "[algo:%s]: Download request sent for order_id=%s request_id=%d ", m_algo_bin.inst_id().to_string(), order_id, request_id );
host_exec_if.cpp         ALGO_ELOG( "[algo:%s]: TTSDK_AttachSyntheticChildOrder failed:(%s), for order_id=%s", m_algo_bin.inst_id().to_string(), TTSDK_ERROR_STR[result], std::string(order_id_string) );
host_exec_if.cpp         ALGO_ILOG( "[algo:%s]: TTSDK_AttachSyntheticChildOrder finished for order_id=%s", m_algo_bin.inst_id().to_string(), std::string(order_id_string) );
host_exec_if.cpp         ALGO_ELOG( "[algo:%s]: TTSDK_PlaceBasicOrder failed:(%s)", m_algo_bin.inst_id().to_string(), TTSDK_ORDER_ERR_STR[result] );
host_exec_if.cpp                 ALGO_WLOG("[algo:%s]: %s",m_algo_bin.inst_id().to_string(), msg);
host_exec_if.cpp                 ALGO_WLOG("[algo:%s]: %s", m_algo_bin.inst_id().to_string(), msg);
host_exec_if.cpp         ALGO_DLOG( "[algo:%s]: FlushAlert: total_count=%d total_audit_trail_count=%d", m_algo_bin.inst_id().to_string(), total_count, total_audit_trail_count );
host_exec_if.cpp     ALGO_ILOG( "[algo:%s]: SearchConnector called with \n" "path=%s\n" "splitted_path.size()=%d \n" "referenced_block_id=%s \n" "connector_id=%s", m_algo_bin.inst_id().to_string(), path, splitted_path.size(), referenced_block_id, connector_id );
host_exec_if.cpp         ALGO_ILOG( "[algo:%s]: push owning_graph[name=%s, owning_block->id=%s] " "to path_of_alert_block. Now size()=%d.", m_algo_bin.inst_id().to_string(), owning_block->blockInst->name, owning_block_guid, path_of_alert_block.size() );
host_exec_if.cpp             ALGO_DLOG("[algo:%s]: Found groupblock with segment %s", m_algo_bin.inst_id().to_string(), path_segment);
host_exec_if.cpp                     ALGO_WLOG( "[algo:%s]: Alert and Reference block deviated: Alert:%s, ReferenceBlock:%s ", m_algo_bin.inst_id().to_string(), graph_on_path_of_alert_block == nullptr ? "NULL": GuidToString(graph_on_path_of_alert_block->owningBlockInstData->blockInst->id, '-') , GuidToString(found_block->blockInst->id, '-') );
host_exec_if.cpp                     ALGO_ELOG( "[algo:%s]: Found virtual gourp on ReferenceBlock path for %s. " "But there is no corresponding graph on Alert path!!" "This is likely due to Alert and Referenced block are on DIFFERENT virtual group path.", m_algo_bin.inst_id().to_string(), path_segment );
host_exec_if.cpp                     ALGO_WLOG( "[algo:%s]: Found virtual gourp on ReferenceBlock path for %s. use the graph[%s] " "on Alert path to ping down the proper virtualizaiton", m_algo_bin.inst_id().to_string(), path_segment, GuidToString(graph_on_path_of_alert_block->owningBlockInstData->blockInst->id, '-') );
host_exec_if.cpp             ALGO_ELOG( "[algo:%s]: AlertBlock formula failed to find block: %s in current graph", m_algo_bin.inst_id().to_string(), path_segment );
host_exec_if.cpp         ALGO_ELOG( "[algo:%s]: AlertBlock formula failed to find block by Id: %s", m_algo_bin.inst_id().to_string(), referenced_block_id );
host_exec_if.cpp         ALGO_ELOG("TTSDKOrderEventCallback. Something is wrong. user_data is NULL!!");
host_exec_if.cpp             ALGO_WLOG("TTSDKOrderEventCallback: receive ttsdk_order_event_detached for existing order[pointer=%p] " "orderSubscriber->callbacks.size()=%lu [should be 0]", static_cast<void*>(subscriber->order), call_back_size);
host_exec_if.cpp         ALGO_ILOG("TTSDKOrderEventCallback: " "No listerner in the callbacks of existing order[pointer=%p] " "[order_event=%s].[status=%s]. " "Likely this event is generated before OrderD detach", static_cast<void*>(subscriber->order), TTSDK_OrderEventToString(event), (order_snap == nullptr ? "order_snap is null!":TTSDK_OrderStatusToString(order_snap->last_status)));
host_exec_if.cpp         ALGO_ILOG("TTSDKOrderEventCallback: Order is Orphan-ed: " "subscriber=%p " "subscriber.order=%p " "[order_event=%s] " "[status=%s] ", subscriber, static_cast<void*>(subscriber->order), TTSDK_OrderEventToString(event), (order_snap == nullptr ? "order_snap is null!":TTSDK_OrderStatusToString(order_snap->last_status)));
host_exec_if.cpp         ALGO_WLOG("TTSDKProfitLossEventCallback: PnlManager=nullptr " "algo_inst_mgr=%p " "user_data=%p", static_cast<void*>(algo_inst_mgr), user_data);
host_exec_if.cpp         ALGO_ELOG("[algo:%s]: price_sub=%llu is not in m_priceSubscriptions", m_algo_bin.inst_id().to_string(), price_sub);
host_exec_if.cpp         ALGO_ELOG("[algo:%s] IsSOAFill: Child fill missing instr_id", inst_id().to_string());
host_exec_if.cpp         ALGO_ELOG("[algo:%s] IsSOAFill: Parent Order Instrument missing", inst_id().to_string());
host_exec_if.cpp         ALGO_ELOG("[algo:%s] IsSOAFill: Child fill missing side", inst_id().to_string());
host_exec_if.cpp         ALGO_ELOG("[algo:%s] IsSOAFill: Parent Order Side missing", inst_id().to_string());
host_exec_if.cpp         ALGO_ELOG("[algo:%s] OnSOAFilled: Child fill missing last fill prc or qty", inst_id().to_string());
host_exec_if.cpp         ALGO_ELOG("[algo:%s] OnSOAFilled: Parent Order Qty missing", inst_id().to_string());
host_exec_if.cpp     ALGO_ILOG( "[algo:%s]: OnSOAFilled: Publishing fill: " "parent_cum_fill_qty: %f " "parent_order_qty: %f " "child_last_fill_price: %f " "child_last_fill_qty: %f " "trade_date=%llu ", m_algo_bin.inst_id().to_string(), parent_cum_fill_qty, parent_order_qty, child_last_fill_price, child_last_fill_qty, trade_date );
host_exec_if.cpp         ALGO_ILOG( "[algo:%s]: OnSOAFilled: Fully/Over filled - scheduling algo stop: " "parent_cum_fill_qty: %f " "parent_order_qty: %f " "child_last_fill_price: %f " "child_last_fill_qty: %f", m_algo_bin.inst_id().to_string(), parent_cum_fill_qty, parent_order_qty, child_last_fill_price, child_last_fill_qty );
host_exec_if.cpp         ALGO_ILOG("[algo:%s] OnSOAFilled: Suppressing all send status from this point on.", inst_id().to_string());
host_exec_if.cpp         ALGO_ELOG("[algo:%s] OnSOAUpdated: Parent Order Qty missing", inst_id().to_string());
host_exec_if.cpp         ALGO_ILOG( "[algo:%s]: OnSOAUpdated: Parent order qty decreased to/below parent cum qty - scheduling algo stop: " "parent_cum_fill_qty: %f " "parent_order_qty: %f " "parent_wrk_qty: %f", m_algo_bin.inst_id().to_string(), parent_cum_fill_qty, parent_order_qty, parent_wrk_qty );
host_exec_if.cpp         ALGO_ELOG("[algo:%s] VerifySOAParams: Parent Order Instrument missing", inst_id().to_string());
host_exec_if.cpp         ALGO_ELOG("[algo:%s] VerifySOAParams: Parent Order Qty missing", inst_id().to_string());
host_exec_if.cpp         ALGO_ELOG("[algo:%s] VerifySOAParams: Parent Side missing", inst_id().to_string());
host_exec_if.cpp         ALGO_ELOG("TTSDKPositionLimitUpdatedEvent: user_data was unexpectedly a nullptr, " "the requestor will NOT get a response of any sort.");
host_exec_if.cpp         ALGO_WLOG("[algo:%s]: SaveStateToDisk: Will not save state to disk since synth_status is [%s]!", m_algo_bin.inst_id().to_string(), TTSDK_SYNTH_STATUS_STR[synth_status]);
host_exec_if.cpp     ALGO_ILOG("[algo:%s] Saving state to disk.", inst_id().to_string());
host_exec_if.cpp     ALGO_ILOG("[algo:%s] Loading state from disk.", inst_id().to_string());
host_exec_if.cpp     ALGO_ILOG("[algo:%s] Marking recovery file as stale.", inst_id().to_string());
host_exec_if.cpp     ALGO_DLOG("%s", msg.str());
host_exec_if.cpp         ALGO_ELOG("[algo:%s]: CanRecover: Missing pre-recovery synthetic status!", m_algo_bin.inst_id().to_string());
host_exec_if.cpp         ALGO_ELOG("[algo:%s]: CanRecover: Cannot recover back to synth status of [%s]!", m_algo_bin.inst_id().to_string(), TTSDK_SYNTH_STATUS_STR[pre_recovery_synth_status]);
host_exec_if.cpp     ALGO_ILOG("[algo:%s]: highest_recursion_level=%lu", m_algo_bin.inst_id().to_string(), m_highest_recursion_level);
so_algo_bin_host_events.cpp                 ALGO_ELOG("[algo:%s] process_external_request: Failed to get Algo Instrument ID!", inst_id().to_string());
so_algo_bin_host_events.cpp             ALGO_ILOG("[algo:%s] DetermineEnableNearFarTouchPriceReasonability: using originating_user_id=%llu (user_id=%llu)", inst_id().to_string(), effective_user_id, m_algo_bin.user_id());
so_algo_bin_host_events.cpp         ALGO_DLOG("[algo:%s]: Creating AlgoInstMgr with %s", inst_id().to_string(), GroupIDsToString(group_ids));
so_algo_bin_host_events.cpp                 ALGO_WLOG("[algo:%s] process_external_request: Failed to update FIX params for reject response: " "error=%s " "IGNORE this warning if FIX is not involved!", inst_id().to_string(), TTSDK_ERROR_STR[ttsdk_error]);
so_algo_bin_host_events.cpp                 ALGO_ILOG("[algo:%s] process_external_request: Updated FIX params for reject response", inst_id().to_string());
so_algo_bin_host_events.cpp                 ALGO_WLOG("[algo:%s] process_external_request: Failed to update CL_ORD_ID params for reject response: " "error=%s ", inst_id().to_string(), TTSDK_ERROR_STR[ttsdk_error]);
so_algo_bin_host_events.cpp                 ALGO_ILOG("[algo:%s] process_external_request: Updated CL_ORD_ID params for reject response cl_ord_id=%llu orig_cl_ord_id=%llu", inst_id().to_string(), cl_ord_id, orig_cl_ord_id);
so_algo_bin_host_events.cpp                 ALGO_ILOG("[algo:%s] set m_dl: %p. type=%s", inst_id().to_string(), (void*)dl, typeid(dl).name());
so_algo_bin_host_events.cpp         ALGO_ILOG("[algo:%s]Dispatch SO extraction to service thread", inst_id().to_string());
so_algo_bin_host_events.cpp             ALGO_ILOG("[algo:%s] Set exec_restatement_reason to REPLACED.", inst_id().to_string());
so_algo_bin_host_events.cpp             ALGO_ILOG("[algo:%s] Set exec_restatement_reason to REPLACE-REJECTED.", inst_id().to_string());
so_algo_bin_host_events.cpp         ALGO_WLOG("[algo:%s] so_algo_bin::process_external_request: error=%s, state=%s ttsdk_error=%s", inst_id().to_string(), ALGOJOB_ERROR_STR[error], ALGO_STATE_STR[get_state()], TTSDK_ERROR_STR[ttsdk_error]);
so_algo_bin_host_events.cpp             ALGO_WLOG("[algo:%s] process_external_request: Failed to update FIX params for reject response: " "error=%s " "IGNORE this warning if FIX is not involved!", inst_id().to_string(), TTSDK_ERROR_STR[ttsdk_error]);
so_algo_bin_host_events.cpp             ALGO_ILOG("[algo:%s] process_external_request: Updated FIX params for reject response", inst_id().to_string());
so_algo_bin_host_events.cpp             ALGO_WLOG("[algo:%s] process_external_request: Failed to update CL_ORD_ID params for reject response: " "error=%s ", inst_id().to_string(), TTSDK_ERROR_STR[ttsdk_error]);
so_algo_bin_host_events.cpp             ALGO_ILOG("[algo:%s] process_external_request: Updated CL_ORD_ID params for reject response cl_ord_id=%llu orig_cl_ord_id=%llu", inst_id().to_string(), cl_ord_id, orig_cl_ord_id);
so_algo_bin_host_events.cpp         ALGO_WLOG("[algo:%s] process_external_request: Failed to promote FIX params for accept response: " "error=%s " "IGNORE this warning if FIX is not involved!", inst_id.to_string(), TTSDK_ERROR_STR[ttsdk_error]);
so_algo_bin_host_events.cpp         ALGO_ILOG("[algo:%s] process_external_request: Promoted FIX params for accept response", inst_id.to_string());
so_algo_bin_host_events.cpp         ALGO_WLOG("[algo:%s] process_external_request: Failed to promote CL_ORD_ID params for accept response: " "error=%s ", inst_id.to_string(), TTSDK_ERROR_STR[ttsdk_error]);
so_algo_bin_host_events.cpp         ALGO_ILOG("[algo:%s] process_external_request: Promoted CL_ORD_ID params for accept response cl_ord_id=%llu orig_cl_ord_id=%llu", inst_id.to_string(), cl_ord_id, orig_cl_ord_id);
so_algo_bin_host_events.cpp         ALGO_ELOG( "[algo:%s] Failed to update OMA Parent ID: request is missing ID", inst_id().to_string() );
so_algo_bin_host_events.cpp     ALGO_ILOG( "[algo:%s] Updated OMA Parent ID on request: " "request=algojob__request_set_oma_parent_id " "new_oma_parent_id=%s", inst_id().to_string(), std::string(oma_parent_uuid_string) );
so_algo_bin_host_events.cpp         ALGO_ELOG("[algo:%s] Failed update review_status and review_user_id", inst_id().to_string());
so_algo_bin_host_events.cpp     ALGO_ILOG("[algo:%s] Updated review/approve parameters on request: " "request=algojob__request_review_approve_via_update review_status=%s review_user_id=%llu", inst_id().to_string(), TTSDK_ReviewStatusToString(review_status), review_user_id);
so_algo_bin_host_events.cpp     ALGO_ILOG( "[algo:%s] Cleared OMA Parent ID on request: " "request=algojob__request_clear_oma_parent_id", inst_id().to_string() );
so_algo_bin_host_events.cpp                 ALGO_ILOG("[algo:%s] SO can not handle update_current_user", inst_id().to_string());
so_algo_bin_host_events.cpp     ALGO_ILOG("[algo:%s] process_request=%s, " "current_state=%s " "active_user_param_count=%d " "request_user_param_count=%s " "resultant_user_param_count=%d ", inst_id().to_string(), ALGOJOB_REQUEST_ID_STR[request_id], ALGO_STATE_STR[algo_state], active_params.count, request_params ? std::to_string(request_params->count) : "N/A", resultant_params.count);
so_algo_bin_host_events.cpp                 ALGO_ELOG("[algo:%s] algojob__request_order_pass: request_params was a nullptr", inst_id().to_string());
so_algo_bin_host_events.cpp             ALGO_ILOG("[algo:%s] algojob__request_order_pass: Attempting to update so_algo_bin and SO's params with: " "obp_state=%s " "current_group_id=%llu " "pass_to_group_id=%llu " "previous_pass_to_group_id=%llu " "original_group_id=%llu", inst_id().to_string(), std::string(OrderPassToString(obp_state)), current_group_id, pass_to_group_id, previous_pass_to_group_id, original_group_id);
so_algo_bin_host_events.cpp                 ALGO_ELOG("[algo:%s] algojob__request_order_pass: Not allowed in current state=%s", inst_id().to_string(), std::string(ALGO_STATE_STR[algo_state_before_action]));
so_algo_bin_host_events.cpp                 ALGO_ELOG("[algo:%s] algojob__request_order_pass: Missing OBP state!", inst_id().to_string());
so_algo_bin_host_events.cpp                     ALGO_ELOG("[algo:%s] algojob__request_order_pass: Missing current_group_id for OBP state=%s!", inst_id().to_string(), std::string(OrderPassToString(obp_state)));
so_algo_bin_host_events.cpp                     ALGO_ELOG("[algo:%s] algojob__request_order_pass: Missing AlgoInstMgr for OBP state=%s!", inst_id().to_string(), std::string(OrderPassToString(obp_state)));
so_algo_bin_host_events.cpp                     ALGO_ILOG("[algo:%s] algojob__request_order_pass: SO does not implement [on_update_obp_params]", inst_id().to_string());
so_algo_bin_host_events.cpp                 ALGO_ILOG("[algo:%s] algojob__request_order_pass: Set current and future child orders with %s", inst_id().to_string(), GroupIDsToString(group_ids));
so_algo_bin_host_events.cpp             ALGO_ILOG("[algo:%s] algojob__request_order_pass: Success!", inst_id().to_string());
so_algo_bin_host_events.cpp                 ALGO_ILOG("[algo:%s] dl()->on_pause_algo: error=%s", inst_id().to_string(), TTSDK_ERROR_STR[error]);
so_algo_bin_host_events.cpp                     ALGO_ILOG( "[algo:%s] dl()->on_stop_algo: error=%s", inst_id().to_string(), TTSDK_ERROR_STR[error] );
so_algo_bin_host_events.cpp                     ALGO_ILOG("[algo:%s] algojob__request_review_approve_via_update: SO does not implement [on_update_review_approve_params]", inst_id().to_string());
so_algo_bin_host_events.cpp         ALGO_ELOG( "[algo:%s] process_request %s error=%s", inst_id().to_string(), ALGOJOB_REQUEST_ID_STR[request_id], TTSDK_ERROR_STR[error] );
so_algo_bin_host_events.cpp             ALGO_ILOG( "[algo:%s] OnRecoverAlgo not implemented, failing recovery", inst_id().to_string() );
so_algo_bin_host_events.cpp                 ALGO_ILOG("[algo:%s] process_extraction_complete_event: This is a special resume->cancel request " "to resume first and then cancel immediately afterwards", inst_id().to_string());
so_algo_bin_host_events.cpp             ALGO_ILOG( "[algo:%s] OnResumeAlgo not implemented, failing resuming process", inst_id().to_string() );
so_algo_bin_host_events.cpp         ALGO_ELOG("[algo:%s] Unrecognized instr_extract_reason!", inst_id().to_string());
so_algo_bin_host_events.cpp         ALGO_ELOG("[algo:%s] process_extraction_complete_event: error=%s", inst_id().to_string(), TTSDK_ERROR_STR[error]);
so_algo_bin_host_events.cpp         ALGO_ILOG("[algo:%s] Always skip price deviation calc for TT_STOP", inst_id().to_string());
so_algo_bin_host_events.cpp         ALGO_ILOG("[algo:%s] OnStartAlgo successful and now awaiting price sub callback - " "suppressing send_status to avoid sending duplicate 'starting' state back to TTW: ", inst_id().to_string());
so_algo_bin_host_events.cpp     ALGO_ELOG("ProcessExtractionFailedEvent: failure=%s", ALGO_REQ_FAILURE_CODE_STR[failure]);
so_algo_bin_host_events.cpp         ALGO_ELOG("ProcessExtractionFailedEvent: recovering algo=%s destroy algo_bin", ALGO_REQ_FAILURE_CODE_STR[failure]);
so_algo_bin_host_events.cpp     ALGO_ILOG( "[algo:%s]process_inst_event calling on_scheduled_event " "order_id=%s user_data_addr=%p", inst_id().to_string(), std::string(order_id_str), &m_so_user_data );
so_algo_bin_host_events.cpp         ALGO_ILOG( "[algo:%s]process_pause_finished_event " "pause_result=%s, user_data_addr=%p", inst_id().to_string(), data->action_status ? "success" : "failed", &m_so_user_data );
so_algo_bin_host_events.cpp                 ALGO_WLOG("[algo:%s] process_pause_finished_event: Failed to update FIX params for reject response: " "error=%s " "IGNORE this warning if FIX is not involved!", inst_id().to_string(), TTSDK_ERROR_STR[ttsdk_error]);
so_algo_bin_host_events.cpp                 ALGO_ILOG("[algo:%s] process_pause_finished_event: Updated FIX params for reject response", inst_id().to_string());
so_algo_bin_host_events.cpp                 ALGO_WLOG("[algo:%s] process_pause_finished_event: Failed to update CL_ORD_ID params for reject response: " "error=%s ", inst_id().to_string(), TTSDK_ERROR_STR[ttsdk_error]);
so_algo_bin_host_events.cpp                 ALGO_ILOG("[algo:%s] process_pause_finished_event: Updated CL_ORD_ID params for reject response cl_ord_id=%llu orig_cl_ord_id=%llu", inst_id().to_string(), cl_ord_id, orig_cl_ord_id);
so_algo_bin_host_events.cpp         ALGO_ILOG( "[algo:%s]process_cancel_finished_event calling on_destroy_algo " "cancel_result=%s, user_data_addr=%p", inst_id().to_string(), data->action_status ? "success" : "failed", &m_so_user_data );
so_algo_bin_host_events.cpp                 ALGO_WLOG("[algo:%s] process_cancel_finished_event: Failed to update FIX params for reject response: " "error=%s " "IGNORE this warning if FIX is not involved!", inst_id().to_string(), TTSDK_ERROR_STR[ttsdk_error]);
so_algo_bin_host_events.cpp                 ALGO_ILOG("[algo:%s] process_cancel_finished_event: Updated FIX params for reject response", inst_id().to_string());
so_algo_bin_host_events.cpp                 ALGO_WLOG("[algo:%s] process_cancel_finished_event: Failed to update CL_ORD_ID params for reject response: " "error=%s", inst_id().to_string(), TTSDK_ERROR_STR[ttsdk_error]);
so_algo_bin_host_events.cpp                 ALGO_ILOG("[algo:%s] process_cancel_finished_event: Updated CL_ORD_ID params for reject response cl_ord_id=%llu orig_cl_ord_id=%llu", inst_id().to_string(), cl_ord_id, orig_cl_ord_id);
synthetic_server_monitor.cpp     ALGO_ILOG("SSM::Observer: start for %s", m_serviceName);
synthetic_server_monitor.cpp     ALGO_ILOG("SSM::Observer: stop for %s", m_serviceName);
synthetic_server_monitor.cpp     ALGO_ILOG("SSM::Observer::OnInstanceAdded: [m_serviceName=%s service_id=%s]" " status=%s" " status_ext=%s", m_serviceName, to_string(serviceId), status, tt::messaging::darwin::StatusExt_Name(status_ext).to_std());
synthetic_server_monitor.cpp         ALGO_WLOG( "SSM::Observer::OnInstanceAdded: [m_serviceName=%s serviceId=%s] no instance_id.", m_serviceName, to_string(serviceId) );
synthetic_server_monitor.cpp         ALGO_ILOG("SSM::Observer::GetCustomData: service_id=%s, custom data not ready", to_string(serviceId));
synthetic_server_monitor.cpp         ALGO_ILOG("SSM::Observer::GetCustomData: failed to parse custom data for service_id=%s", to_string(serviceId));
synthetic_server_monitor.cpp     ALGO_ILOG("SSM::Observer::OnInstanceRemoved: " "[m_serviceName=%s service_id=%s] removed.", m_serviceName, to_string(serviceId));
synthetic_server_monitor.cpp         ALGO_WLOG("SSM::Observer::OnInstanceRemoved: " "[m_serviceName=%s service_id=%s] is not in our map", m_serviceName, to_string(serviceId));
synthetic_server_monitor.cpp             ALGO_WLOG("SSM::Observer::OnInstanceRemoved: " "Routing Library cannot find it by exch_order_assoc=%s ", iter->second);
synthetic_server_monitor.cpp     ALGO_ILOG("SSM::Observer::OnInstanceModified: [m_serviceName=%s service_id=%s]" " status=%s" " status_ext=%s", m_serviceName, to_string(serviceId), status, tt::messaging::darwin::StatusExt_Name(status_ext).to_std());
synthetic_server_monitor.cpp         ALGO_WLOG( "SSM::Observer::OnInstanceModified: %s[%s] updated. no instance_id", m_serviceName, to_string(serviceId) );
synthetic_server_monitor.cpp             ALGO_WLOG( "SSM::Observer: markets is empty. " "skip adding to RL." "m_lbmTopicPrefix=%s " "instanceId=%s " "m_serviceName=%s " "serviceId=%s ", m_lbmTopicPrefix, instanceId, m_serviceName, to_string(serviceId) );
synthetic_server_monitor.cpp             ALGO_ILOG("SSM::Observer: Add [%s.%s] to Routing Library!", m_lbmTopicPrefix, instanceId);
synthetic_server_monitor.cpp             ALGO_ELOG( "SSM::Observer: Failed to add [%s.%s] to Routing Library with status=%s", m_lbmTopicPrefix, instanceId, (m_synthServerMonitor.GetRoutingLibraryStatus()) ? "RL up" : "RL down" );
synthetic_server_monitor.cpp         ALGO_ILOG("SSM: Failed to create server for topic=%s.%s, error=%s", m_lbmTopicPrefix, instanceId, std::string(e.what()));
synthetic_server_monitor.cpp     ALGO_ILOG("SSM: Start client_id=%s, client_secret=%s, ttid=%s, risk=%s, riskws=%s, ssl=%s, allow_aggregator=%s", client_id, Elide(client_secret, 4), ttid_url, risk_url, risk_ws_url, ssl_ca_path, (allow_aggregator == true) ? "true" : "false");
synthetic_server_monitor.cpp                                        ALGO_ILOG("SSM: Connection up");
synthetic_server_monitor.cpp                                        ALGO_ILOG("SSM: Connection down");
synthetic_server_monitor.cpp     ALGO_ILOG("SSM: HandleSyntheticRouterConnectionUp");
synthetic_server_monitor.cpp     ALGO_WLOG("SSM: HandleSyntheticRouterConnectionDown");
synthetic_server_monitor.cpp     ALGO_ILOG("SSM: AddSyntheticServer " "server_type=%d exch_order_assoc=%s mktsize=%d " "status_ext=%s user_data=%p. RL status=%s", serverType, exchAssocId, markets.size(), tt::messaging::darwin::StatusExt_Name(status_ext).to_std(), userData.get(), m_routingLibraryStatus ? "up" : "down (RL will queue)");
algojob_thread_context.cpp     ALGO_ILOG("%s thread pending add algo %s", m_name, algo->inst_id().to_string());
algojob_thread_context.cpp     ALGO_ILOG("%s thread pending remove algo %s", m_name, inst_id.to_string());
algojob_thread_context.cpp     ALGO_ILOG("********** Enter %s thread. thrd_id=0x%x **********", m_name, std::this_thread::get_id());
algojob_thread_context.cpp                         ALGO_ILOG("[algo: %s] execute high priority event %s",kvp.second->inst_id().to_string(), ALGO_EVENT_TYPE_STR[e]);
algojob_thread_context.cpp                             ALGO_ELOG( "[algo: %s] execute %s caught exception. %s", kvp.second->inst_id().to_string(), ALGO_EVENT_TYPE_STR[(unsigned int)event->event_type], std::string(what ? what : "") );
algojob_thread_context.cpp                             ALGO_ELOG( "[algo: %s] execute %s caught unknown exception.", kvp.second->inst_id().to_string(), ALGO_EVENT_TYPE_STR[(unsigned int)event->event_type] );
algojob_thread_context.cpp                             ALGO_ELOG( "[algo: %s] execute %d caught exception. %s", kvp.second->inst_id().to_string(), event->event_type, std::string(what ? what : "") );
algojob_thread_context.cpp                             ALGO_ELOG("[algo: %s] execute %d caught unknown exception.", kvp.second->inst_id().to_string(), event->event_type);
algojob_thread_context.cpp                 ALGO_ILOG("%s thread " "loop_count=%llu, " "loop_time=%llu, " "process_time=%llu, " "average ratio=%lf", m_name, m_loop_count, m_loop_time, m_process_time, m_ratio/m_loop_count);
algojob_thread_context.cpp             ALGO_ILOG("%s thread add algo[%s]", m_name, algo->inst_id().to_string());
algojob_thread_context.cpp             ALGO_ILOG("%s thread remove algo[%s]", m_name, inst_id.to_string());
algojob_thread_context.cpp                 ALGO_ILOG("---------- algo[%s] removed from %s, ref_count=%llu ----------", inst_id.to_string(), m_name, (unsigned long long)algo.use_count());
algojob_thread_context.cpp     ALGO_DLOG("Thread %s (thrd_id=0x%x) is exiting with " "m_pendginAddAlgo.size()=%zu " "m_pendingRemoveAlgo.size()=%zu", m_name, std::this_thread::get_id(), m_pendingAddAlgo.size(), m_pendingRemoveAlgo.size());
algojob_thread_context.cpp         ALGO_ILOG("---------- algo[%s]: saving state to disk for recovery ---------- ", kvp.second->inst_id().to_string());
algojob_thread_context.cpp         ALGO_ILOG("algo[%s] has " "m_high_priority_event_buffer.size()=%zu " "m_event_buffer.size()=%zu", kvp.second->inst_id().to_string(), m_high_priority_event_buffer[kvp.first].size(), m_event_buffer[kvp.first].size());
algojob_thread_context.cpp     ALGO_ILOG("********** Exit %s thread. thrd_id=0x%x **********", m_name, std::this_thread::get_id());
algojob_thread_context.cpp     ALGO_ILOG("%s thread pending add algo %s", m_name, algo->inst_id().to_string());
so_algo_bin_service_events.cpp         ALGO_ILOG("[algo:%s] download_instr: instr_id=%llu extract_reason=%d", inst_id().to_string(), instrId, event->extract_reason);
so_algo_bin_service_events.cpp         ALGO_WLOG("[algo:%s] download_instr: Can not find order instrument id", inst_id().to_string());
so_algo_bin_service_events.cpp     ALGO_ILOG("[algo:%s] download_instr: instr_id=%llu extract_reason=%d, retry=%u, retry_delay=%u (msec)", inst_id().to_string(), instrId, event->extract_reason, retry, retry_delay);
so_algo_bin_service_events.cpp         ALGO_ELOG("[algo:%s] download_instr: failed" " instr_id=%llu" " error=%s", inst_id().to_string(), instrId, tt::sdk::internal::to_string(result_code));
so_algo_bin_service_events.cpp     ALGO_ILOG("[algo:%s] extract_instr: " " instr_id=%llu" " algo_type=[%s] " " algo_verion=[%s] " " extract_reason=%d", inst_id().to_string(), instr_id, TTSDK_ALGO_TYPE_STR[event->algo_type], std::string(version), event->extract_reason);
so_algo_bin_service_events.cpp             ALGO_ILOG("Loading pre-configured local so, algo_instr_id=%llu, bin=%s", instr_id, std::string(local_so_path));
so_algo_bin_service_events.cpp             ALGO_ILOG("Loading local so, algo_instr_id=%llu, bin=%s", instr_id, std::string(local_so_path));
so_algo_bin_service_events.cpp             ALGO_ILOG("Downloading resource=%s", std::string(algo_uuid_string));
so_algo_bin_service_events.cpp                 ALGO_ELOG("Failed to download resource=%s error=%s", std::string(algo_uuid_string), tt::sdk::internal::to_string(error));
so_algo_bin_service_events.cpp                 ALGO_ELOG("Failed to extract resource");
so_algo_bin_service_events.cpp         ALGO_ELOG("ExtractInstr failed: %s", ALGO_REQ_FAILURE_CODE_STR[failure]);
so_algo_bin_service_events.cpp         ALGO_ELOG("failed to load shared object: %s", ALGO_REQ_FAILURE_CODE_STR[failure]);
so_algo_bin_service_events.cpp         ALGO_ELOG("Failed to dlopen shared object: %s", std::string(dlerror()));
so_algo_bin_service_events.cpp         ALGO_ILOG("dlopen so_handle: instr_id=%llu, so_file_path=%s", instr_id, std::string(so_file_path));
so_algo_bin_service_events.cpp         ALGO_ELOG("Missing version from shared object");
so_algo_bin_service_events.cpp         ALGO_WLOG(" warning_msg=TTSDK_VERSION_mismatch! file=%s " "server_version=%s " "user_version=%s ", std::string(so_file_path), server_version, user_version);
so_algo_bin_service_events.cpp         ALGO_ILOG("file=%s " "server_version=%s " "user_version=%s ", std::string(so_file_path), server_version, user_version);
so_algo_bin_service_events.cpp         ALGO_ELOG("Missing exports from shared object");
algo_bin_impl.cpp     ALGO_ILOG("Create algo_dl:" " instr_id=%llu" " version=%s" " user_id=%llu" " algo_compliance_id=%llu", instr_id, version, user_id, algo_compliance_id);
algo_bin_impl.cpp         ALGO_ELOG("[algo:%s] algo_bin_impl: Failed! class_1_2_fields_size=%zu", inst_id().to_string(), data->request->class_1_2_fields_size);
algo_bin_impl.cpp             ALGO_ILOG("[algo:%s] algo_bin_impl: originating_user_id=%llu class_1_2_fields_size=%zu [%s]", inst_id().to_string(), m_algo_bin.m_originating_user_id, data->request->class_1_2_fields_size, m_class_1_2_fields->ShortDebugString().to_std());
algo_bin_impl.cpp             ALGO_ILOG("[algo:%s] algo_bin_impl: originating_user_id=%llu (set from user_id) class_1_2_fields_size=%zu [%s]", inst_id().to_string(), m_algo_bin.m_originating_user_id, data->request->class_1_2_fields_size, m_class_1_2_fields->ShortDebugString().to_std());
algo_bin_impl.cpp     ALGO_ILOG("[algo:%s] algo_bin_impl: Destroyed. this=%p algo_mgr=%p dl=%p", inst_id().to_string(), this, m_algo_inst_mgr.get(), m_dl );
algo_bin_impl.cpp     ALGO_ILOG("add_algo_dl[%p]:" " instr_id=%llu" " version=%s" " user_id=%llu" " is_adl=%d", dl.get(), instr_id, version, user_id, is_adl);
algo_bin_impl.cpp         ALGO_ILOG("ref_algo_dl[%p]:" " ref_count=%llu" " instr_id=%llu" " version=%s" " user_id=%llu" " is_adl=%d", itr->second.get(), itr->second->ref_count.load(std::memory_order_relaxed), instr_id, version, user_id, is_adl);
algo_bin_impl.cpp     ALGO_ILOG("ref_algo_dl: not found." " instr_id=%llu" " version=%s" " user_id=%llu" " is_adl=%d", instr_id, version, user_id, is_adl);
algo_bin_impl.cpp         ALGO_ILOG("unref_algo_dl[%p]:" " ref_count=%llu" " instr_id=%llu" " version=%s" " user_id=%llu" " is_adl=%d", dl, dl->ref_count.load(std::memory_order_relaxed), dl->instr_id, dl->version, dl->user_id, dl->is_adl);
algo_bin_impl.cpp         ALGO_WLOG("unref_algo_dl[%p]: not found." " instr_id=%llu" " version=%s" " user_id=%llu" " is_adl=%d", dl, dl->instr_id, dl->version, dl->user_id, dl->is_adl);
algo_bin_impl.cpp     ALGO_ILOG("[algo:%s] set pending request=[%s] user_request_id=%llu", inst_id().to_string(), ALGOJOB_REQUEST_ID_STR[m_pending_request.request_id], m_pending_request.user_request_id);
algo_bin_impl.cpp     ALGO_ILOG("[algo:%s] clean pending request=[%s] user_request_id=%llu", inst_id().to_string(), ALGOJOB_REQUEST_ID_STR[m_pending_request.request_id], m_pending_request.user_request_id);
algo_bin_impl.cpp             ALGO_ELOG("[algo:%s]: check_class_2_fields: request=[%s], Failed! class_2_size=%zu", inst_id().to_string(), ALGOJOB_REQUEST_ID_STR[request->id], data->request->class_1_2_fields_size);
algo_bin_impl.cpp             ALGO_ILOG("[algo:%s]: check_class_2_fields: request=[%s], class_2_size=%zu tmp=%s m_class_1_2_fields=%s", inst_id().to_string(), ALGOJOB_REQUEST_ID_STR[request->id], data->request->class_1_2_fields_size, tmp->ShortDebugString().to_std(), m_class_1_2_fields->class_2().ShortDebugString().to_std());
algojob_0.cpp         ALGO_WLOG("Delay starting Job0 delay=%d", delay);
algojob_0.cpp         ALGO_ELOG("Failed to initialize communication between Jobs");
algojob_0.cpp         ALGO_ELOG("Failed to start SSM");
algojob_0.cpp             ALGO_ILOG("IPC0: Remove job_connection=%p, socket=%d from s_job0_epoll_file, error=%s", (void*)job_connection, job_connection->socket, ALGOUTIL_ERROR_STR[error]);
algojob_0.cpp             ALGO_ELOG("Exception while stopping ZooKeeperClient. error=%s", ex.what());
algojob_0.cpp         ALGO_ILOG("ConfigXml: data_center_name=%s", data_center_name);
algojob_0.cpp         ALGO_ILOG("ConfigXml: client_id=%s", client_id);
algojob_0.cpp         ALGO_ILOG("ConfigXml: client_secret=%s", Elide(client_secret, 4));
algojob_0.cpp         ALGO_ILOG("ConfigXml: ttid_url=%s", ttid_url);
algojob_0.cpp         ALGO_ILOG("ConfigXml: admin_url=%s", admin_url);
algojob_0.cpp         ALGO_ILOG("ConfigXml: risk_url=%s", risk_url);
algojob_0.cpp         ALGO_ILOG("ConfigXml: risk_ws_url=%s", risk_ws_url);
algojob_0.cpp         ALGO_ILOG("ConfigXml: ssl_ca_path=%s", ssl_ca_path);
algojob_0.cpp         ALGO_ILOG("ConfigXml: allow_aggregator=%d", allow_aggregator);
algojob_0.cpp         ALGO_ELOG("Exception starting SSM: error=%s", error);
algojob_0.cpp         ALGO_ELOG("Exception starting SSM: error=%s", ex.what());
algojob_0.cpp     ALGO_ILOG("IPC0: gonna hangup job_connection.socket=%d", socket);
algojob_0.cpp     ALGO_ILOG("IPC0: Remove job_connection socket=%d from s_job0_epoll_file, error=%s", socket, ALGOUTIL_ERROR_STR[error]);
algojob_0.cpp     ALGO_ILOG("IPC0: Removed job_connection=%p. s_connections.size=%d", (void*)job_connection, s_connections.size());
algojob_0.cpp         ALGO_ILOG("IPC0: CleanupJobConnection: job_connection=%p not found", (void*)job_connection);
algojob_0.cpp         ALGO_ELOG("IPC0: HandleHangup: epoll_data is null");
algojob_0.cpp     ALGO_ILOG("IPC0: receive Hangup");
algojob_0.cpp         ALGO_ILOG("IPC0: s_job0_ipc_server.listen_socket=%d hangup", s_job0_ipc_server.listen_socket); } else { // This is a non-safe pointer. This pointer should not be dereferenced until // it is verified that it is still valid. const auto job_connection = static_cast<algoutil__ipc_connection*>(epoll_data);
algojob_0.cpp     ALGO_ILOG("IPC0: HandleJobConnecting");
algojob_0.cpp     ALGO_ILOG("IPC0: Add job_connection.socket=%d to s_job0_epoll_file, error=%s", job_connection->socket, ALGOUTIL_ERROR_STR[error]);
algojob_0.cpp     ALGO_ILOG("IPC0: Added job_connection=%p. s_connections.size=%d", (void*)job_connection, s_connections.size());
algojob_0.cpp     ALGO_ILOG("IPC0: JobQuestionReceiverThread starting......");
algojob_0.cpp             ALGO_ELOG("IPC0: epoll_wait received signal_count==-1");
algojob_0.cpp                     ALGO_ILOG("IPC0: JobQuestionReceiverThread::AlgoUtil_RecvMessage: " " job_connection=%p not found", (void*)job_connection);
algojob_0.cpp                     ALGO_ELOG("IPC0: AlgoUtil_RecvMessage error=%s", ALGOUTIL_ERROR_STR[err]);
algojob_0.cpp                 ALGO_ILOG("IPC0: Socket became invalid ...., So new scoket has been created.");
algojob_0.cpp                     ALGO_ELOG("IPC0: Failed to add listen_socket=%d to s_job0_epoll_file error=%s errno=%d", s_job0_ipc_server.listen_socket, ALGOUTIL_ERROR_STR[epoll_error], errno);
algojob_0.cpp                     ALGO_ILOG("IPC0: listen_socket=%d added to s_job0_epoll_file", s_job0_ipc_server.listen_socket);
algojob_0.cpp     ALGO_ILOG("IPC0: JobQuestionReceiverThread stopping......");
algojob_0.cpp     ALGO_ILOG("IPC0: Init IPC Server: address=job0.ipc");
algojob_0.cpp         ALGO_ELOG("IPC0: Failed to init JOB0 IPC Server:%s, error=%s errno=%d", job0_ipc_address, ALGOUTIL_ERROR_STR[error], sys_err_no);
algojob_0.cpp         ALGO_ILOG("IPC0: Created IPC Server: listen_socket=%d, listen_name=%s", s_job0_ipc_server.listen_socket, std::string(s_job0_ipc_server.listen_name));
algojob_0.cpp         ALGO_ELOG("IPC0: Failed to epoll_create s_job0_epoll_file");
algojob_0.cpp         ALGO_ILOG("IPC0: epoll_create s_job0_epoll_file=%d", s_job0_epoll_file);
algojob_0.cpp         ALGO_ELOG("IPC0: Failed to add listen_socket=%d to s_job0_epoll_file error=%s", s_job0_ipc_server.listen_socket, ALGOUTIL_ERROR_STR[error]);
algojob_0.cpp         ALGO_ILOG("IPC0: Add listen_socket=%d to s_job0_epoll_file", s_job0_ipc_server.listen_socket);
algojob_0.cpp         ALGO_ILOG("QA: routing_library_query, " "market_id=%u " "primary_market_id=%u " "user_id=%llu " "acct_company=%llu " "user_company=%llu " "And result topic=%s", question->data.rl_query.market_id, question->data.rl_query.primary_market_id, question->data.rl_query.user_id, question->data.rl_query.acct_company, question->data.rl_query.user_company, topic );
algojob_0.cpp                     ALGO_ILOG("IPC0: ProcessJobQuestion encountered a job that is no longer valid. " " job_connection=%p", (void*)job_connection);
algojob_0.cpp             ALGO_ILOG("QA: reply to question_id=%llu job_id=%llu user_id=%llu, error=%s", answer.question.question_id , answer.question.job_id, answer.question.user_id, ALGOUTIL_ERROR_STR[error]);
algojob_0.cpp         ALGO_ELOG("ProcessJobQuestion Unknown type=%d", question->type );
algojob_0.cpp                                         ALGO_ILOG("IPC0: NotifySyntheticServer encountered a job that is no longer valid. " "job_connection=%p, " "topic=%s", (void*)job_connection, topic.c_str());
algojob_0.cpp                                 ALGO_ILOG("Send to job socket=%d topic=%s error=%s", job_connection->socket, topic, ALGOUTIL_ERROR_STR[error]);
algojob_0.cpp         ALGO_WLOG("Invalid parameter was passed to AlgoUtil_ValidateListenSocket.");
algojob_0.cpp         ALGO_ILOG("IPC0: re-initialize IPC Server: address=job0.ipc");
algojob_0.cpp             ALGO_ELOG("IPC0: Failed to re-initialize JOB0 IPC Server:%s, error=%s errno=%d", listen_address.c_str(), ALGOUTIL_ERROR_STR[ipc_error], sys_err_no);
algo_bin.cpp     ALGO_ILOG("[algo:%s] algo_bin: Destroyed. this=%p stats=[%s]", m_inst_id.to_string(), this, report_statistics());
algo_bin.cpp     ALGO_ELOG("[algo:%s] fail_algo_on_exception. reason=%s", m_inst_id.to_string(), reason);
algo_bin.cpp         ALGO_ILOG("[algo:%s] faile algo, impl is not created. algo will be removed.", m_inst_id.to_string());
algo_bin.cpp                         ALGO_ILOG("[algo:%s] user_id=%llu event=%s flushed_events=%zu (thread_context_events.size=%zu algo_bin_events.size=%zu)", m_inst_id.to_string(), m_user_id, request_id == algojob__request_pause ? "pause" : "cancel", flushed, thread_context_events.size(), algo_bin_events.size());
algo_bin.cpp                             ALGO_ELOG("[algo:%s] user_id=%llu event=%s. Too many flushed_events or algo failed previously on queue limit violation " "flushed_events=%zu and failing algo", m_inst_id.to_string(), m_user_id, request_id == algojob__request_pause ? "pause" : "cancel", flushed);
algo_bin.cpp                             ALGO_ILOG("[algo:%s] user_id=%llu event=%s. Executing flushed_events=%zu", m_inst_id.to_string(), m_user_id, request_id == algojob__request_pause ? "pause" : "cancel", flushed);
algo_bin.cpp                                 ALGO_ILOG("[algo:%s] user_id=%llu event=%s. Executed flushed_events=%zu", m_inst_id.to_string(), m_user_id, request_id == algojob__request_pause ? "pause" : "cancel", flushed);
algo_bin.cpp         ALGO_ILOG("[algo:%s] %s", m_inst_id.to_string(), str);
algo_bin.cpp                     ALGO_WLOG("[algo:%s] process_job_request_on_algo_thread: Failed to update FIX params for reject response: " "error=%s " "IGNORE this warning if FIX is not involved!", m_inst_id.to_string(), TTSDK_ERROR_STR[ttsdk_error]);
algo_bin.cpp                     ALGO_ILOG("[algo:%s] process_job_request_on_algo_thread: Updated FIX params for reject response", m_inst_id.to_string());
algo_bin.cpp                     ALGO_WLOG("[algo:%s] process_job_request_on_algo_thread: Failed to update CL_ORD_ID params for reject response: " "error=%s ", m_inst_id.to_string(), TTSDK_ERROR_STR[ttsdk_error]);
algo_bin.cpp                     ALGO_ILOG("[algo:%s] process_job_request_on_algo_thread: Updated CL_ORD_ID params for reject response cl_ord_id=%llu orig_cl_ord_id=%llu", m_inst_id.to_string(), cl_ord_id, orig_cl_ord_id);
algo_bin.cpp                 ALGO_ELOG("[algo:%s]Reject stale New order: " "request=[%s], " "user_request_id=%d, " "timeSent=%llu, " "timeRecd=%llu " "delay_ms=%llu, " "threshold_ms=%llu", m_inst_id.to_string(), ALGOJOB_REQUEST_ID_STR[request_id], request->user_request_id, timeSent, timeRecd, delay_ms, threshold_ms);
algo_bin.cpp         ALGO_ELOG( "internal_process_job_request: m_impl is null " "request=[%s], " "user_id=%llu " , ALGOJOB_REQUEST_ID_STR[request_id], request->user_id );
algo_bin.cpp     ALGO_ILOG("[algo:%s] algo_bin is being deactivated." " this=%p" " active=%d" " impl=%p", m_inst_id.to_string(), this, (bool)m_active, m_impl.get());
server_connection.cpp         ALGO_WLOG("Failed to connect to %s, job_id=%d, system errno=%d", address, job_id, sys_errno);
server_connection.cpp         ALGO_ILOG("Connected to %s, job_id=%d, m_pConnection=%p, m_pConnection->socket=%d", address, job_id, m_pConnection, m_pConnection->socket);
server_connection.cpp         ALGO_ELOG("Failed to send connect response to algo server %s. job_id=%d", address, job_id);
server_connection.cpp         ALGO_ELOG( "Error receiving server messages, job_id=%d, algoutil_error=%s, recvd_size=%zu, compressed_recvd_size=%zu errno=%s", m_job_id, ALGOUTIL_ERROR_STR[error], recvd_size, compressed_recvd_data_size, std::string(strerror(errno)) );
server_connection.cpp     ALGO_ILOG("Recevied AlgoServer Message: request=[%s] recvd_size=%zu compressed_recvd_size=%zu latency_us=%lu", ALGOJOB_REQUEST_ID_STR[request->id], recvd_size, compressed_recvd_data_size, latency_us);
server_connection.cpp         ALGO_ELOG("AlgoUtil_RecvMessage error. error=%s", ALGOUTIL_ERROR_STR[error]);
server_connection.cpp         ALGO_WLOG("No algoserver connection. Drop message type=%s", type);
server_connection.cpp         ALGO_ELOG("Failure sending %s [%s], [%s]", std::move(type), ALGOUTIL_ERROR_STR[error], std::string(strerror(errno)));
server_connection.cpp     ALGO_ILOG( "server_connection::send_loopback_order_request() sending size=%u", payload_size);
server_connection.cpp         ALGO_ELOG("Deserialization error. recvd_size_result=%zu cb=%zu", *recvd_size_result, cb);
adl_algo_bin_host_events.cpp     ALGO_ILOG( "[algo:%s]: process_external_request=[%s], state=%s", inst_id().to_string(), ALGOJOB_REQUEST_ID_STR[request->id], ALGO_STATE_STR[state] );
adl_algo_bin_host_events.cpp                 ALGO_ELOG("[algo:%s]: ADL Recovery is not supported - setting algo_state to [failed] and cleaning up child orders", inst_id().to_string());
adl_algo_bin_host_events.cpp                 ALGO_ELOG("[algo:%s] Request is missing algo version.", inst_id().to_string());
adl_algo_bin_host_events.cpp             ALGO_DLOG("[algo:%s] EPIQ_flag=%d", inst_id().to_string(), epiqFlag);
adl_algo_bin_host_events.cpp                 ALGO_WLOG("[algo:%s] Algo has no Export Value. Ignore reuqest=%s", inst_id().to_string(),ALGOJOB_REQUEST_ID_STR[request->id]);
adl_algo_bin_host_events.cpp                 ALGO_DLOG("Algo has no Export Value. Ignore reuqest=%s", ALGOJOB_REQUEST_ID_STR[request->id]);
adl_algo_bin_host_events.cpp             ALGO_DLOG("[algo:%s] Detected server disconnect but will ignore it!", inst_id().to_string());
adl_algo_bin_host_events.cpp             ALGO_ILOG( "[algo:%s] Updated OMA Parent ID on request: " "request=%s " "new_oma_parent_id=%s", inst_id().to_string(), ALGOJOB_REQUEST_ID_STR[request->id], std::string(oma_parent_uuid_string) );
adl_algo_bin_host_events.cpp             ALGO_ILOG( "[algo:%s] Cleared OMA Parent ID on request: " "request=%s", inst_id().to_string(), ALGOJOB_REQUEST_ID_STR[request->id] );
adl_algo_bin_host_events.cpp                 ALGO_ELOG("[algo:%s] algojob__request_order_pass: request_params was a nullptr", inst_id().to_string());
adl_algo_bin_host_events.cpp             ALGO_ILOG("[algo:%s] algojob__request_order_pass: Attempting to update params with: " "obp_state=%s " "current_group_id=%llu " "pass_to_group_id=%llu " "previous_pass_to_group_id=%llu " "original_group_id=%llu", inst_id().to_string(), std::string(OrderPassToString(obp_state)), current_group_id, pass_to_group_id, previous_pass_to_group_id, original_group_id);
adl_algo_bin_host_events.cpp                 ALGO_ELOG("[algo:%s] algojob__request_order_pass: Not allowed in current state=%s", inst_id().to_string(), std::string(ALGO_STATE_STR[state]));
adl_algo_bin_host_events.cpp                 ALGO_ELOG("[algo:%s] algojob__request_order_pass: Missing OBP state!", inst_id().to_string());
adl_algo_bin_host_events.cpp                     ALGO_ELOG("[algo:%s] algojob__request_order_pass: Missing current_group_id for OBP state=%s!", inst_id().to_string(), std::string(OrderPassToString(obp_state)));
adl_algo_bin_host_events.cpp                     ALGO_ELOG("[algo:%s] algojob__request_order_pass: Missing AlgoInstMgr for OBP state=%s!", inst_id().to_string(), std::string(OrderPassToString(obp_state)));
adl_algo_bin_host_events.cpp                 ALGO_ILOG("[algo:%s] algojob__request_order_pass: Set current and future child orders with %s", inst_id().to_string(), GroupIDsToString(group_ids));
adl_algo_bin_host_events.cpp             ALGO_ILOG("[algo:%s] algojob__request_order_pass: Success!", inst_id().to_string());
adl_algo_bin_host_events.cpp         ALGO_WLOG("[algo:%s] action=%s invalid: state=%s", inst_id().to_string(), ALGO_ACTION_STR[ action], ALGO_STATE_STR[m_host_if->get_state()]);
adl_algo_bin_host_events.cpp         ALGO_ILOG("[algo:%s] queue up action=%s. state=%s", inst_id().to_string(), ALGO_ACTION_STR[ action], ALGO_STATE_STR[m_host_if->get_state()]);
adl_algo_bin_host_events.cpp                  ALGO_ILOG("[algo:%s] signaler_id=%llu is stopped, dropped this event", inst_id().to_string(), event->signaler_id);
adl_algo_bin_host_events.cpp             ALGO_ILOG("[algo:%s] now process scheduled exit_block_graph m_globalVIndex=%llu", inst_id().to_string(), event->m_globalVIndex);
adl_algo_bin_host_events.cpp     ALGO_ILOG("[algo:%s]: process_compilation_completed_event: " "state=%s " "compile_reason=%s", inst_id().to_string(), ALGO_STATE_STR[state], instr_compile_reason_to_string(reason));
adl_algo_bin_host_events.cpp         ALGO_ILOG("[algo:%s]: hasAnalytics=%d analyticsBlockCount=%d", inst_id().to_string(), (dl()->algo_graph.analyticsBlockCount > 0), // keeping the boolean hasAnalytics for log-level compatibility dl()->algo_graph.analyticsBlockCount);
adl_algo_bin_host_events.cpp             ALGO_WLOG("[algo:%s]: Analytics Block usage is disabled on the server", inst_id().to_string());
adl_algo_bin_host_events.cpp             ALGO_WLOG("[algo:%s]: The number of Analytics Blocks in the algo (%d) exceeds the max allowed on the server (%d)", inst_id().to_string(), dl()->algo_graph.analyticsBlockCount, env::instance().max_analytics_blocks());
adl_algo_bin_host_events.cpp         ALGO_DLOG("[algo:%s]: Creating AlgoInstMgr with %s", inst_id().to_string(), GroupIDsToString(group_ids));
adl_algo_bin_host_events.cpp             ALGO_ILOG("[algo:%s]: process_compilation_completed_event: " "Asynchronously download child orders for recovery before continuing.", inst_id().to_string());
adl_algo_bin_host_events.cpp         ALGO_ELOG("%s", error);
adl_algo_bin_host_events.cpp     ALGO_ILOG("[algo:%s]: create_block_graph_and_init_action: " "Continue processing compilation completed event: " "state=%s " "compile_reason=%s", inst_id().to_string(), ALGO_STATE_STR[state], instr_compile_reason_to_string(reason));
adl_algo_bin_host_events.cpp         ALGO_ILOG("[algo:%s]: m_has_periodic_task=%d HasExportValue=%d hasAlert=%d hasPnL=%d", inst_id().to_string(), m_has_periodic_task, m_inst_if->HasExportValue(), dl()->algo_graph.hasAlert, m_algo_inst_mgr->m_hasPnl);
adl_algo_bin_host_events.cpp             ALGO_ILOG("[algo:%s]: will use account_id=%llu",inst_id().to_string(), accountId);
adl_algo_bin_host_events.cpp         ALGO_ELOG("%s", error);
adl_algo_bin_host_events.cpp     ALGO_ILOG("[algo:%s] process_action_failed_event: " "current_synth_status=%s " "next_synth_status=%s " "current_algo_state=%s " "next_algo_state=%s " "(note: current and next algo_state are expected to be both algojob__algo_failed) " "failed_action=%s", inst_id().to_string(), TTSDK_SYNTH_STATUS_STR[current_synth_status], TTSDK_SYNTH_STATUS_STR[next_synth_status], ALGO_STATE_STR[current_algo_state], ALGO_STATE_STR[next_algo_state], ALGOJOB_REQUEST_ID_STR[failed_action]);
adl_algo_bin_host_events.cpp         ALGO_ILOG("[algo:%s] process_action_failed_event: Skipping purge child orders to allow recovery to be retried.", inst_id().to_string());
adl_algo_bin_host_events.cpp     ALGO_ILOG("[algo:%s] process_action_complete_event:action=%s state=%s,", inst_id().to_string(), ALGO_ACTION_STR[action], ALGO_STATE_STR[state]);
adl_algo_bin_host_events.cpp     ALGO_WLOG("[algo:%s] request[%s][id:%llu] rejected. state=%s", inst_id().to_string(), ALGOJOB_REQUEST_ID_STR[request->id], request->user_request_id, ALGO_STATE_STR[state]);
adl_algo_bin_host_events.cpp         ALGO_ILOG("[algo:%s] suppress action", inst_id().to_string());
adl_algo_bin_host_events.cpp         ALGO_WLOG("[algo:%s] skip SetSuppressActionFlag. state=%s", inst_id().to_string(), ALGO_STATE_STR[state]);
adl_algo_bin_host_events.cpp         ALGO_ILOG("[algo:%s] Saving state to disk.", inst_id().to_string());
adl_algo_bin_host_events.cpp     ALGO_ILOG("[algo:%s] recover_children: Downloading children.", inst_id().to_string());
adl_algo_bin_host_events.cpp         ALGO_ILOG("[algo:%s] recover_children: Will attempt to delete PR child order (if any) because: " "is_sse_pr_enabled=%s", inst_id().to_string(), env::instance().is_sse_pr_enabled() ? "true" : "false");
adl_algo_bin_host_events.cpp     ALGO_ILOG("[algo:%s] on_children_recovered: " "state=%s " "result=%s " "children_count=%zu", inst_id().to_string(), ALGO_STATE_STR[state], result ? "true" : "false", size);
adl_algo_bin_host_events.cpp         ALGO_ELOG("[algo:%s] on_children_recovered: Download failed, declaring recovery failure!", inst_id().to_string());
adl_algo_bin_host_events.cpp     ALGO_ILOG("[algo:%s] on_children_recovered: Download success, printing recovered child order IDs.", inst_id().to_string());
adl_algo_bin_host_events.cpp             ALGO_ELOG("[algo:%s] on_children_recovered: Param for a recovered child was unexpectedly a nullptr: " "index=%zu", inst_id().to_string(), i);
adl_algo_bin_host_events.cpp             ALGO_ELOG("[algo:%s] on_children_recovered: Order ID missing for a recovered child: " "index=%zu", inst_id().to_string(), i);
adl_algo_bin_host_events.cpp         ALGO_ILOG("[algo:%s] on_children_recovered: " "index=%zu " "order_id=%s", inst_id().to_string(), i, order_id.to_string());
adl_algo_bin.cpp     ALGO_ILOG("[algo:%s]--------- Schedule Destroy adl_algo_bin ---------", inst_id().to_string());
adl_algo_bin.cpp     ALGO_ILOG("[algo:%s]========= Destroy adl_algo_bin =========", inst_id().to_string());
adl_algo_bin.cpp         ALGO_ILOG("[algo:%s] destroy inst_if %p", inst_id().to_string(), static_cast<void*>(m_inst_if));
adl_algo_bin.cpp             ALGO_ELOG( "[algo:%s] destroy adl_algo_bin. state=%s", inst_id().to_string(), ALGO_STATE_STR[m_state.load(std::memory_order_relaxed)] );
adl_algo_bin.cpp         ALGO_ILOG("[algo:%s] inst_if destroyed", inst_id().to_string());
adl_algo_bin.cpp                     ALGO_ILOG("[algo:%s] export_values=%d collect_values=%d force_collect=%d bool export value id=%s name=%s value=%d", inst_id().to_string(), (int)export_values, (int)collect_values, (int)force_collect, std::string(exportValue->blockAndConnectorId.c_str()), exportValue->name, (int)value.value);
adl_algo_bin.cpp                         ALGO_ELOG("[algo:%s] has more than %d export values", inst_id().to_string(), TTSDK_PARAM_MAX_COUNT );
adl_algo_bin.cpp                     ALGO_ILOG("[algo:%s] export_values=%d collect_values=%d force_collect=%d INT export value id=%s name=%s value=%d", inst_id().to_string(), (int)export_values, (int)collect_values, (int)force_collect, std::string(exportValue->blockAndConnectorId.c_str()), exportValue->name, value.value);
adl_algo_bin.cpp                         ALGO_ELOG("[algo:%s] has more than %d export values", inst_id().to_string(), TTSDK_PARAM_MAX_COUNT );
adl_algo_bin.cpp                     ALGO_ILOG("[algo:%s] export_values=%d collect_values=%d force_collect=%d REAL export value id=%s name=%s value=%f", inst_id().to_string(), (int)export_values, (int)collect_values, (int)force_collect, std::string(exportValue->blockAndConnectorId.c_str()), exportValue->name, (double)value.value);
adl_algo_bin.cpp                         ALGO_ELOG("[algo:%s] has more than %d export values", inst_id().to_string(), TTSDK_PARAM_MAX_COUNT );
adl_algo_bin.cpp                         ALGO_ELOG("[algo:%s] has more than %d export values", inst_id().to_string(), TTSDK_PARAM_MAX_COUNT );
adl_algo_bin.cpp                 ALGO_ILOG( "TryCollectAndSendValues when forceToCollect: export_values_data.count=%d", export_values_data.count );
adl_algo_bin.cpp         ALGO_ILOG("[algo:%s] Suppressed sending status", inst_id().to_string());
adl_algo_bin.cpp             ALGO_ILOG("[algo:%s] Suppressed sending status", inst_id().to_string());
adl_algo_bin.cpp     ALGO_ELOG("[algo:%s] fail_algo_on_exception. reason=%s ", inst_id().to_string(), reason);
algojob.cpp     ALGO_ILOG("LoopBackToServer: size=%lu", payload_size);
algojob.cpp         ALGO_ILOG("Stop and Join m_job_qa_thread");
algojob.cpp         ALGO_ELOG("No Job0 for question type=%d", question_copy->type);
algojob.cpp     ALGO_ILOG("Question: question_id=%llu", question_id);
algojob.cpp                                                     ALGO_ILOG("Question: send to job0 question_id=%llu error=%s", question_copy->question_id, ALGOUTIL_ERROR_STR[error]);
algojob.cpp             ALGO_ELOG("Question: question_id=%llu timeout", question_id);
algojob.cpp         ALGO_ELOG("Question: question_id=%llu has no answer", question_id);
algojob.cpp     ALGO_ILOG("ConfigXml: simulation_mode=%u", isSim);
algojob.cpp     ALGO_ILOG("ConfigXml: thread_mode=%d", thr_mode);
algojob.cpp     ALGO_ILOG("ConfigXml: thread_pool_count=%d", thread_pool_count);
algojob.cpp     ALGO_ILOG("ConfigXml: algo_thread_static_affinities=%s", algo_thread_static_affinities);
algojob.cpp         ALGO_ELOG("Failed to initialize OrderD");
algojob.cpp         ALGO_ELOG("Failed to start controller");
algojob.cpp     ALGO_ILOG("Initializing pricelib");
algojob.cpp         ALGO_ELOG("Failed to initialize pricefs lib");
algojob.cpp         ALGO_ELOG("Failed to init ADL resource");
algojob.cpp     ALGO_ILOG("Algojob (%s) Started. Sleep 2 seconds so JOB0 can connect...", is_algoserver_debug ? "algoserver_debug" : "algoserver_exec");
algojob.cpp             ALGO_WLOG("Remove sockect=%d from s_job0_epoll_file=%d", s_job0_connection->socket, s_job0_epoll_file);
algojob.cpp         ALGO_WLOG("Closing s_job0_epoll_file=%d", s_job0_epoll_file);
algojob.cpp         ALGO_WLOG("Error loading plugin [%s]: %s", info.pluginName, info.loadError);
algojob.cpp         ALGO_ELOG( "Error(s) loading plugins: %#x, num blocks: %d", error, plugin_loader.blockIfLib.BlockCount() );
algojob.cpp         ALGO_ELOG("Failed to load standard_blocks.");
algojob.cpp         ALGO_ELOG("Failed to create precompile_path, err=%s", ALGOUTIL_ERROR_STR[algoutil_error]);
algojob.cpp         ALGO_ILOG("successfully create precompile_path=%s",std::string(precompile_path));
algojob.cpp         ALGO_ELOG("PrecompileCommon failed. %s", std::string(compiler_command));
algojob.cpp     ALGO_ILOG("PrecompileCommon succeed: compiler_command=%s", std::string(compiler_command));
algojob.cpp         ALGO_ELOG( "Could not delete unifierConfig=%s, error=%d", unifier_config_file, error);
algojob.cpp     ALGO_ILOG("Trying to connect to JOB0");
algojob.cpp         ALGO_WLOG("Failed to connect to JOB0 IPC: job0.ipc error=%s, system errno=%d", ALGOUTIL_ERROR_STR[error], sys_errno);
algojob.cpp     ALGO_ILOG("Connected to JOB0: socket=%d", s_job0_connection->socket);
algojob.cpp         ALGO_ELOG("IPC: Failed to epoll_create s_job0_epoll_file");
algojob.cpp     ALGO_ILOG("IPC: epoll_create s_job0_epoll_file=%d", s_job0_epoll_file);
algojob.cpp         ALGO_ELOG("IPC: Failed to add socket=%d to s_job0_epoll_file. error=%s", s_job0_connection->socket, ALGOUTIL_ERROR_STR[error]);
algojob.cpp         ALGO_ILOG("IPC: Add socket=%d to s_job0_epoll_file", s_job0_connection->socket);
algojob.cpp     ALGO_ILOG("IPC: JobAnswerReceiverThread starting......");
algojob.cpp                 ALGO_ELOG("IPC: epoll_wait received EINVAL(Invalid argument). Reconnect to Job0", errno);
algojob.cpp                 ALGO_ELOG("IPC: epoll_wait received signal_count==-1 errno=%d job zero died?", errno);
algojob.cpp                 ALGO_ILOG("IPC: receive Hangup s_job0_connection=%p epoll_data=%p job zero died?", s_job0_connection.get(), epoll_data);
algojob.cpp                     ALGO_ELOG("IPC: AlgoUtil_RecvMessage error=%s. Closing connection to job zero", ALGOUTIL_ERROR_STR[err]);
algojob.cpp     ALGO_ILOG("IPC: JobAnswerReceiverThread stopping......");
algojob.cpp         ALGO_ILOG("Answer: RL update: topic=%s", std::string(answer->data.synthetic_server_topic));
algojob.cpp         ALGO_ILOG("Answer: RL query: topic=%s", std::string(answer->data.synthetic_server_topic));
algojob.cpp                 ALGO_ELOG("Answer: but question_id=%llu not in map!!", answer->question.question_id);
algojob.cpp         ALGO_WLOG("Answer: but type unknown");
controller.cpp     ALGO_ILOG("Start controller...n_threads=%d cpu_affinities=%s", n_threads, cpu_affinities);
controller.cpp         ALGO_ELOG("Failed to start periodic timer. %s", std::string(err.what()));
controller.cpp         ALGO_ILOG("Stop algojob threads");
controller.cpp         ALGO_ILOG("Join algojob threads");
controller.cpp             ALGO_ILOG( "create new algo_bin with inst_id=%s user_id=%llu request_id=%s total m_algos.size()=%d on reserved algo thread", inst_id.to_string(), request->user_id, ALGOJOB_REQUEST_ID_STR[request->id], m_algos.size() );
controller.cpp             ALGO_ILOG( "create new algo_bin with inst_id=%s user_id=%llu request_id=%s total m_algos.size()=%d, job_thread_index=%d", inst_id.to_string(), request->user_id, ALGOJOB_REQUEST_ID_STR[request->id], m_algos.size(), job_thread_index );
controller.cpp     ALGO_ELOG("create_algo unexpectedly found existing inst_id=%s user_id=%llu request_id=%s! " "Sending request-failure back to server!", inst_id.to_string(), request->user_id, ALGOJOB_REQUEST_ID_STR[request->id] );
controller.cpp         ALGO_WLOG("search_algo can NOT find inst_id=%s user_id=%llu request_id=%s ", inst_id.to_string(), request->user_id, ALGOJOB_REQUEST_ID_STR[request->id] );
controller.cpp     ALGO_ILOG( "Parsing reserved users %s", reserved_users);
controller.cpp         ALGO_ILOG( "Add reserved user %s", user_id);
request_receiver.cpp         ALGO_ELOG("epoll_create failed. err: %s", strerror(errno));
request_receiver.cpp     ALGO_ILOG("epoll_create m_epoll_file=%d", m_epoll_file);
request_receiver.cpp         ALGO_ELOG("failed to set epoll file %s", ALGOUTIL_ERROR_STR[algoutil_error]);
request_receiver.cpp                 ALGO_ILOG("Re-connected to algoserver");
request_receiver.cpp                     ALGO_ELOG("Failed to connect to algoserver for 2 hours");
request_receiver.cpp                     ALGO_ELOG("epoll_wait failure: m_epoll_file=%d errno=%s", m_epoll_file, strerror(errno) );
request_receiver.cpp             ALGO_ILOG(std::string(err.what()));
request_receiver.cpp     ALGO_ILOG("request: %d", request->id);
request_receiver.cpp             ALGO_ILOG("update token: user_id=%llu, token=%s ......", request->user_id, std::string(request->data.token, 48));
request_receiver.cpp             ALGO_ILOG("saved token to env: user_id=%llu, token=%s ......", request->user_id, std::string(saved_token, 48));
request_receiver.cpp             ALGO_ILOG("update user: %llu", request->user_id);
request_receiver.cpp             ALGO_ELOG("Should not have received this request->id=%s", ALGOJOB_REQUEST_ID_STR[request->id]);
request_receiver.cpp                     ALGO_WLOG("[algo:%s] receive_algojob_request: Failed to update FIX params for reject response: " "error=%s " "IGNORE this warning if FIX is not involved!", inst_id.to_string(), TTSDK_ERROR_STR[ttsdk_error]);
request_receiver.cpp                     ALGO_ILOG("[algo:%s] receive_algojob_request: Updated FIX params for reject response", inst_id.to_string());
request_receiver.cpp                     ALGO_WLOG("[algo:%s] receive_algojob_request: Failed to update CL_ORD_ID params for reject response: " "error=%s ", inst_id.to_string(), TTSDK_ERROR_STR[ttsdk_error]);
request_receiver.cpp                     ALGO_ILOG("[algo:%s] receive_algojob_request: Updated CL_ORD_ID params for reject response cl_ord_id=%llu orig_cl_ord_id=%llu", inst_id.to_string(), cl_ord_id, orig_cl_ord_id);
request_receiver.cpp         ALGO_ELOG("Failed to receive deploy_def message. Can not allocate with size of %d", def_size + 1);
request_receiver.cpp         ALGO_ELOG( "Error receiving data, request=[%s], recvd_def_size=%u, err=%s", ALGOJOB_REQUEST_ID_STR[request->id], recvd_def_size, std::string(strerror(errno)) );
so_algo_bin.cpp         ALGO_ILOG("[algo:%s] set_state old=%s new=%s", inst_id().to_string(), ALGO_STATE_STR[old_state], ALGO_STATE_STR[new_state]);
so_algo_bin.cpp         ALGO_ELOG("[algo:%s] is loosing broker_id !!!!!!!!!! state=%s", inst_id().to_string(), ALGO_STATE_STR[get_state()]);
so_algo_bin.cpp             ALGO_ELOG("[algo:%s] recover from exising broker_id=%llu", inst_id().to_string(), broker_id);
so_algo_bin.cpp     ALGO_ILOG( "[algo:%s] destroy so_algo_bin %p", inst_id().to_string(), this );
so_algo_bin.cpp             ALGO_WLOG( "finish_pending_action invoked while not in valid transitional state. State=%s", ALGO_STATE_STR[algo_state] );
so_algo_bin.cpp     ALGO_ILOG( "finish_pending_action, old_state=%s new_state=%s code=%s", ALGO_STATE_STR[algo_state], ALGO_STATE_STR[next_job_state], TTSDK_ERROR_STR[error_code] );
so_algo_bin.cpp             ALGO_ILOG("finish_pending_action - set exec_restatement_reason to REPLACED.");
so_algo_bin.cpp             ALGO_WLOG("[algo:%s] finish_pending_action: Failed to update CL_ORD_ID params for pause response: " "error=%s ", inst_id().to_string(), TTSDK_ERROR_STR[ttsdk_error]);
so_algo_bin.cpp             ALGO_ILOG("[algo:%s] finish_pending_action: Updated CL_ORD_ID params for pause response cl_ord_id=%llu orig_cl_ord_id=%llu", inst_id().to_string(), cl_ord_id, orig_cl_ord_id);
so_algo_bin.cpp             ALGO_ILOG("finish_pending_action - set exec_restatement_reason to REPLACE-REJECTED.");
so_algo_bin.cpp             ALGO_WLOG("[algo:%s] finish_pending_action: Failed to update FIX params for reject response: " "error=%s " "IGNORE this warning if FIX is not involved!", inst_id().to_string(), TTSDK_ERROR_STR[ttsdk_error]);
so_algo_bin.cpp             ALGO_ILOG("[algo:%s] finish_pending_action: Updated FIX params for reject response", inst_id().to_string());
so_algo_bin.cpp             ALGO_WLOG("[algo:%s] finish_pending_action: Failed to update CL_ORD_ID params for reject response: " "error=%s ", inst_id().to_string(), TTSDK_ERROR_STR[ttsdk_error]);
so_algo_bin.cpp             ALGO_ILOG("[algo:%s] finish_pending_action: Updated CL_ORD_ID params for reject response cl_ord_id=%llu orig_cl_ord_id=%llu", inst_id().to_string(), cl_ord_id, orig_cl_ord_id);
so_algo_bin.cpp         ALGO_ILOG( "[algo:%s] so_algo_bin::pause_algo fail, state=%s ", inst_id().to_string(), ALGO_STATE_STR[algo_state] );
so_algo_bin.cpp         ALGO_ILOG( "[algo:%s] so_algo_bin::stop_algo. Algo already in state=%s ", inst_id().to_string(), ALGO_STATE_STR[algo_state] );
so_algo_bin.cpp         ALGO_ILOG( "[algo:%s] so_algo_bin::stop_algo fail, state=%s ", inst_id().to_string(), ALGO_STATE_STR[algo_state] );
so_algo_bin.cpp         ALGO_ELOG( "[algo:%s] fail_algo_on_exception state=%s reason=%s", inst_id().to_string(), ALGO_STATE_STR[algo_state], reason );
so_algo_bin.cpp     ALGO_ILOG("%s", ss.str());
adl_algo_bin_service_events.cpp         ALGO_ILOG("[algo:%s]: will use instrument_id=%llu (order instrument)",inst_id().to_string(),orderInstrId);
adl_algo_bin_service_events.cpp             ALGO_ILOG("[algo:%s]: will use instrument_id=%llu",inst_id().to_string(),instrId);
adl_algo_bin_service_events.cpp         ALGO_ILOG("[algo:%s] download_instr: instr_id=%llu on service thread", inst_id().to_string(), instr_id);
adl_algo_bin_service_events.cpp             ALGO_ELOG("download_instr: Instrument download failed, instr_id=%llu, error=%s", instr_id, tt::sdk::internal::to_string(dl_result.first));
adl_algo_bin_service_events.cpp             ALGO_ELOG("compile_instr: Algo def download failed." " instr_id=%llu" " error=%s", algo_instr_id, reason);
adl_algo_bin_service_events.cpp             ALGO_ELOG("compile_instr: Algo def not found, likely the algo is not approved." " instr_id=%llu", algo_instr_id);
adl_algo_bin_service_events.cpp             ALGO_ELOG("compile_instr: Resource download failed." " instr_id=%llu" " error=%s", algo_instr_id, reason);
adl_algo_bin_service_events.cpp         ALGO_ILOG("[algo: %s] Cancel compile_def. algo stopping", inst_id().to_string());
adl_algo_bin_service_events.cpp     ALGO_ILOG("[algo:%s] compile_def: Attempting to deploy algo resource: %s...", inst_id().to_string(), algo_resource.substr(0,10));
adl_algo_bin_service_events.cpp             ALGO_ELOG("[algo:%s] instr_id=%llu already exist", inst_id().to_string(), instr_id);
adl_algo_bin_service_events.cpp         ALGO_ILOG("[algo:%s] parsing algo resource...", inst_id().to_string());
adl_algo_bin_service_events.cpp             ALGO_ELOG( "[algo:%s] Error [%s] parsing algo XML at line: %u, source: %s, source param: %s, error msg: %s sourceCodeLineNumber: %u", inst_id().to_string(), GRAPH_ERROR_ID_STR[info.errorId], info.lineNumber, BLOCK_SOURCE_STR[info.sourceInfo.source], info.sourceInfo.param, info.msg, info.sourceCodeLineNumber );
adl_algo_bin_service_events.cpp                 ALGO_ELOG("[algo:%s] compile_def: failed to write xml source to file. error=%s", inst_id().to_string(), std::string(strerror(errno)));
adl_algo_bin_service_events.cpp                 ALGO_ILOG("[algo:%s] compile_def: xml source written to file %s", inst_id().to_string(), std::string(xml_path));
adl_algo_bin_service_events.cpp             ALGO_ELOG("[algo:%s] compile_def: parser_error=%s \n root_def_uuid_string=%s \n algo_resource=%s", inst_id().to_string(), PARSER_ERROR_STR[parser_error], std::string(root_def_uuid_string), algo_resource.substr(0,200));
adl_algo_bin_service_events.cpp             ALGO_ILOG("Cancel compile_def, [algo: %s] request for stopping", inst_id().to_string());
adl_algo_bin_service_events.cpp         ALGO_ILOG("[algo:%s] emitting algo source code... to %s", inst_id().to_string(), std::string(source_path));
adl_algo_bin_service_events.cpp         ALGO_ILOG("Special warning: %s", special_warning.str());
adl_algo_bin_service_events.cpp             ALGO_ELOG("[algo:%s] compile_def: failed to write generated algo source to file. error=%s", inst_id().to_string(), std::string(strerror(errno)));
adl_algo_bin_service_events.cpp             ALGO_ILOG("Cancel compile_def, [algo: %s] request for stopping", inst_id().to_string());
adl_algo_bin_service_events.cpp         ALGO_ILOG("[algo:%s] compiling algo source code...", inst_id().to_string());
adl_algo_bin_service_events.cpp             ALGO_ELOG("[algo:%s] compile_def: compilation failed.", inst_id().to_string());
adl_algo_bin_service_events.cpp         ALGO_ILOG("[algo:%s] CompileSource called: compiler_command=%s", inst_id().to_string(), std::string(compiler_command));
adl_algo_bin_service_events.cpp             ALGO_ILOG("[algo: %s] Cancel compile_def. algo stopping", inst_id().to_string());
adl_algo_bin_service_events.cpp         ALGO_ILOG("[algo:%s] Load algo shared object %s", inst_id().to_string(), std::string(compiled_instr_path));
adl_algo_bin_service_events.cpp             ALGO_ELOG("[algo:%s] CompileDef: Error loading algo: %s", inst_id().to_string(), failure_string);
adl_algo_bin_service_events.cpp             ALGO_ELOG("[algo:%s] compile_def: InitAlgo failed.", inst_id().to_string());
adl_algo_bin_service_events.cpp         ALGO_ILOG("[algo:%s] about to collect_instr. m_dl=%p", inst_id().to_string(), dl_ptr);
adl_algo_bin_service_events.cpp         ALGO_ELOG("[algo:%s] compile_def: EmitSource failed=%s",inst_id().to_string(), std::string(ex.what()));
main.cpp         ALGO_ILOG("SigActionHandler: sig=%d. Shutting down", sig);
main.cpp         ALGO_ILOG("SigUsrSigHandler: ignoring unsupported signal=%d. To control the logging level, please use algocli ", sig);
main.cpp             ALGO_ILOG("SetSigAction replacing.... signal=%d, error=%d, %s", sig, error, std::string(strerror(errno)));
main.cpp         ALGO_ILOG("SIGHUP received");
main.cpp         ALGO_ILOG("job_id=%d, job_ptr=%p", job_id, job);
main.cpp         ALGO_ILOG("algojob__algoserver_address=%s", algojob__algoserver_address);
main.cpp         ALGO_ILOG("instance_identifier=%s", instance_identifier);
main.cpp         ALGO_ILOG("ConfigXml: compiler=%s", compiler);
main.cpp         ALGO_ILOG("ConfigXml: min_log_level=%d", static_cast<int>(algojob__min_log_level));
main.cpp         ALGO_ILOG("ConfigXml: remote_services=%d", static_cast<int>(algojob__is_remote));
main.cpp         ALGO_ILOG("ConfigXml: algojob__persist_xml=%d", static_cast<int>(algojob__persist_xml));
main.cpp         ALGO_ILOG("ConfigXml: collect_order_changes_stats=%d", static_cast<int>(collect_order_changes_stats));
main.cpp         ALGO_ILOG("ConfigXml: skip_should_apply_log_interval=%d", skip_should_apply_log_interval);
main.cpp         ALGO_ILOG("ConfigXml: skip_order_change_log_interval=%d", skip_order_change_log_interval);
main.cpp         ALGO_ILOG("ConfigXml: circular_loop_check=%d", (int) circular_loop_check);
main.cpp         ALGO_ILOG("ConfigXml: circular_loop_limit=%lu", circular_loop_limit);
main.cpp         ALGO_ILOG("ConfigXml: max_recursion_level=%d", max_recursion_level);
main.cpp         ALGO_ILOG("ConfigXml: send_ahead_interval_ms=%d", send_ahead_interval_ms);
main.cpp             ALGO_ILOG("Detected ASAN_OPTIONS=%s", std::string(asan_options));
main.cpp             ALGO_ILOG("Note: ASAN_OPTIONS are not defined when running instrumented build");
main.cpp         ALGO_ILOG("Initializing AlgoJob. build_date=" BUILD_DATE " build_commit=" BUILD_COMMIT);
main.cpp                 ALGO_ILOG("%s=%s", std::string(preloadEnv), std::string(preloadVal));
main.cpp                 ALGO_ILOG("%s=NULL", std::string(preloadEnv));
main.cpp                 ALGO_ILOG("Onload is enabled");
main.cpp                 ALGO_ILOG("Onload is not enabled");
main.cpp             ALGO_ELOG("Failed to connect to AlgoServer");
main.cpp                 ALGO_ELOG(oss.str());
main.cpp             ALGO_ELOG("Failed to init PDS. url=%s", pds_url);
main.cpp             ALGO_ELOG("Failed to start job.");
main.cpp             ALGO_WLOG("Failed to Preload SSE algos. Ignoring and continuing the initialization");
main.cpp             ALGO_ILOG("Analytics disabled via config. Continuing initializing Analytics components in case it's later enabled via CLI");
main.cpp             ALGO_ILOG("Analytics Initialization succeeded");
main.cpp             ALGO_ELOG("Analytics Initialization failed but continuing anyway");
main.cpp         ALGO_ELOG("Failed during startup! main_flags=%s, job_ptr=%p", flags.to_string(), job);
main.cpp     ALGO_ILOG("Shutting down. main_flags=%s", main_flags.to_string());
main.cpp             ALGO_ELOG("Incorrect AnalyticsConfig %s", analyticsConfig.ToString());
main.cpp             ALGO_ELOG("Incorrect ScheduleConfig %s", scheduleConfig.ToString());
main.cpp         ALGO_ILOG("AnalyticsConfig %s ScheduleConfig %s", analyticsConfig.ToString(), scheduleConfig.ToString());
main.cpp             ALGO_ELOG("AnalyticsEngine initialization failed");
comm_websocket.cpp     SERVER_ILOG("comm_websocket: New client connection_id: %llu", next_connection_id);
comm_websocket.cpp                 SERVER_ELOG("comm_websocket: decode_request_failed");
comm_websocket.cpp                 SERVER_ELOG("Invalid token. [%s]", std::string(e.what()));
comm_websocket.cpp         SERVER_ELOG( "comm_websocket: Failure processing received data [%u], remaining_size [%u]", algoserver_error, remaining_size );
comm_websocket.cpp             SERVER_ELOG("comm_websocket: Failure sending response [%u]", websocket_error);
comm_websocket.cpp                         SERVER_DLOG("WebSocket::JobValue: active=%u, map[0].size=%u map[1].size=%u", algo->activeIndex, algo->mapBlockDefValues[0].size(), algo->mapBlockDefValues[1].size() );
comm_websocket.cpp             SERVER_ELOG("comm_websocket: Failure encoding forwarded data [%u]", algoserver_error);
comm_websocket.cpp             SERVER_ELOG("comm_websocket: Failure servicing websocket [%d]", error);
comm_websocket.cpp     SERVER_ILOG("ConfigXml: port=%d", port);
comm_websocket.cpp     SERVER_ILOG("ConfigXml: use_ssl=%d", use_ssl);
comm_websocket.cpp     SERVER_ILOG("AlgoServer::comm_websocket context destroyed...");
ttus_user.cpp         SERVER_ELOG("Failed to get all SecurityExchanges from PDS. error=%d", ex.what());
ttus_user.cpp     SERVER_ILOG("Get SecurityExchanges from PDS. security_exchanges.size()=%d", security_exchanges.size());
ttus_user.cpp         SERVER_ILOG("AlgoSettings for account=%llu algosettings=[%s]", account.id(), account.algo_settings().ShortDebugString().to_std());
ttus_user.cpp     SERVER_ILOG("TTUSWeb::Init creating ttus_handler: configFile=%s max_ttus_workers=%d enable_ttus_file_cache=%s", configFile, max_ttus_workers, enable_ttus_file_cache_str);
ttus_user.cpp     SERVER_ILOG("TTUSWeb::Init sizeof(user_obj)=%llu ", sizeof(user_obj));
ttus_user.cpp         SERVER_ELOG("ProcessUserResponse: %s Response NOT OK. response.code=%s", whichAPI, TTUS_ResponseCodeToString(response.code));
ttus_user.cpp         SERVER_ELOG("ProcessUserResponse: %s Response OK, but size=%d", whichAPI, size);
ttus_user.cpp     SERVER_ILOG("ProcessSingleUser: Processing result from %s for user_id=%llu user_obj=[%s]", whichAPI, user_id, user.ShortDebugString().to_std());
ttus_user.cpp             SERVER_WLOG("ProcessSingleUser: Unexpected! Could not find user_id=%llu in collection!", user_id);
ttus_user.cpp         SERVER_ELOG("ProcessSingleUser: user_id=%llu does not have person_id!", user_id);
ttus_user.cpp         SERVER_ILOG("ProcessSingleUser: From %s user_id=%llu. user.account_ids_size()=%d user.account_settings_size()=%d" , whichAPI, user_id, user.account_ids_size(), user.account_settings_size());
ttus_user.cpp             SERVER_ELOG("ProcessSingleUser: Too many accounts - dropping some accounts that are over the processing limit!");
ttus_user.cpp                 SERVER_ELOG("ProcessSingleUser: User updated with a NEW account=%llu that has not reached us. " "Run CLI --ResetUserInfo for user_id=%llu", account_id, user_id);
ttus_user.cpp             SERVER_ELOG("ProcessSingleUser: user.account_settings_size() != user.account_ids_size()");
ttus_user.cpp         SERVER_ILOG("ProcessSingleUser: From %s user_id=%llu. user.exchange_product_groups_size()=%d", whichAPI, user_id, user.exchange_product_groups_size());
ttus_user.cpp             SERVER_ELOG("ProcessSingleUser: Too many exchange_product_groups - dropping some exchange_product_groups that are over the processing limit!");
ttus_user.cpp                     SERVER_ELOG("ProcessSingleUser: Can not find security_exchange_id for exchange_id=%u identifier=%s ", key.market_id, key.name);
ttus_user.cpp         SERVER_ILOG("ProcessSingleUser: From %s user_id=%llu require_permission_to_run_own_algo=%d. " , whichAPI, user_id, userPtr->require_permission_to_run_own_algo);
ttus_user.cpp             SERVER_ILOG("ProcessSingleUser: From %s user_id=%llu sim_party_id=%llu. ", whichAPI, user_id, sim_party_id);
ttus_user.cpp             SERVER_ELOG("ProcessSingleUser: From %s user_id=%llu sim_party_id changed, this is not supported! old_party_id=%llu new_party_id=%llu", whichAPI, user_id, userPtr->sim_party_id, sim_party_id);
ttus_user.cpp         SERVER_ILOG("ProcessSingleUser: From %s user_id=%llu. user.custom_fields_size()=%d", whichAPI, user_id, user.custom_fields_size());
ttus_user.cpp             SERVER_ELOG("ProcessSingleUser: Too many custom_fields - dropping some custom_fields that are over the processing limit!");
ttus_user.cpp         SERVER_ILOG("<--All Info " "user_id=%llu " "user_company_id=%llu " "require_permission_to_run_own_algo=%d " "account_count=%zu " "market_data_count=%zu " "person_id=%llu " "company_enable_algo_risk_checks=%d " "company_enable_near_far_touch_price_reasonability=%d " "sim_party_id=%llu ", p->user_id, p->user_company_id, p->require_permission_to_run_own_algo, p->account_count, p->market_data_count, p->person_id, p->company_enable_algo_risk_checks, p->company_enable_near_far_touch_price_reasonability, p->sim_party_id);
ttus_user.cpp             SERVER_ILOG("<-----account_id=%llu, broker_id=%llu, account_company_id=%llu", p->ptr_accounts[i].account_id, p->ptr_accounts[i].broker_id, p->ptr_accounts[i].account_company_id);
ttus_user.cpp             SERVER_ILOG("<--------algo_permission=[" "ttsdk=%d" " adl=%d" " timed=%d" " stop=%d" " if_touched=%d" " trailing_limit=%d" " oco=%d" " bracket=%d" " iceberg=%d" " time_duration=%d" " time_slicer=%d" " retry=%d" " WAT=%d" " obv=%d" " auto_hedger=%d" " volume_slicer=%d" " volume_duration=%d]", p->ptr_accounts[i].algo_permission.ttsdk, p->ptr_accounts[i].algo_permission.adl, p->ptr_accounts[i].algo_permission.tt_timed, p->ptr_accounts[i].algo_permission.tt_stop, p->ptr_accounts[i].algo_permission.tt_if_touched, p->ptr_accounts[i].algo_permission.tt_trailing_limit, p->ptr_accounts[i].algo_permission.tt_oco, p->ptr_accounts[i].algo_permission.tt_bracket, p->ptr_accounts[i].algo_permission.tt_iceberg, p->ptr_accounts[i].algo_permission.tt_time_duration, p->ptr_accounts[i].algo_permission.tt_time_slicer, p->ptr_accounts[i].algo_permission.tt_retry, p->ptr_accounts[i].algo_permission.tt_with_a_tick, p->ptr_accounts[i].algo_permission.tt_obv, p->ptr_accounts[i].algo_permission.tt_auto_hedger, p->ptr_accounts[i].algo_permission.tt_volume_slicer, p->ptr_accounts[i].algo_permission.tt_volume_duration);
ttus_user.cpp             SERVER_ILOG("<--------%s", ToString(p->ptr_accounts[i].algo_settings));
ttus_user.cpp             SERVER_ILOG("<-----exchange_id=%zu, security_exchange_id=%zu, %s %s", p->market_data[i].exchange_id, p->market_data[i].security_exchange_id, p->market_data[i].is_all_market ? "all ": "individual", p->market_data[i].allowed ? "allowed ": "not allowed");
ttus_user.cpp             SERVER_ILOG("<-----company_id=%llu, name=%s, value=%s", p->custom_fields[i].company_id, std::string(p->custom_fields[i].name), std::string(p->custom_fields[i].value));
ttus_user.cpp     SERVER_ILOG("SyncDownloadUser: user_id=%llu downloading from Admin API...", user_id);
ttus_user.cpp     SERVER_ILOG("SyncDownloadUser: user_id=%llu downloaded from Admin API: response_code=%s", user_id, TTUS_ResponseCodeToString(admin_api_response.code));
ttus_user.cpp         SERVER_DLOG("SyncDownloadUser: Printing raw response=%s response_size=%d", admin_api_response.response->ShortDebugString().to_std(), admin_api_response.response->ByteSize());
ttus_user.cpp     SERVER_ILOG("SyncDownloadUser: user_id=%llu downloading from Risk API...", user_id);
ttus_user.cpp     SERVER_ILOG("SyncDownloadUser: user_id=%llu downloaded from Risk API: response_code=%s", user_id, TTUS_ResponseCodeToString(risk_api_response.code));
ttus_user.cpp         SERVER_DLOG("SyncDownloadUser: Printing raw response=%s response_size=%d", risk_api_response.response->ShortDebugString().to_std(), risk_api_response.response->ByteSize());
ttus_user.cpp         SERVER_ELOG("SyncDownloadUser: ADMIN API Response NOT OK - sending FAILED result to Server Thread: response.code=%s", TTUS_ResponseCodeToString(admin_api_response.code));
ttus_user.cpp         SERVER_ELOG("SyncDownloadUser: RISK API Response NOT OK - sending FAILED result to Server Thread: response.code=%s", TTUS_ResponseCodeToString(risk_api_response.code));
ttus_user.cpp         SERVER_ILOG("SyncDownloadUser: For user_id=%llu, both ADMIN API and RISK API Responses are OK! " "Now processing responses and adding user_obj to m_users collection!", user_id);
ttus_user.cpp         SERVER_ILOG("SyncDownloadUser: user_id=%llu processed Admin API response: process_result=%s", user_id, std::string(admin_api_process_result ? "success" : "failure"));
ttus_user.cpp         SERVER_ILOG("SyncDownloadUser: user_id=%llu processed Risk API response: process_result=%s", user_id, std::string(risk_api_process_result ? "success" : "failure"));
ttus_user.cpp             SERVER_ILOG("SyncDownloadUser: user_id=%llu detach worker. m_workersForUserDownload.size()=%d ", user_id, m_workersForUserDownload.size());
ttus_user.cpp             SERVER_ELOG("SyncDownloadUser: user_id=%llu. worker_thread no longer in map!! m_workersForUserDownload.size()=%d", user_id, m_workersForUserDownload.size());
ttus_user.cpp             SERVER_ILOG("AsyncDownloadUser: user_id=%llu has already been downloaded", user_id);
ttus_user.cpp         SERVER_WLOG("AsyncDownloadUser: user_id=%llu is currently running", user_id);
ttus_user.cpp         SERVER_ELOG("AsyncDownloadUser: Too many ttus worker threads. m_workersForUserDownload.size()=%d", m_workersForUserDownload.size());
ttus_user.cpp     SERVER_ILOG("AsyncDownloadUser: user_id=%llu starts...", user_id);
ttus_user.cpp         SERVER_ILOG("DownloadConnectionsSync response OK, response.response->update().size()=%d", size);
ttus_user.cpp         SERVER_ELOG("DownloadConnectionsSync response NOT OK. response.code=%s", TTUS_ResponseCodeToString(response.code));
ttus_user.cpp             SERVER_ILOG("SyncDownloadSpecificConnections response OK: " "id=%llu " "response.response->update().size()=%d", id, size);
ttus_user.cpp             SERVER_ELOG("SyncDownloadSpecificConnections response NOT OK: " "problematic_id=%llu " "response.code=%s", id, TTUS_ResponseCodeToString(response.code));
ttus_user.cpp         SERVER_ILOG("DownloadAccountsSync response OK, response.response->update().size()=%d", size);
ttus_user.cpp                 SERVER_ELOG("TTUS:Dropping connections!!!!!!!!!!");
ttus_user.cpp         SERVER_ELOG("DownloadAccountsSync response NOT OK. response.code=%s", TTUS_ResponseCodeToString(response.code));
ttus_user.cpp             SERVER_ILOG("SyncDownloadSpecificAccounts response OK: " "id=%llu " "response.response->update().size()=%d", id, size);
ttus_user.cpp                     SERVER_ELOG("SyncDownloadSpecificAccounts: This account has too many connections! Dropping the following connections!");
ttus_user.cpp                         SERVER_ELOG("SyncDownloadSpecificAccounts: Dropped %llu", dropped_connection_id);
ttus_user.cpp             SERVER_ELOG("SyncDownloadSpecificAccounts response NOT OK: " "problematic_id=%llu " "response.code=%s", id, TTUS_ResponseCodeToString(response.code));
ttus_user.cpp         SERVER_ILOG("Remove user[user_id=%llu]", user_id);
ttus_user.cpp         SERVER_WLOG("TTUSWeb::RefreshToken called before Init()");
ttus_user.cpp         SERVER_ELOG("TTUSWeb::RefreshToken called before Init()");
ttus_user.cpp             SERVER_ILOG("InternalTTUSHandler::Initialize: Asking TTUS Client Library for App Token...");
ttus_user.cpp                 SERVER_ILOG("InternalTTUSHandler::Initialize: App Token not ready yet - sleep 3 seconds and try again...");
ttus_user.cpp         SERVER_ILOG("InternalTTUSHandler::Initialize: App Token obtained!");
ttus_user.cpp         SERVER_ELOG("InternalTTUSHandler::Initialize: Already initialized!");
ttus_user.cpp             SERVER_ILOG("Connection Update received. " "New connection: connection_id=%llu, exchange_id=%d" , connection_id, exchange_id );
ttus_user.cpp             SERVER_ILOG("Connection Update received. " "Update connection: connection_id=%llu, old exchange_id=%d, new exhcange_id=%d" , connection_id, found->second, exchange_id );
ttus_user.cpp             SERVER_ILOG("Account Update received. " "New Account: account_id=%llu " "account_company_id=%llu, " "broker_id=%llu, " "connection_count=%llu " , account_id, account.company_id(), account.broker_id(), account.connection_ids_size() );
ttus_user.cpp             SERVER_ILOG("Account Update received. " "Change Account: account_id=%llu " "account_company_id(%llu-->%llu) " "broker_id(%llu-->%llu) " "connection_count(%llu-->%llu) " "algoSettingsChanged=%d", account_id, accountPtr->account_company_id, account.company_id(), accountPtr->broker_id, account.broker_id(), accountPtr->connection_count, account.connection_ids_size(), algoSettingsChanged);
ttus_user.cpp             SERVER_ELOG("TTUS:Dropping connections!!!!!!!!!! account_id=%llu connection_size=%d", account.id(), account.connection_ids_size());
ttus_user.cpp         SERVER_ELOG("DownloadSingleResourceWithRetrys: This function does NOT support NON-BLOCKING option! Please call TTUSHandler::DownloadSingleResource directly.");
ttus_user.cpp             SERVER_ILOG("DownloadSingleResourceWithRetrys: Sleeping for 100 milliseconds...");
ttus_user.cpp         SERVER_ILOG("DownloadSingleResourceWithRetrys: Calling TTUSHandler::DownloadSingleResource: " "number_of_attempts_so_far=%d " "max_number_of_attempts=%d", number_of_attempts_so_far, max_number_of_attempts);
ttus_user.cpp         SERVER_ILOG("DownloadSingleResourceWithRetrys: Completed TTUSHandler::DownloadSingleResource: " "response.code=%s", TTUS_ResponseCodeToString(response.code));
ttus_user.cpp         SERVER_ELOG("DownloadAllResourcesWithRetrys: This function does NOT support NON-BLOCKING option! Please call TTUSHandler::DownloadAllResources directly.");
ttus_user.cpp         SERVER_ILOG("DownloadAllResourcesWithRetrys: Calling TTUSHandler::DownloadAllResources: " "number_of_attempts_so_far=%d " "max_number_of_attempts=%d", number_of_attempts_so_far, max_number_of_attempts);
ttus_user.cpp         SERVER_ILOG("DownloadAllResourcesWithRetrys: Completed TTUSHandler::DownloadAllResources: " "response.code=%s", TTUS_ResponseCodeToString(response.code));
ttus_user.cpp         SERVER_ILOG("Company: name=[%s] id=%llu " "generate_synthetic_leg_fill=%d " "enable_algo_risk_checks=%d " "enable_near_far_touch_price_reasonability=%d", std::string(c.name().c_str()), company_id, generate_synthetic_leg_fill, enable_algo_risk_checks, enable_near_far_touch_price_reasonability);
ttus_user.cpp         SERVER_ILOG("SyncDownloadCompanies response OK, size=%d", size);
ttus_user.cpp         SERVER_ELOG("SyncDownloadCompanies response NOT OK. response.code=%s", TTUS_ResponseCodeToString(response.code));
ttus_user.cpp             SERVER_ILOG("SyncDownloadSpecificCompanies response OK: " "id=%llu " "size=%d", id, size);
ttus_user.cpp             SERVER_ELOG("SyncDownloadSpecificCompanies response NOT OK: " "problematic_id=%llu " "response.code=%s", id, TTUS_ResponseCodeToString(response.code));
ttus_user.cpp         SERVER_ELOG("CheckCompanyForGenerateLegFills: account_id=%llu not in map! user_id=%llu", account_id, user_id);
ttus_user.cpp         SERVER_DLOG("CheckCompanylevelSetting. " "company_id=%llu for " "user_id=%llu " "enable_algo_risk_checks=%d " "enable_near_far_touch_price_reasonability=%d", userPtr->user_company_id, userPtr->user_id, itr->second->enable_algo_risk_checks, itr->second->enable_near_far_touch_price_reasonability);
ttus_user.cpp         SERVER_ELOG("CheckCompanylevelSetting. Can not find " "company_id=%llu for " "user_id=%llu ", userPtr->user_company_id, userPtr->user_id);
ttus_user.cpp             SERVER_ELOG("User company not in Company cache! " "user_company_id=%llu " "user_id=$llu", user_obj->user_company_id, user_obj->user_id);
ttus_user.cpp                     SERVER_ILOG("UpdateAlgoSettingsByAccountUpdate: user_id=%llu account_id=%llu", user_obj->user_id, updated_account_id);
ttus_user.cpp                         SERVER_ELOG("User account not in Account cache! " "account_id=%llu " "user_id=$llu", user_account.account_id, user_obj->user_id);
ttus_user.cpp             SERVER_ILOG("UpdateUserByCompanyUpdate: user_id=%llu company_id=%llu", user_obj->user_id, updated_company_id);
ttus_user.cpp         SERVER_ELOG("TTUSWeb::AsyncDownloadAggregatedRiskLimits: Too many ttus worker threads! " "inst_id=%s " "m_workersForRiskLimitDownload.size()=%d", algo_instance_id, m_workersForRiskLimitDownload.size());
ttus_user.cpp     SERVER_ILOG("TTUSWeb::AsyncDownloadAggregatedRiskLimits: Starting async download on TTUS Worker Thread: " "inst_id=%s " "worker_id=%llu " "user_id=%llu " "account_id=%llu " "instrument_id=%llu ", algo_instance_id, this->m_workersForRiskLimitDownloadID, user_id, account_id, instrument_id);
ttus_user.cpp         SERVER_ELOG("TTUSWeb::SyncDownloadAggregatedRiskLimits: inst_id=%s: Instrument download failed!", algo_instance_id);
ttus_user.cpp         SERVER_ELOG("TTUSWeb::SyncDownloadAggregatedRiskLimits: inst_id=%s: Instrument parse failed!", algo_instance_id);
ttus_user.cpp         SERVER_ILOG("TTUSWeb::SyncDownloadAggregatedRiskLimits: inst_id=%s: Exempted from risk checks because the given instrument is synthetic.", algo_instance_id);
ttus_user.cpp         SERVER_ILOG("TTUSWeb::SyncDownloadAggregatedRiskLimits: inst_id=%s: " "Given instrument is Calendar Spread / Option Strategy - we must download first child leg instrument " "and use the child's product_type_id and product_id to locate the proper risk limits!", algo_instance_id);
ttus_user.cpp             SERVER_ELOG("TTUSWeb::SyncDownloadAggregatedRiskLimits: inst_id=%s: Child instrument download failed!", algo_instance_id);
ttus_user.cpp             SERVER_ELOG("TTUSWeb::SyncDownloadAggregatedRiskLimits: inst_id=%s: Child instrument parse failed!", algo_instance_id);
ttus_user.cpp         SERVER_ILOG("TTUSWeb::SyncDownloadAggregatedRiskLimits: Using child leg instrument's product_type_id and product_id: " "inst_id=%s " "parent_product_type_id=%llu --> child_product_type_id=%llu " "parent_product_id=%llu --> child_product_id=%llu", algo_instance_id, product_type_id, child_product_type_id, product_id, child_product_id);
ttus_user.cpp     SERVER_ILOG("TTUSWeb::SyncDownloadAggregatedRiskLimits: Starting sync download on TTUS Worker Thread: " "inst_id=%s " "user_id=%llu " "account_id=%llu " "instrument_id=%llu ", algo_instance_id, user_id, account_id, instrument_id);
ttus_user.cpp         SERVER_ELOG("TTUSWeb::SyncDownloadAggregatedRiskLimits: Response NOT OK. " "inst_id=%s" "response.code=%s ", algo_instance_id, TTUS_ResponseCodeToString(response.code));
ttus_user.cpp     SERVER_ILOG("TTUSWeb::SyncDownloadAggregatedRiskLimits: Response OK (zero means not set): " "inst_id=%s " "outright_price_drift_check_interval_one_min_ticks=%u " "outright_price_drift_check_interval_one_min_pct=%u " "outright_price_drift_check_interval_three_min_ticks=%u " "outright_price_drift_check_interval_three_min_pct=%u " "outright_price_drift_check_interval_lifetime_ticks=%u " "outright_price_drift_check_interval_lifetime_pct=%u " "spread_price_drift_check_interval_one_min_ticks=%u " "spread_price_drift_check_interval_one_min_pct=%u " "spread_price_drift_check_interval_three_min_ticks=%u " "spread_price_drift_check_interval_three_min_pct=%u ""spread_price_drift_check_interval_lifetime_ticks=%u ""spread_price_drift_check_interval_lifetime_pct=%u ""max_child_slice_size=%u ""max_number_of_cancels=%u ""max_number_of_updates=%u ""is_spread_or_strategy=%d",algo_instance_id,risk_limits_cache->risk_limits.pdci_one_min_ticks,risk_limits_cache->risk_limits.pdci_one_min_pct,risk_limits_cache->risk_limits.pdci_three_min_ticks,risk_limits_cache->risk_limits.pdci_three_min_pct,risk_limits_cache->risk_limits.pdci_lifetime_ticks,risk_limits_cache->risk_limits.pdci_lifetime_pct,risk_limits_cache->risk_limits.spdci_one_min_ticks,risk_limits_cache->risk_limits.spdci_one_min_pct,risk_limits_cache->risk_limits.spdci_three_min_ticks,risk_limits_cache->risk_limits.spdci_three_min_pct,risk_limits_cache->risk_limits.spdci_lifetime_ticks,risk_limits_cache->risk_limits.spdci_lifetime_pct,risk_limits_cache->risk_limits.max_child_slice_size,risk_limits_cache->risk_limits.max_number_of_cancels,risk_limits_cache->risk_limits.max_number_of_updates,risk_limits_cache->risk_limits.is_spread_or_strategy);
ttus_user.cpp             SERVER_ILOG("SendAggregatedRiskLimitsAndEraseWorker: worker_id=%llu --> detached worker. m_workersForRiskLimitDownload.size()=%d ", worker_id, m_workersForRiskLimitDownload.size());
ttus_user.cpp             SERVER_ELOG("SendAggregatedRiskLimitsAndEraseWorker: worker_id=%llu --> unexpectedly absent in map! m_workersForRiskLimitDownload.size()=%d", worker_id, m_workersForRiskLimitDownload.size());
ttus_user.cpp         SERVER_ELOG("GetUserOrganizationByAccountId: account_id=%llu not found", account_id);
ttus_user.cpp         SERVER_ELOG("GetUserOrganizationByAccountId: user_id=%llu not found", user_id);
ttus_user.cpp     SERVER_ELOG("GetUserOrganizationByAccountId: organization not found for account_id=%llu account_company_id=%llu user_id=%llu", account_id, account_company_id, user_id);
token_manager.cpp         SERVER_ELOG("Skip UpdateAccessToken. user_id=%llu", user_id);
token_manager.cpp             SERVER_ELOG("!!!!!!!!! Invalid token: algoserver_request from user=%llu, but the token is for user=%llu !!!!!!!!!!", user_id, token_info.user_id);
token_manager.cpp         SERVER_ELOG("Exception while ValidateAndUpdateAccessToken: " "user_id=%llu " "runtime_error=%s ", user_id, std::string(e.what()));
token_manager.cpp     SERVER_ILOG("Started token_manager timer internval=60 seconds");
token_manager.cpp                 SERVER_ELOG("Token user mismatch." " user_id=%llu" " token.user_id=%llu", user_id, old_token_info.user_id);
token_manager.cpp                 SERVER_ELOG("Failed to resign tokens.", " user_id=%llu" " error=%s" " expiry=%llu", user_id, ALGOSERVER_ERROR_STR[error], old_token_info.expiry);
token_manager.cpp                 SERVER_ELOG("Failed to store access token.", " user_id=%llu" " error=%s", user_id, ALGOSERVER_ERROR_STR[error]);
token_manager.cpp                 SERVER_WLOG("Failed to store refresh token.", " user_id=%llu" " error=%s", user_id, ALGOSERVER_ERROR_STR[error]);
token_manager.cpp             SERVER_ILOG("Token successfully re-signed." " user_id=%llu" " expiry=%llu", user_id, new_token_info.expiry);
token_manager.cpp             SERVER_ELOG("Exception while resign token: " "user_id=%llu " "runtime_error=%s ", user_id, std::string(e.what()));
token_manager.cpp     SERVER_ILOG("Re-signed %u of %u tokens in %f seconds", succeeded, attempts, difftime(start_time, stop_time));
token_manager.cpp             SERVER_ELOG("ExamToken: Failed to resign token. " " error=%s" " user_id=%llu", ALGOSERVER_ERROR_STR[error], token_info.user_id);
token_manager.cpp             SERVER_ELOG("ExamToken: Failed to save Access Token. " " error=%s" " user_id=%llu", ALGOSERVER_ERROR_STR[error], token_info.user_id);
token_manager.cpp             SERVER_ILOG("Saving access token. " "user_id=%llu" "expiry=%llu", token_info.user_id, token_info.expiry);
token_manager.cpp             SERVER_ELOG("ExamToken: Failed to save Refresh Token. " " error=%s" " user_id=%llu", ALGOSERVER_ERROR_STR[error], token_info.user_id);
token_manager.cpp             SERVER_ILOG("Saving refresh token for user_id=%llu", token_info.user_id);
token_manager.cpp             SERVER_ELOG("RenewTokenUponRecovery: Failed to fetch Access Token from Disk " "error=%i(%s) " "user_id=%llu " "order_id=%s ", error, ALGOSERVER_ERROR_STR[error], user_id, order_id.to_string());
token_manager.cpp             SERVER_ILOG("RenewTokenUponRecovery: Fetched Access Token from DIsk: " "user_id=%llu " "order_id=%s ", user_id, order_id.to_string());
token_manager.cpp             SERVER_ELOG("!!!!!!!!! Invalid token: algoserver_request from user=%llu, " "but the token is for user=%llu !!!!!!!!!!", user_id, token_info.user_id);
token_manager.cpp             SERVER_ELOG("Expired token. but continue recovery." " user_id=%llu" " expiry=%llu" " current=%llu" " env_missing_token=%d", token_info.user_id, token_info.expiry, current_time_ns, env_missing_token);
token_manager.cpp         SERVER_ELOG("RenewTokenUponRecovery: Failed. " "runtime_error=%s, " "user_id=%llu " "order_id=%s ", std::string(e.what()), user_id, order_id.to_string());
token_manager.cpp         SERVER_DLOG("Refresh in progress. Skip!");
token_manager.cpp             SERVER_WLOG("Skipped %llu refresh", skipped );
token_manager.cpp         SERVER_ILOG("About to Refresh %d token(s) ",local_copy.size());
token_manager.cpp                             SERVER_ILOG("Send updated token to algojob [user_id=%llu, job_id=%llu]", user_id, algojob->algojob_id);
token_manager.cpp                 SERVER_ELOG("Exception while RefreshOnTimerThreadn: " "user_id=%llu " "runtime_error=%s ", user_id, std::string(e.what()));
load_balancer.cpp         SERVER_ILOG( "Selecting an algojob for incoming request: " "request.id=%s " "request.inst_id=%s " "request.user_id=%llu " "request.user_request_id=%llu", ALGOJOB_REQUEST_ID_STR[request.id], std::string(inst_uuid), request.user_id, request.user_request_id );
load_balancer.cpp             SERVER_ILOG("Decided to spawn a new algojob.");
load_balancer.cpp             SERVER_ILOG( "Decided to route to an existing algojob: selected_algojob->algojob_id=%llu", selected_algojob->algojob_id );
load_balancer.cpp             SERVER_ELOG( "RoundRobin threw an out-of-range exception - we will just spawn a new algojob instead of round-robin." );
load_balancer.cpp             SERVER_ELOG( "RoundRobin threw an unknown exception - we will just spawn a new algojob instead of round-robin." );
load_balancer.cpp                 SERVER_ILOG( "RESERVED: RoundRobinPolicyWithReservedUsers::IsReservedAlgoJobForUserImpl() user_id=%llu", user_id);
load_balancer.cpp                     SERVER_ILOG( "RESERVED: RoundRobinPolicyWithReservedUsers::PickAlgoJobImpl() user_id=%llu, FOUND ALGOJOB\n", request.user_id);
load_balancer.cpp                     SERVER_ILOG( "RESERVED: RoundRobinPolicyWithReservedUsers::PickAlgoJobImpl() user_id=%llu, Empty ALGOJOB\n", request.user_id);
load_balancer.cpp             SERVER_ILOG( "UN-----RESERVED: RoundRobinPolicyWithReservedUsers::PickAlgoJobImpl() user_id=%llu\n", request.user_id);
load_balancer.cpp             SERVER_ELOG( "RoundRobinPolicyWithReservedUsers threw an out-of-range exception - we will just spawn a new algojob instead of round-robin." );
load_balancer.cpp             SERVER_ELOG( "RoundRobinPolicyWithReservedUsers threw an unknown exception - we will just spawn a new algojob instead of round-robin." );
load_balancer.cpp     SERVER_ILOG( "-----------------|> Initialized to policy type: %s <|----------------- ", DISTRIBUTION_POLICY_STR[policy] );
load_balancer.cpp         SERVER_ILOG("algojob %p assigned to user %llu", algojobData, user_id);
pricefs_config_xml.cpp     SERVER_ILOG("*****************************Prepare Unifier CRAP for Job=%llu ****************************", algojob_id);
pricefs_config_xml.cpp         SERVER_ELOG( "PreparePriceUnifierConfigXml %s does not exist", unifier_config.str());
pricefs_config_xml.cpp         SERVER_ILOG( "unifier crap: read_xml Parsed Successfully for %s", unifier_config.str());
pricefs_config_xml.cpp                 SERVER_ILOG( "unifier crap: set price_client_config_file to %s", new_price_client_config.str());
pricefs_config_xml.cpp         SERVER_ILOG("*****************************Done Unifier CRAP for Job=%llu *******************************", algojob_id);
pricefs_config_xml.cpp         SERVER_ELOG( "PreparePriceUnifierConfigXml Failed to read %s, invalid format", unifier_config.str());
pricefs_config_xml.cpp         SERVER_ELOG( "PreparePriceUnifierConfigXml Failed to read %s, error %s", unifier_config.str(), std::string(e.what()));
pricefs_config_xml.cpp         SERVER_ILOG( "PreparePriceClientConfigXml() base=%s, new=%s, algojob_id=%llu", baseConfigFile.str(), newConfigFile.str(), algojob_id);
pricefs_config_xml.cpp         SERVER_ELOG( "ERROR PreparePriceClientConfigXml() boost::property_tree::ptree_bad_path algojob_id=%llu", algojob_id);
pricefs_config_xml.cpp         SERVER_ELOG( "ERROR PreparePriceClientConfigXml() xml_parser_error::ptree_bad_path algojob_id=%llu", algojob_id);
book_downloader.cpp     SERVER_ILOG("ConfigXml: skip_order_book_dl_config=%d", skip_order_book_dl_config);
book_downloader.cpp         SERVER_ILOG("Skipping order book download (due to config setting)");
book_downloader.cpp         SERVER_ILOG("Requesting book download, attempt=%i, delay=%i secs", retry_count, retry_delay);
book_downloader.cpp             SERVER_ELOG("Failed to get clock time, unable to schedule download requests");
book_downloader.cpp         SERVER_ELOG("Failed to receive download response from ledger");
protocol_protobuf.cpp         SERVER_ELOG( "Can not get brokerId from algo_params for account_id=%llu", acctId );
protocol_protobuf.cpp         SERVER_ILOG("STAGED: From NewOrderSingle SET_staged_order_id=%s", std::string(staged));
protocol_protobuf.cpp     SERVER_ILOG( "InitRequest: request=[%s], " "user_id=%d, " "account_id=%llu " "broker_id=%llu " "instr_id=%llu, " "user_req_id=%llu, " "timeSent=%llu " "source=%s " "flags=%08x " "cl_ord_id=%llu ", ALGOJOB_REQUEST_ID_STR[request_id], user_id, connection_id, broker_id, instr_id, user_request_id, timeSent, tt::messaging::order::enums::Source_Name(source).to_std(), flags, cl_ord_id);
protocol_protobuf.cpp                     SERVER_ILOG("Recevied long param: %s=%s", std::string(user_param_item->name().c_str()), std::string(user_param_item->v_string().c_str()));
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] new_order_single missing user_id",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] new_order_single missing account_id",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] new_order_single missing cl_ord_id",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] new_order_single missing auth_token",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] new_order_single missing algo_instrument_id",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] new_order_single missing instrument_id",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] new_order_single missing market_id",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] new_order_single missing side",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] new_order_single missing ord_type",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] new_order_single missing time_sent",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] new_order_single missing source",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_WLOG("DecodeNewOrderSingle ParseFromString failed. Trying ParseFromArray." " payload_size=%zu", wire_message->payload(0).length());
protocol_protobuf.cpp             SERVER_ELOG("DecodeNewOrderSingle ParseFromArray also failed.");
protocol_protobuf.cpp         SERVER_ILOG("Alert condition: [Failure processing LOOPBACK data] IS FIXED");
protocol_protobuf.cpp         SERVER_ELOG("new_order_single missing order_id");
protocol_protobuf.cpp     SERVER_DLOG_L([=]() { return std::string("[algo_inst_id=") + algo_inst_id.to_string() + "] NewOrderSingle " + new_order_single.ShortDebugString().to_std(); });
protocol_protobuf.cpp             SERVER_ELOG("algo[%s] new_order_single has too many user parameter, user_parameter_count=%zu", algo_inst_id.to_string(), user_parameter_size);
protocol_protobuf.cpp         SERVER_WLOG("Receive deprecated ase_order_info algo_inst_id=%s", algo_inst_id.to_string());
protocol_protobuf.cpp     SERVER_ILOG("DecodeNewOrderSingle: %s", nos_info.str());
protocol_protobuf.cpp         SERVER_ILOG("DecodeNewOrderSingle: order_id=%s user_parameters=[%s]", algo_inst_id.to_string(), parsedMessage);
protocol_protobuf.cpp         SERVER_ELOG("UpdateChangedFields: order_id=%s found no class_1_2_fields", algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ILOG("UpdateChangedFields: order_id=%s change=[%s]", algo_inst_id.to_string(), inbound_class_1_2->ShortDebugString().to_std());
protocol_protobuf.cpp     SERVER_DLOG_L([=]() { return std::string("[algo_inst_id=") + algo_inst_id.to_string() + "] OrderCancel " + order_cancel_request.ShortDebugString().to_std(); });
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] order_cancel_request missing user_id",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] order_cancel_request missing account_id",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] order_cancel_request missing cl_ord_id",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] order_cancel_request missing instrument_id",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] order_cancel_request missing market_id",algo_inst_id.to_string());
protocol_protobuf.cpp     SERVER_DLOG_L([=]() { return std::string("[algo_inst_id=") + algo_inst_id.to_string() + "] OrderCancelReplace " + order_cancel_replace_request.ShortDebugString().to_std(); });
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] order_cancel_replace_request missing user_id",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] order_cancel_replace_request missing account_id",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] order_cancel_replace_request missing cl_ord_id",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] order_cancel_replace_request missing instrument_id",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("algo[%s] order_cancel_replace_request missing market_id",algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ILOG("DecodeOrderCancelReplaceRequest: order_id=%s user_parameters=[%s]", algo_inst_id.to_string(), parsedMessage);
protocol_protobuf.cpp     SERVER_ILOG("DecodeAlgoSideChannelRequest. args: %s", request->data.cli_cmd.argc ? oss.str() : "");
protocol_protobuf.cpp     SERVER_ILOG("DecodeTriageActionRequest: " "request_id=%s " "initiator_name=%s " "message=%s", triage_action_request.request_id().to_std(), triage_action_request.initiator_name().to_std(), triage_action_request.message().to_std());
protocol_protobuf.cpp         SERVER_WLOG("[algo_inst_id=%s] DecodeOrderTags: OC rejected OTD NOS with: " "ord_status=ORD_STATUS_REJECTED", algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_WLOG("[algo_inst_id=%s] DecodeOrderTags: Failed to find Algo's Class 1/2 Fields!", algo_inst_id.to_string());
protocol_protobuf.cpp     SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Dumping class_1_2_fields before merge:\n%s", algo_inst_id.to_string(), class_1_2_fields->ShortDebugString().to_std());
protocol_protobuf.cpp         SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD account=%s", algo_inst_id.to_string(), er->account().to_std());
protocol_protobuf.cpp         SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD account_override=%s " "(Parent ER's [account_override] and [account] fields will honor this value going forward)", algo_inst_id.to_string(), er->account_override().to_std());
protocol_protobuf.cpp         SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD text_tt=%s", algo_inst_id.to_string(), er->text_tt().to_std());
protocol_protobuf.cpp         SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD text_a=%s", algo_inst_id.to_string(), er->text_a().to_std());
protocol_protobuf.cpp         SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD text_b=%s", algo_inst_id.to_string(), er->text_b().to_std());
protocol_protobuf.cpp         SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD text_c=%s", algo_inst_id.to_string(), er->text_c().to_std());
protocol_protobuf.cpp         SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD vendor_defined_field_1=%s", algo_inst_id.to_string(), er->vendor_defined_field_1().to_std());
protocol_protobuf.cpp         SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD vendor_defined_field_2=%s", algo_inst_id.to_string(), er->vendor_defined_field_2().to_std());
protocol_protobuf.cpp         SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD vendor_defined_field_3=%s", algo_inst_id.to_string(), er->vendor_defined_field_3().to_std());
protocol_protobuf.cpp         SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD vendor_defined_field_4=%s", algo_inst_id.to_string(), er->vendor_defined_field_4().to_std());
protocol_protobuf.cpp         SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD vendor_defined_field_5=%s", algo_inst_id.to_string(), er->vendor_defined_field_5().to_std());
protocol_protobuf.cpp                 SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_ORDER_ORIGINATION_TRADER", algo_inst_id.to_string());
protocol_protobuf.cpp                 SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_ACCOUNT_CODE", algo_inst_id.to_string());
protocol_protobuf.cpp                 SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_TAKEUP_FIRM", algo_inst_id.to_string());
protocol_protobuf.cpp                 SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_CLIENT_ID", algo_inst_id.to_string());
protocol_protobuf.cpp                 SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_EXECUTING_TRADER", algo_inst_id.to_string());
protocol_protobuf.cpp                 SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_INVESTMENT_DECISION_MAKER", algo_inst_id.to_string());
protocol_protobuf.cpp                 SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_MIFID_ID", algo_inst_id.to_string());
protocol_protobuf.cpp                 SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_EXECUTING_FIRM", algo_inst_id.to_string());
protocol_protobuf.cpp     SERVER_ILOG("[algo_inst_id=%s] DecodeOrderTags: Dumping class_1_2_fields after merge:\n%s", algo_inst_id.to_string(), class_1_2_fields->ShortDebugString().to_std());
protocol_protobuf.cpp                 SERVER_ILOG("[algo_inst_id=%s] DecodeOrderResponse: Enqueue fill for " "order_id=%s " "instrument_id=%llu " "order_sequence=%llu " "last_qty=%0.8f " "leg_fill_sequence=%llu " "reporting_type=%s ", algo_inst_id.to_string(), order_id.to_string(), er->instrument_id(), er->order_sequence(), er->last_qty(), er->leg_fill_sequence(), MultiLegReportingType_Name(er->multi_leg_reporting_type()).to_std() .substr(MULTI_LEG_REPORTING_TYPE_PREFIX_SIZE));
protocol_protobuf.cpp     SERVER_DLOG_L([=]() { return "algo[" + algo_inst_id.to_string() + "]: Dumping order_fill_update_msg: " + msg.ShortDebugString().to_std(); });
protocol_protobuf.cpp             SERVER_ELOG("DecodeOrderFillUpdateRequest: order_id=%s review_status=%s review_user_id=%llu The message length cb=%zu exceeds the max=%zu", algo_inst_id.to_string(), TTSDK_ReviewStatusToString(review_status), review_user_id, cb, sizeof(request->data.order_review_approve.serialized_msg));
protocol_protobuf.cpp         SERVER_ILOG("DecodeOrderFillUpdateRequest: order_id=%s review_status=%s review_user_id=%llu cb=%zu %s", algo_inst_id.to_string(), TTSDK_ReviewStatusToString(review_status), review_user_id, cb, msg.ShortDebugString().to_std());
protocol_protobuf.cpp             SERVER_ELOG("DecodeOrderFillUpdateRequest: could not find order_id=%s in s_algo_protobufs. Assuming it's a terminated order", algo_inst_id.to_string());
protocol_protobuf.cpp                     SERVER_ELOG("DecodeOrderFillUpdateRequest: order_id=%s text_a=%s text_b=%s text_tt=%s The message length cb=%zu exceeds the max=%zu", algo_inst_id.to_string(), text_a, text_b, text_tt, cb, sizeof(request->data.order_review_approve.serialized_msg));
protocol_protobuf.cpp                 SERVER_ILOG("DecodeOrderFillUpdateRequest: order_id=%s text_a=%s text_b=%s text_tt=%s cb=%zu %s", algo_inst_id.to_string(), text_a, text_b, text_tt, cb, msg.ShortDebugString().to_std());
protocol_protobuf.cpp                 SERVER_ELOG("DecodeOrderFillUpdateRequest: no changes to any of text fields for order_id=%s. Ignoring OrderFillUpdateRequest", algo_inst_id.to_string());
protocol_protobuf.cpp                 SERVER_ILOG("DecodeOrderFillUpdateRequest: order_id=%s class_2_change=[%s] %s", algo_inst_id.to_string(), inbound_class_1_2->ShortDebugString().to_std(), msg.ShortDebugString().to_std());
protocol_protobuf.cpp                 SERVER_ILOG("DecodeOrderFillUpdateRequest: order_id=%s No class 2 change. %s", algo_inst_id.to_string(), msg.ShortDebugString().to_std());
protocol_protobuf.cpp     SERVER_DLOG_L([=]() { return "algo[" + algo_inst_id.to_string() + "]: Dumping order_update_msg: " + msg.ShortDebugString().to_std(); });
protocol_protobuf.cpp         SERVER_ELOG("[algo=%s] order_update_request missing user_id", algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ILOG("[algo=%s] order_update_request has OMA-related info", algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ILOG("[algo=%s] order_update_request reason=%s", algo_inst_id.to_string(), OrderUpdateReason_Name(reason).to_std());
protocol_protobuf.cpp         SERVER_ELOG("[algo=%s] order_update_request has no reason", algo_inst_id.to_string());
protocol_protobuf.cpp              SERVER_ELOG("[algo=%s] Order passing initiate - missing (required: curr_user_group_id, pass_to_group_id, curr_user_id)", algo_inst_id.to_string());
protocol_protobuf.cpp              SERVER_ELOG("[algo=%s] Order passing accept - missing (required: curr_user_group_id, curr_user_id)", algo_inst_id.to_string());
protocol_protobuf.cpp              SERVER_ELOG("[algo=%s] Order passing reject - missing (required: curr_user_group_id, curr_user_id)", algo_inst_id.to_string());
protocol_protobuf.cpp              SERVER_ELOG("[algo=%s] Order passing undo - missing (required: curr_user_group_id, curr_user_id)", algo_inst_id.to_string());
protocol_protobuf.cpp              SERVER_ELOG("[algo=%s] Order passing set_child - missing (required: curr_user_group_id, curr_user_id)", algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ELOG("[algo=%s] order_update_request=cancel should never come in as a request", algo_inst_id.to_string());
protocol_protobuf.cpp             SERVER_ELOG("[algo=%s] order_update_request=ORDER_UPDATE_REASON_ORDER_APPROVAL does is missing review_status or review_user_id", algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ILOG("[algo=%s] ORDER_UPDATE_REASON_ORDER_APPROVAL review_status=%d review_user_id=%llu", algo_inst_id.to_string(), TTSDK_ReviewStatusToString(review_status), review_user_id);
protocol_protobuf.cpp         SERVER_ELOG("[algo=%s] order_update_request reason=%s Not supported!", algo_inst_id.to_string(), OrderUpdateReason_Name(reason).to_std());
protocol_protobuf.cpp         SERVER_ILOG("STAGED: To ExecutionReport SET_staged_account_type=%d", stagedAccountType);
protocol_protobuf.cpp                 SERVER_ILOG("[algo_inst_id=%s] instrument_id=%llu is mapped to so_name=%d, which is mapped to SyntheticOrderType=%s. Using this type for the Execution Report", algo_order_id.to_string(), algo_instr_id, so_name, tt::messaging::order::enums::SyntheticOrderType_Name(synthTypeEnum).to_std());
protocol_protobuf.cpp                 SERVER_WLOG("[algo_inst_id=%s] instrument_id=%llu is mapped to so_name=%d, but so_name is not mapped to any SyntheticOrderType", algo_order_id.to_string(), algo_instr_id, so_name);
protocol_protobuf.cpp             SERVER_ELOG("EncodeExecutionReportInternal: order_id=%s found no class_1_2_fields", algo_order_id.to_string());
protocol_protobuf.cpp                 SERVER_ILOG("[algo_inst_id=%s] EncodeExecutionReportInternal: fill=%s", algo_order_id.to_string(), message.ShortDebugString().to_std());
protocol_protobuf.cpp                 SERVER_ELOG("[algo_inst_id=%s] EncodeExecutionReportInternal, could not generate ShortDebugString, Exception: %s", algo_order_id.to_string(), reason);
protocol_protobuf.cpp             SERVER_ELOG("[algo_inst_id=%s] Delaying fill=%s", algo_order_id.to_string(), message.ShortDebugString().to_std());
protocol_protobuf.cpp     SERVER_ILOG( "[algo_inst_id=%s] Encoding ExecutionReport: " "user_id=%llu " "current_user_id=%llu " "account_id=%llu " "broker_id=%llu " "order_id=%s " "order_status=%s " "syn_status=[%s] " "algoType=%s " "exec_type=%s " "source=%s " "order_sequence=%llu " "synthetic_order_type=%s " "algoinst_id=%llu " "side=%s " "qty=%s " "leaves_qty=%s " "disp_qty=%s " "price=%s " "stop_price=%s " "time_in_force=%s " "user_request_id=%llu " "cl_ord_id=%llu " "orig_cl_ord_id=%llu " "fix_cl_ord_id=%s " "fix_orig_cl_ord_id=%s " "trade_date=%llu " "exec_restatement_reason=%s " "organization=%s " "isFakeExecutionReport=%d " "[%s] " "[%s] "//order_passing "[%s] "//	user parameters "review_status=%s " "review_user_id=%llu " , algo_order_id.to_string(), user_id, algo_params->current_user_id, connection_id, GetBrokerID(algo_params, connection_id), algo_order_id.to_string(), tt::messaging::order::enums::OrdStatus_Name(order_status).to_std(), all_synth_status, std::string(TTSDK_ALGO_TYPE_STR[algoType]), tt::messaging::order::enums::ExecType_Name(exec_type).to_std(), tt::messaging::order::enums::Source_Name(source_enum).to_std(), response_count, tt::messaging::order::enums::SyntheticOrderType_Name(synthTypeEnum).to_std(), algo_instr_id, (message.has_side() ? tt::messaging::order::enums::Side_Name(message.side()).to_std() : "N/A"), (message.has_order_qty() ? std::to_string(message.order_qty()) : "N/A"), (message.has_leaves_qty() ? std::to_string(message.leaves_qty()) : "N/A"), (message.has_display_qty() ? std::to_string(message.display_qty()) : "N/A"), (message.has_price() ? std::to_string(message.price()) : "N/A"), (message.has_stop_px() ? std::to_string(message.stop_px()) : "N/A"), (message.has_time_in_force() ? tt::messaging::order::enums::TimeInForce_Name(message.time_in_force()).to_std() : "N/A"), user_request_id, cl_ord_id, orig_cl_ord_id, (message.has_fix_cl_ord_id() ? message.fix_cl_ord_id().to_std() : "N/A"), (message.has_fix_orig_cl_ord_id() ? message.fix_orig_cl_ord_id().to_std() : "N/A"), trade_date, (message.has_exec_restatement_reason() ? tt::messaging::order::enums::ExecRestatementReason_Name(message.exec_restatement_reason()).to_std() : "N/A"), (message.has_organization() ? message.organization().to_std() : ""), isFakeExecutionReport, prev_exch_order_assoc, has_order_pass ? order_pass_info.str() : "No Order Passing", (message.has_user_parameters() ? UserParametersToString(message.user_parameters()) : ""), (message.has_review_status() ? TTSDK_ReviewStatusToString(review_status) : "N/A"), review_user_id);
protocol_protobuf.cpp         SERVER_ILOG("long_param=%s", long_param);
protocol_protobuf.cpp     SERVER_DLOG_L([=]() { return std::string("[algo_inst_id=") + algo_order_id.to_string() + "] ExecutionReport " + message.ShortDebugString().to_std(); });
protocol_protobuf.cpp         SERVER_ILOG("EncodeExecutionReportInternal: order_id=%s full_filled or canceled. Queued task to remove cached class_1_2", algo_order_id.to_string());
protocol_protobuf.cpp             SERVER_ELOG("EncodeOrderCancelRejectInternal: order_id=%s found no class_1_2_fields", algo_order_id.to_string());
protocol_protobuf.cpp     SERVER_ILOG("Encoding OrderCancelReject: " "user_id=%llu " "order_id=%s " "order_status=%s " "cl_ord_id=%llu " "orig_cl_ord_id=%llu " "fix_cl_ord_id=%s " "fix_orig_cl_ord_id=%s " "%s", user_id, algo_order_id.to_string(), tt::messaging::order::enums::OrdStatus_Name(order_status).to_std(), cl_ord_id, orig_cl_ord_id, (message.has_fix_cl_ord_id() ? message.fix_cl_ord_id().to_std() : "N/A"), (message.has_fix_orig_cl_ord_id() ? message.fix_orig_cl_ord_id().to_std() : "N/A"), extra_log_info.str());
protocol_protobuf.cpp     SERVER_DLOG_L([=]() { return std::string("[algo_inst_id=") + algo_order_id.to_string() + "] OrderCancelReject " + message.ShortDebugString().to_std(); });
protocol_protobuf.cpp         SERVER_DLOG("Failed to parse wire header." " data_size=%zu", data_size);
protocol_protobuf.cpp     SERVER_DLOG_L([=]() { return std::string("[algo_inst_id=") + algo_inst_id.to_string() + "] Downloaded ExecutionReport " + report.ShortDebugString().to_std(); });
protocol_protobuf.cpp         SERVER_ELOG("DecodeDownloadedExecutionReport: get algo order with no synth_status: algo_inst_id=%s", algo_inst_id.to_string());
protocol_protobuf.cpp     SERVER_ILOG("DecodeDownloadedExecutionReport: [algo=%s] %s", algo_inst_id.to_string(), recovery_info.str());
protocol_protobuf.cpp         SERVER_ELOG( "AlgoServer_EncodeFailure: request=[%s], error=%s", ALGOJOB_REQUEST_ID_STR[request_id], ALGOSERVER_ERROR_STR[error] );
protocol_protobuf.cpp         SERVER_ILOG("STAGED: To ExecutionReport SET_staged_order_id=%s", std::string(staged));
protocol_protobuf.cpp         SERVER_ILOG( "Encoding AlertExecutionReport: This is a child algo with a parent: " "order_id=%s " "parent_order_id=%s ", algo_order_id.to_string(), std::string(parent_order_id_str) );
protocol_protobuf.cpp             SERVER_ELOG("algo_params has UNKNOWN AlgoType!");
protocol_protobuf.cpp         SERVER_ELOG("algo_params has no AlgoType");
protocol_protobuf.cpp         SERVER_ILOG("STAGED: To ExecutionReport SET_staged_account_type=%d", stagedAccountType);
protocol_protobuf.cpp             SERVER_ELOG("EncodeExecutionReportInternal: order_id=%s found no class_1_2_fields", algo_order_id.to_string());
protocol_protobuf.cpp     SERVER_ILOG("Algo[inst_id=%s] Encoding Alert ER: %s", algo_order_id.to_string(), std::string(alert_message));
protocol_protobuf.cpp     SERVER_ILOG("EncodeExportValue order_id=%s %s", algo_order_id.to_string(), side_channel_message.ShortDebugString().to_std());
protocol_protobuf.cpp     SERVER_ILOG( "AlgoServer_EncodeBookieDownloadRequest req_id=%s, exch_order_assoc=%s", std::string(request_id_string), std::string(algoserver_id) );
protocol_protobuf.cpp     SERVER_ILOG("dl_request=[%s]", std::string(protoString.c_str()));
protocol_protobuf.cpp         SERVER_ELOG("AlgoServer_DecodeAndForwardOrderTagDownload: Failed to parse LBM message!");
protocol_protobuf.cpp         SERVER_ELOG("AlgoServer_DecodeAndForwardOrderTagDownload: Was expecting [Header::MSG_EXECUTION_REPORT] but received something else!");
protocol_protobuf.cpp         SERVER_ELOG("AlgoServer_DecodeAndForwardOrderTagDownload: Failed to parse payload into ER!");
protocol_protobuf.cpp         SERVER_ELOG("AlgoServer_DecodeAndForwardOrderTagDownload: ER is missing the parent_order_id!");
protocol_protobuf.cpp     SERVER_ILOG("[algo_inst_id=%s] AlgoServer_DecodeAndForwardOrderTagDownload: Dumping OTD ER:\n%s", algo_inst_id.to_string(), er->ShortDebugString().to_std());
protocol_protobuf.cpp         SERVER_ELOG("Ledger response missing book");
protocol_protobuf.cpp     SERVER_ILOG("Book downloaded, size=%i", book_size);
protocol_protobuf.cpp             SERVER_ELOG("AlgoServer_EncodeRecoveryRequest: order_id=%s found no class_1_2_fields", algo_inst_id.to_string());
protocol_protobuf.cpp     SERVER_ILOG("AlgoServer_EncodeOrderTagNewOrderSingle: Generating a makeshift child OTD NOS with: " "order_id=%s " "parent_order_id=%s", std::string(order_id_string), std::string(algo_inst_id_string));
protocol_protobuf.cpp             SERVER_ELOG("AlgoServer_EncodeOrderTagNewOrderSingle: Trying to encode non-null terminated account_override string: " "algo_inst_id=%s " "value=%s", std::string(algo_inst_id_string), std::string(account_override, TTSDK_PARAM_MAX_STRING_SIZE));
protocol_protobuf.cpp         SERVER_ILOG("AlgoServer_EncodeOrderTagNewOrderSingle: For algo_inst_id=%s, dumping the makeshift child OTD NOS:\n%s", std::string(algo_inst_id_string), toPrint.to_std());
protocol_protobuf.cpp             SERVER_ELOG("AlgoServer_EncodeChildCancel: parent_id=%s found no class_1_2_fields", parent_id.to_string());
protocol_protobuf.cpp     SERVER_ILOG("EncodeOrderCancelReject: " "user_id=%llu " "order_id=%s " "request=%s ", algo->user_id, algo->inst_id.to_string(), ALGOJOB_REQUEST_ID_STR[request.id]);
protocol_protobuf.cpp         SERVER_ELOG("EncodeClassOneTwoFields: order_id=%s found no class_1_2_fields for job_request=%s", algo_inst_id.to_string(), ALGOJOB_REQUEST_ID_STR[id]);
protocol_protobuf.cpp             SERVER_ELOG("EncodeClassOneTwoFields: request=%s inst_id=%s " "class_1_2_fields_size=%zu too large!!!", ALGOJOB_REQUEST_ID_STR[id], algo_inst_id.to_string(), size);
protocol_protobuf.cpp             SERVER_ILOG("EncodeClassOneTwoFields: request=%s inst_id=%s " "class_1_2_fields_size=%zu ", ALGOJOB_REQUEST_ID_STR[id], algo_inst_id.to_string(), size);
protocol_protobuf.cpp             SERVER_ELOG("EncodeClassOneTwoFields: request=%s inst_id=%s " "class_2_size=%zu too large!!!", ALGOJOB_REQUEST_ID_STR[id], algo_inst_id.to_string(), size);
protocol_protobuf.cpp             SERVER_ILOG("EncodeClassOneTwoFields: request=%s " "inst_id=%s " "class_2_size=%zu ", ALGOJOB_REQUEST_ID_STR[id], algo_inst_id.to_string(), size);
protocol_protobuf.cpp     SERVER_ILOG("RemoveClassOneTwoFields: order_id=%s ", algo_order_id.to_string());
protocol_protobuf.cpp             SERVER_ELOG("OverrideERAndEncode: order_id=%s found no class_1_2_fields", algo->inst_id.to_string());
protocol_protobuf.cpp             SERVER_ELOG("[algo_inst_id=%s]: Cannot get primary_market_id", algo_inst_id.to_string());
protocol_protobuf.cpp         SERVER_ILOG("[algo_inst_id=%s] PopulateFill for " "order_id_on_fill=%s " "order_sequence_on_fill=%llu " "order_sequence_on_er=%llu " "primary_market_id=%u ", algo_inst_id.to_string(), order_id_on_fill, order_sequence_on_fill, order_sequence_on_er, primary_market_id);
protocol_protobuf.cpp          SERVER_WLOG("[algo_inst_id=%s] PopulateFill Missing " "order_id_on_fill=%s " "order_sequence_on_fill=%llu ", algo_inst_id.to_string(), std::string(order_id), order_sequence_on_fill);
protocol_protobuf.cpp             SERVER_ILOG("[algo_inst_id=%s] PopulateFillsGrp fills_grp_size=%zu", algo_inst_id.to_string(), fills_grp_from_algojob.fills_grp_size());
protocol_protobuf.cpp             SERVER_ELOG("[algo_inst_id=%s] PopulateFillsGrp failed", algo_inst_id.to_string());
protocol_protobuf.cpp     SERVER_DLOG_L([=]() { return "algo[" + algo_order_id.to_string() + "]: Dumping order_fill_update_resp: " + message.ShortDebugString().to_std(); });
controller.cpp             SERVER_ILOG("RetryRecovery %s", msg.str());
controller.cpp                 SERVER_ILOG("Stop retrying after 50");
controller.cpp                 SERVER_ELOG(error);
controller.cpp     SERVER_DLOG("BEFOR DeleteAlgoJobFromMap size=%u, algojob_id=%llu", mapToAlgoJobData.size(), algojob_id);
controller.cpp     SERVER_DLOG("AFTER DeleteAlgoJobFromMap size=%u, algojob_id=%llu", mapToAlgoJobData.size(), algojob_id);
controller.cpp         SERVER_ELOG("[algo_inst_id=%s] PrepareSyntheticLegInfo: Failed to get instrument error=%s ", algo_inst_id, TTSDK_ERROR_STR[error]);
controller.cpp         SERVER_ELOG("[algo_inst_id=%s] PrepareSyntheticLegInfo: DownloadInstrument failed " "instr_id=%llu " "error=%s ", algo_inst_id, instr_id, to_string(dl_result.first));
controller.cpp         SERVER_ELOG("[algo_inst_id=%s] PrepareSyntheticLegInfo: invalid instr_id=%llu ", algo_inst_id, instr_id);
controller.cpp         SERVER_WLOG("[algo_inst_id=%s] PrepareSyntheticLegInfo: Downloaded: name=%s no leg.", algo_inst_id, instr_data->name);
controller.cpp     SERVER_ILOG("[algo_inst_id=%s] PrepareSyntheticLegInfo: Downloaded: name=%s leg_size=%zu", algo_inst_id, instr_data->name, instr_data->legs.size());
controller.cpp         SERVER_ILOG("[algo_inst_id=%s] PrepareSyntheticLegInfo: " "For instrument=%s Add " "leg info=[instrument_id=%llu " "ratio=%0.8f " "cum_qty=%0.8f " "avg_px=0.0]", algo_inst_id, instr_data->name, l.instrument_id, l.ratio, l.cum_qty);
controller.cpp     SERVER_ILOG("InitAlgoData: Added algo=%p" "[inst_id=%s, " "user_id=%llu, " "state=%s] to " "algojob=%p" "[algojob_id=%llu, " "pid=%ld " "connection_established=[%s] " "conn_data=%p " "owned_algos: size=%u] ", (void*)algo, algo->inst_id.to_string(), algo->user_id, ALGO_STATE_STR[init_state], (void*)algojob, algojob->algojob_id, algojob->pid, algojob->flags&connection_established ? "Y" : "N", (void*)(algojob->conn_data), algojob->owned_algos.size());
controller.cpp     SERVER_ILOG("DestroyAlgoData: algo->inst_id=%s", algo->inst_id.to_string());
controller.cpp         SERVER_ILOG( "DestroyAlgoData: removed algo inst %s from algojob %p[owned_algos: size=%ld]", algo->inst_id.to_string(), (const void*)algojob, algojob->owned_algos.size() );
controller.cpp     SERVER_ILOG( "ReportToZK: user_id=%llu algojob->pid=%llu count=%zu ", user_id, algojob->pid, count );
controller.cpp             SERVER_ILOG( "RESERVED: InitAlgoJobData() user_id=%llu", user_id);
controller.cpp         SERVER_ILOG("AlgoJobData %p [algojob_id=%llu, pid=%ld] created", (void*)algojob, algojob_id, algojob->pid);
controller.cpp         SERVER_ELOG("Failed to create algojob_data");
controller.cpp         SERVER_ILOG("Cancelling child order." " inst_id=%s" " order_id=%s", algo->inst_id.to_string(), kvp.first.to_string());
controller.cpp     SERVER_ILOG("NoJobKillKids finished for algo=%s, sent_cancel=%u.", algo->inst_id.to_string(), algo->children.size());
controller.cpp     SERVER_ILOG( "DestroyAlgoJob: %p [connection_established=%s, owned_algos=%u queued=%u, queued_recovery=%u]", (void*)algojob, algojob->flags&connection_established ? "Y" : "N", algojob->owned_algos.size(), algojob->queued_requests.size(), queued_recovery );
controller.cpp             SERVER_ILOG("DestroyAlgoJob: " "algo=%p " "inst_id=%s " "user_id=%llu " "current_state=%s " "No recovery Unknown syn_status ", algo, algo->inst_id.to_string(), algo->user_id, ALGO_STATE_STR[algo->state]);
controller.cpp             SERVER_ILOG("DestroyAlgoJob: " "algo=%p " "inst_id=%s " "user_id=%llu " "current_state=%s " "No need to revoery for RECOVERY_FAILED", algo, algo->inst_id.to_string(), algo->user_id, ALGO_STATE_STR[algo->state]);
controller.cpp             SERVER_ILOG("DestroyAlgoJob: " "algo=%p " "inst_id=%s " "user_id=%llu " "current_state=%s " "created recovery request for " "current_syn_status=%s ", algo, algo->inst_id.to_string(), algo->user_id, ALGO_STATE_STR[algo->state], SynthStatus_Name(syn_status).to_std());
controller.cpp         SERVER_WLOG("SpawnAlgoJob0: Job0 already exist");
controller.cpp         SERVER_ILOG("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
controller.cpp         SERVER_ILOG("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Job0 pid =%8d !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", job0->pid);
controller.cpp         SERVER_ILOG("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
controller.cpp         SERVER_ELOG("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx");
controller.cpp         SERVER_ELOG("xxxxxxxxxxxxxxxxxxxxx Job0 failed to launch xxxxxxxxxxxxxxxxxxxxx");
controller.cpp         SERVER_ELOG("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx");
controller.cpp         SERVER_ELOG("fork failed, errno=%s", std::string(strerror(errno)));
controller.cpp         SERVER_ILOG( "Spawned child process for algojob %p [algojob_id=%llu, pid=%ld]", (void*)algojob, algojob->algojob_id, algojob->pid );
controller.cpp                 SERVER_ILOG( "TrySpawn() Configs, client_server_core_CPU=%s client_data_core_CPU=%s client_spin=%s client_onload=%s", clientServerCoreCPU, clientDataCoreCPU, clientSpin, clientOnload );
controller.cpp                         SERVER_WLOG("Onload is requested for the client (algojob), but is not presently enabled for algoserver. Ignoring the request to enable onload");
controller.cpp                 SERVER_ELOG( "TrySpawn() Generated File Failed, e=%s", std::string(e.what()));
controller.cpp             SERVER_ELOG( "TrySpawn() SpawnAlgoJob(...) Failed, error=%s", ALGOSERVER_ERROR_STR[error]);
controller.cpp     SERVER_ILOG( "UpdateAlgo algo_inst_id=%s from response_id=%s user_id=%llu current_user_id=%llu user_param_count=%d", algo->inst_id.to_string(), ALGO_RESPONSE_ID_STR[response_id], algo->params.user_id, algo->params.current_user_id, algo->params.count );
controller.cpp         SERVER_DLOG("SanitizeAlgoJobResponse fills_grp_size=%zu serialized_size=%zu", algo_params->fills_grp.fills_grp_size, algo_params->fills_grp.struct_size);
controller.cpp     SERVER_ELOG( "RespondFailure: " "request=[%s] " "user_id=%llu " "connection_id=%llu " "inst_id=%s " "market_id=%u " "response_count=%llu " "user_request_id=%llu " "algo_state=%s " "failure_code=[%s] " "request_flags=[%s %s %s]", ALGOJOB_REQUEST_ID_STR[request_id], user_id, connection_id, std::string(algo_uuid_string), market_id, response_count, user_request_id, ALGO_STATE_STR[state], ALGO_REQ_FAILURE_CODE_STR[failure], request_flags&algojob__request_force_success ? "force_success" : "", request_flags&algojob__request_so_algo ? "so_algo" : "", request_flags&algojob__request_recovery_adl_algo ? "recovery_adl_algo" : "" );
controller.cpp         SERVER_ELOG("ProcessAlgoJobRequestFailure: " "For algo=%s, OrderUpdate request=%s failed since algo does not exist in Job - " "no failure ER will be published!", ttuuid(response->inst_id).to_string(), ALGOJOB_REQUEST_ID_STR[request_failure.request_id]);
controller.cpp         SERVER_ELOG("ProcessAlgoJobRequestFailure: Recovery Request Failed!!! " "inst_id=%s " "failure_code=[%s] " "request_failure.state=[%s] " "algo->state=[%s] " "Run CLI to retry", ttuuid(response->inst_id).to_string(), ALGO_REQ_FAILURE_CODE_STR[request_failure.failure], ALGO_STATE_STR[request_failure.state], ALGO_STATE_STR[algo->state]);
controller.cpp     SERVER_ELOG("ProcessAlgoJobRequestFailure: " "request=[%s] " "inst_id=%s " "failure_code=[%s] " "state=%s->%s " "flags=%d", ALGOJOB_REQUEST_ID_STR[request_failure.request_id], ttuuid(response->inst_id).to_string(), ALGO_REQ_FAILURE_CODE_STR[request_failure.failure], ALGO_STATE_STR[before], ALGO_STATE_STR[request_failure.state], (int)request_failure.request_flags);
controller.cpp             SERVER_ILOG("Starting or Resuming was interrupted. " "algojob=%p " "state=%s->%s", (void*)algojob, ALGO_STATE_STR[before], ALGO_STATE_STR[request_complete.state]);
controller.cpp             SERVER_ILOG("Dropping transitional RequestComplete from AlgoJob " "algojob=%p " "state=%s->%s", (void*)algojob, ALGO_STATE_STR[before], ALGO_STATE_STR[request_complete.state]);
controller.cpp         SERVER_ELOG("inst_id=%s Something is not right. We should never be here.", ttuuid(response->inst_id).to_string());
controller.cpp     SERVER_ILOG("Converting Algojob RequestComplete to Status " "algojob=%p " "state=%s->%s", (void*)algojob, ALGO_STATE_STR[before], ALGO_STATE_STR[request_complete.state]);
controller.cpp             SERVER_ELOG("JOB0 reconnecting but job0 exists");
controller.cpp             SERVER_ILOG("JOB0 reconnected pid=%d", job0->pid);
controller.cpp         SERVER_ELOG("job_id=%llu not-supported with current design", job_id);
controller.cpp     SERVER_ILOG("AlgoJobData restored with %p [algojob_id=%llu, pid=%ld]", (void*)algojob, job_id, algojob->pid);
controller.cpp     SERVER_ILOG("ProcessAlgoJobInit(), job_id=%llu, user_request_id=%llu, response_id=%s", response->job_id, response->user_request_id, ALGO_RESPONSE_ID_STR[response->id]);
controller.cpp         SERVER_WLOG("***********************************************");
controller.cpp         SERVER_WLOG("* Existing job connected, job_id=%7llu *", response->job_id);
controller.cpp         SERVER_WLOG("***********************************************");
controller.cpp             SERVER_WLOG("Can not adopt existing algojob");
controller.cpp         SERVER_WLOG("algojob already running for job_id=%llu", response->job_id);
controller.cpp     SERVER_ILOG( "algojob_%llu %p [socket=%d] connected.", algojob->algojob_id, algojob, conn_data->ipc_connection->socket );
controller.cpp                 SERVER_ILOG("ProcessAlgoJobStatus: Recovery Request Failed!!! inst_id=%s reason=%s " "--Run CLI to retry (synth_status will remain unchanged to allow retry)", algo->inst_id.to_string(), reason);
controller.cpp                 SERVER_ILOG("ProcessAlgoJobStatus: Recovery Request Failed!!! inst_id=%s reason=%s --Unrecoverable!", algo->inst_id.to_string(), reason);
controller.cpp                 SERVER_ILOG("ProcessAlgoJobStatus: Recovery Request Worked!!! " "inst_id=%s " "staus.state=%s " "synth_status=%s " "msg=%s ", algo->inst_id.to_string(), ALGO_STATE_STR[status.state], tt::messaging::order::enums::SynthStatus_Name((tt::messaging::order::enums::SynthStatus)synth_status).to_std(), reason);
controller.cpp             SERVER_ELOG("ProcessAlgoJobStatus: Recovery Request Failed!!! inst_id=%s response has no synth_status", algo->inst_id.to_string());
controller.cpp     SERVER_ILOG("ProcessAlgoJobStatus: algo=%s state=%s->%s", algo->inst_id.to_string(), ALGO_STATE_STR[before], ALGO_STATE_STR[status.state]);
controller.cpp         SERVER_DLOG("ProcessAlgoJobStatus: algo:%s response_count=0 (just came from reconnected job). Skip sending status. State=%s", algo->inst_id.to_string(), ALGO_STATE_STR[algo->state]);
controller.cpp         SERVER_DLOG("ProcessAlgoJobValue: inst_id=%s, value_type=%d, block=%s, conn=%s, pathToRoot=%s, Map.size=%u, index=%u", std::string( algo_uuid_string), value->type, std::string( uuid_block_inst), std::string( uuid_connector_def), ossPathToRoot.str(), algo->mapBlockDefValues[ (algo->activeIndex) ].size(), algo->activeIndex);
controller.cpp         SERVER_ILOG("Found existing algo_inst_id=%s . Set seq_num=%llu and send latest status", ttuuid(inst_id).to_string(), init_seq_num);
controller.cpp         SERVER_ELOG("algo_inst_id=%s Can NOT AllocAlgoJobRequestData", ttuuid(inst_id).to_string());
controller.cpp             SERVER_ELOG("algo_inst_id=%s rejected. user_id=%lld already has user_sse_algo_count=%d SSE algos running. max_sse_algos_per_user=%d", ttuuid(inst_id).to_string(), user_id, user_sse_algo_count, algoserver__max_sse_algos_per_user);
controller.cpp             SERVER_ELOG("algo_inst_id=%s rejected. user_id=%lld already has user_adl_algo_count=%d ADL algos running. max_adl_algos_per_user=%d", ttuuid(inst_id).to_string(), user_id, user_adl_algo_count, algoserver__max_adl_algos_per_user);
controller.cpp         SERVER_ELOG("algo_inst_id=%s Can NOT InitAlgoData", ttuuid(inst_id).to_string());
controller.cpp         SERVER_ILOG("algo_inst_id=%s user_id=%lld params.algo_type=%s state=%s", ttuuid(algo->inst_id).to_string(), algo->user_id, TTSDK_ALGO_TYPE_STR[algo->params.algo_type], ALGO_STATE_STR[algo->state]);
controller.cpp             SERVER_ILOG("ProcessQueuedRequests: algojob %p not connected yet so deferring all queued requests!", static_cast<void*>(algojob));
controller.cpp                 SERVER_ILOG("ProcessQueuedRequests: Defer sending this queued request - we need to start a (late) download of USER info: " "algo_instance_id=%s " "algojob=%p " "user_request_id=%llu " "user_id=%llu " "originating_user_id=%llu ", algo_instance_id, static_cast<void*>(algojob), request_data->request.user_request_id, request_data->request.user_id, request_data->request.params.originating_user_id);
controller.cpp                             SERVER_ILOG("ProcessQueuedRequests: Defer sending this queued request - we need to wait for download of ORDER TAGS to resolve: " "algo_instance_id=%s " "algojob=%p " "user_request_id=%llu", algo_instance_id, static_cast<void*>(algojob), request_data->request.user_request_id);
controller.cpp                         SERVER_ILOG("ProcessQueuedRequests: Defer sending this queued request - we need to wait for download of RISK LIMITS to resolve: " "algo_instance_id=%s " "algojob=%p " "user_request_id=%llu", algo_instance_id, static_cast<void*>(algojob), request_data->request.user_request_id);
controller.cpp                         SERVER_ELOG("ProcessQueuedRequests: Dropping this queued request - failed to start async download of Aggregated Instrument Risk Limits: " "algo_instance_id=%s " "algojob=%p " "user_request_id=%llu", algo_instance_id, static_cast<void*>(algojob), request_data->request.user_request_id);
controller.cpp                     SERVER_ILOG("ProcessQueuedRequests: Defer sending this queued request - we need to wait for download of USER info to resolve: " "algo_instance_id=%s " "algojob=%p " "user_request_id=%llu", algo_instance_id, static_cast<void*>(algojob), request_data->request.user_request_id);
controller.cpp                         SERVER_ELOG("ProcessQueuedRequests: Failing this algo instance queued for start/recovery: " "reason=%s " "algo_instance_id=%s " "algojob=%p " "user_request_id=%llu", failure_reason, algo_instance_id, static_cast<void*>(algojob), request_data->request.user_request_id);
controller.cpp                     SERVER_WLOG("ProcessQueuedRequests: Failed to download TTUS User Info but sending the request to Job anyway: " "reason=%s " "algo_instance_id=%s " "algojob=%p " "user_request_id=%llu", failure_reason, algo_instance_id, static_cast<void*>(algojob), request_data->request.user_request_id);
controller.cpp             SERVER_ILOG("ProcessQueuedRequests: Send this queued request to algojob: " "algo_instance_id=%s " "algojob=%p " "user_request_id=%llu ", algo_instance_id, static_cast<void*>(algojob), request_data->request.user_request_id);
controller.cpp                 SERVER_ELOG("ProcessQueuedRequests: Failure forwarding this queued request to algojob: " "algo_instance_id=%s " "algojob=%p " "user_request_id=%llu " "error=%d ", algo_instance_id, static_cast<void*>(algojob), request_data->request.user_request_id, error);
controller.cpp                     SERVER_ELOG("ProcessQueuedRequests: Failure forwarding variable data to algojob: " "algo_instance_id=%s " "algojob=%p " "user_request_id=%llu " "error=%d ", algo_instance_id,								static_cast<void*>(algojob), request_data->request.user_request_id, error);
controller.cpp             SERVER_ILOG("ProcessQueuedRequests: for algojob_id=%llu: " "processed=%d " "skipped=%d", algojob->algojob_id, processedCount, skippedCount);
controller.cpp             SERVER_ILOG("MarshalClassOneTwoFields: request=%s user_request_id=%llu inst_id=%s " "%s", ALGOJOB_REQUEST_ID_STR[id], user_request_id, ttuuid(request_data->request.inst_id).to_string(), algo_params == nullptr ? "algo_params is null" : "request has no class_1_2");
controller.cpp     SERVER_ILOG( "Queued request for algojob %p, user_id=%llu, request_id=%s, user_request_id=%llu", (void*)algojob, user_id, ALGOJOB_REQUEST_ID_STR[request->id], user_request_id );
controller.cpp                 SERVER_ILOG("ProcessRecoveryRequest: There is still job reconnecting. Requeue this recovery request. " "user_request_id=%llu, user_id=%llu reconnecting_jobs=%s", algoserver_request.user_request_id, user_id, reconnecting_jobs);
controller.cpp         SERVER_ILOG("No need to recover: Algo inst exists. " "user_request_id=%llu, user_id=%llu", algoserver_request.user_request_id, user_id);
controller.cpp         SERVER_ELOG("ProcessRecoveryRequest: Error=%s, user_request_id=%llu, user_id=%llu ", ALGOSERVER_ERROR_STR[error], algoserver_request.user_request_id, user_id);
controller.cpp         SERVER_ELOG("ProcessRecoveryRequest: " "user_request_id=%llu, " "algo_inst_id=%s. Recovery Succeed for Held/Paused SSE Algo", algoserver_request.user_request_id, algo->inst_id.to_string());
controller.cpp          SERVER_ELOG("ProcessRecoveryRequest: user_request_id=%llu, user_id=%llu order_id=%s " "Skip recovery for TT Algo SDK order", algoserver_request.user_request_id, user_id, order_id.to_string());
controller.cpp         SERVER_ELOG("ProcessRecoveryRequest: user_request_id=%llu, user_id=%llu order_id=%s " "RenewTokenUponRecovery failed. But will continue Recovery", algoserver_request.user_request_id, user_id, order_id.to_string());
controller.cpp         SERVER_ILOG("MaybeDownloadAggregatedInstrumentRiskLimits: Skip download since request is not deploy_instr: " "inst_id=%s " "user_request_id=%llu", algo_instance_id, request_data->request.user_request_id);
controller.cpp     SERVER_ILOG("MaybeDownloadAggregatedInstrumentRiskLimits: originating_user_id=%llu user_id=%llu effective_user_id=%llu", request_data->request.params.originating_user_id, request_data->request.user_id, effective_user_id);
controller.cpp         SERVER_ILOG("MaybeDownloadAggregatedInstrumentRiskLimits: Skip download since USER's COMPANY has not opted for Algo Risk Checks: " "inst_id=%s " "user_request_id=%llu", algo_instance_id, request_data->request.user_request_id);
controller.cpp         SERVER_ILOG("MaybeDownloadAggregatedInstrumentRiskLimits: Skip download since this algo is NOT an SSE algo type: " "inst_id=%s " "user_request_id=%llu", algo_instance_id, request_data->request.user_request_id);
controller.cpp         SERVER_ELOG("MaybeDownloadAggregatedInstrumentRiskLimits: User ID missing! " "inst_id=%s " "user_request_id=%llu", algo_instance_id, request_data->request.user_request_id);
controller.cpp         SERVER_ELOG("MaybeDownloadAggregatedInstrumentRiskLimits: Order instrument ID missing! " "inst_id=%s " "user_request_id=%llu", algo_instance_id, request_data->request.user_request_id);
controller.cpp         SERVER_ELOG("MaybeDownloadAggregatedInstrumentRiskLimits: Account ID missing! " "inst_id=%s " "user_request_id=%llu", algo_instance_id, request_data->request.user_request_id);
controller.cpp         SERVER_ILOG("MaybeDownloadAggregatedInstrumentRiskLimits: Download required! Cache is absent. " "inst_id=%s " "user_request_id=%llu", algo_instance_id, request_data->request.user_request_id);
controller.cpp             SERVER_ILOG("MaybeDownloadAggregatedInstrumentRiskLimits: Exempt! Instrument is synthetic. " "inst_id=%s " "user_request_id=%llu", algo_instance_id, request_data->request.user_request_id);
controller.cpp             SERVER_ILOG("MaybeDownloadAggregatedInstrumentRiskLimits: Download pending! " "inst_id=%s " "user_request_id=%llu", algo_instance_id, request_data->request.user_request_id);
controller.cpp                 SERVER_ILOG("MaybeDownloadAggregatedInstrumentRiskLimits: Download required! Cache is stale. " "cache_age_in_seconds=%lld " "cache_age_in_minutes=%lld " "inst_id=%s " "user_request_id=%llu", static_cast<long long int>(cache_age_in_seconds), static_cast<long long int>(cache_age_in_minutes), algo_instance_id, request_data->request.user_request_id);
controller.cpp                     SERVER_ELOG("MaybeDownloadAggregatedInstrumentRiskLimits: Failure! Cache is recent but last download was a failure! " "cache_age_in_seconds=%lld " "cache_age_in_minutes=%lld " "inst_id=%s " "user_request_id=%llu", static_cast<long long int>(cache_age_in_seconds), static_cast<long long int>(cache_age_in_minutes), algo_instance_id, request_data->request.user_request_id);
controller.cpp                     SERVER_ILOG("MaybeDownloadAggregatedInstrumentRiskLimits: No download required! Cache is recent and last download was a success! " "cache_age_in_seconds=%lld " "cache_age_in_minutes=%lld " "inst_id=%s " "user_request_id=%llu", static_cast<long long int>(cache_age_in_seconds), static_cast<long long int>(cache_age_in_minutes), algo_instance_id, request_data->request.user_request_id);
controller.cpp         SERVER_ILOG("MaybeDownloadAggregatedInstrumentRiskLimits: Using Risk Limits Cache: " "inst_id=%s " "user_request_id=%llu " "pdci_one_min_ticks=%u " "pdci_one_min_pct=%u " "pdci_three_min_ticks=%u " "pdci_three_min_pct=%u " "pdci_lifetime_ticks=%u " "pdci_lifetime_pct=%u " "spdci_one_min_ticks=%u " "spdci_one_min_pct=%u " "spdci_three_min_ticks=%u " "spdci_three_min_pct=%u " "spdci_lifetime_ticks=%u " "spdci_lifetime_pct=%u " "max_child_slice_size=%u " "max_number_of_cancels=%u " "max_number_of_updates=%u " "is_spread_or_strategy=%d", algo_instance_id, request_data->request.user_request_id, cache_ptr->risk_limits.pdci_one_min_ticks, cache_ptr->risk_limits.pdci_one_min_pct, cache_ptr->risk_limits.pdci_three_min_ticks, cache_ptr->risk_limits.pdci_three_min_pct, cache_ptr->risk_limits.pdci_lifetime_ticks, cache_ptr->risk_limits.pdci_lifetime_pct, cache_ptr->risk_limits.spdci_one_min_ticks, cache_ptr->risk_limits.spdci_one_min_pct, cache_ptr->risk_limits.spdci_three_min_ticks, cache_ptr->risk_limits.spdci_three_min_pct, cache_ptr->risk_limits.spdci_lifetime_ticks, cache_ptr->risk_limits.spdci_lifetime_pct, cache_ptr->risk_limits.max_child_slice_size, cache_ptr->risk_limits.max_number_of_cancels, cache_ptr->risk_limits.max_number_of_updates, cache_ptr->risk_limits.is_spread_or_strategy);
controller.cpp         SERVER_ELOG("MaybeDownloadAggregatedInstrumentRiskLimits: Failed to start async download! " "inst_id=%s " "user_request_id=%llu", algo_instance_id, request_data->request.user_request_id);
controller.cpp     SERVER_ILOG("MaybeDownloadAggregatedInstrumentRiskLimits: Started async download and download is now pending! " "inst_id=%s " "user_request_id=%llu", algo_instance_id, request_data->request.user_request_id);
controller.cpp         SERVER_ELOG("algo_inst_id=%s is missing algo_instr_id in its params!", ttuuid(algoserver_request.inst_id).to_string());
controller.cpp         SERVER_ELOG("algo_inst_id=%s Can NOT AllocAlgoJobRequestData", ttuuid(algoserver_request.inst_id).to_string());
controller.cpp         SERVER_ELOG( "ProcessDeployInstrRequest: Error=%s, user_request_id=%llu user_id=%llu ", ALGOSERVER_ERROR_STR[error], algoserver_request.user_request_id, algoserver_request.user_id );
controller.cpp         SERVER_ELOG( "ProcessResumeRequest: Error=%s, user_request_id=%llu", ALGOSERVER_ERROR_STR[error], algoserver_request.user_request_id );
controller.cpp         SERVER_ILOG("ProcessResumeRequest: Setting [has_class_1_2_fields] to TRUE for: " "inst_id=%s " "user_request_id=%llu", ttuuid(algoserver_request.inst_id).to_string(), algoserver_request.user_request_id);
controller.cpp         SERVER_ELOG("ProcessPauseRequest: Error=%s, user_request_id=%llu", ALGOSERVER_ERROR_STR[error], algoserver_request.user_request_id);
controller.cpp         SERVER_WLOG( "ProcessStopRequest: Error=%s, user_request_id=%llu", ALGOSERVER_ERROR_STR[error], algoserver_request.user_request_id );
controller.cpp         SERVER_ELOG("ProcessUpdateRequest: Error=%s, user_request_id=%llu", ALGOSERVER_ERROR_STR[error], algoserver_request.user_request_id);
controller.cpp         SERVER_ELOG( "ProcessRegisterSideChannelRequest: Error=%s. user_request_id=%llu, user_id=%llu", ALGOSERVER_ERROR_STR[error], algoserver_request.user_request_id, algoserver_request.user_id );
controller.cpp         SERVER_ELOG( "ProcessUnregisterSideChannelRequest: Error=%s. user_request_id=%llu, user_id=%llu", ALGOSERVER_ERROR_STR[error], algoserver_request.user_request_id, algoserver_request.user_id );
controller.cpp         SERVER_DLOG( "ProcessParamSnapshotRequest: Error=%s, user_request_id=%llu, user_id=%llu", ALGOSERVER_ERROR_STR[error], algoserver_request.user_request_id, algoserver_request.user_id );
controller.cpp         SERVER_DLOG("ProcessParamSnapshotRequest: Algo has no export value");
controller.cpp     SERVER_ILOG( "ProcessHandleUserDisconnectReq: user_request_id=%llu, user_id=%llu algojob=%llu", handle_disconnect_request.user_request_id, handle_disconnect_request.user_id, algojob->algojob_id );
controller.cpp     SERVER_ILOG( "ProcessSetOMAParentIdRequest: user_request_id=%llu, user_id=%llu algojob=%llu", request_data->request.user_request_id, request_data->request.user_id, algojob->algojob_id );
controller.cpp     SERVER_ILOG( "ProcessClearOMAParentIdRequest: user_request_id=%llu, user_id=%llu algojob=%llu", request_data->request.user_request_id, request_data->request.user_id, algojob->algojob_id );
controller.cpp         SERVER_ELOG("SendUserToAllJobs: Download for user_id=%llu failed!", user_id);
controller.cpp             SERVER_ILOG("SendUserToAllJobs: user_id=%llu, algo_job_id=%llu has NULL algojob", user_id, pair.first);
controller.cpp             SERVER_ILOG( "SendUserToAllJobs: user_id=%llu, but algojob %p not connection_established. Skip this call", user_id, algojob );
controller.cpp     SERVER_ILOG("SendUserToAllJobs: Download for user_id=%llu completed!", user_id);
controller.cpp                     SERVER_ELOG("CheckCompanyNeedSynLegFill: algo_inst_id=%s not found", ttuuid(request.inst_id).to_string());
controller.cpp             SERVER_ELOG("[%s]: Account ID missing!", std::string(algo_uuid_string));
controller.cpp                 SERVER_ELOG("[%s]: Could not find organization for account_id=%llu user_id=%llu. This is expected if this is the first algo for this user_id", algo_uuid_string, account_id, user_id);
controller.cpp                 SERVER_ILOG("[%s]: account_id=%llu user_id=%llu organization=[%s]", std::string(algo_uuid_string), account_id, user_id, organization_str);
controller.cpp                     SERVER_ELOG("CheckUserOrganization: algo_inst_id=%s not found", ttuuid(request.inst_id).to_string());
controller.cpp         SERVER_WLOG("SendUserUpdateToAlgoJob: TTUSWeb::Instance().GetUser() failed. user_id=%llu.", user_id);
controller.cpp         SERVER_ELOG("SendUserUpdateToAlgoJob: Failed to send update_user [user_id=%llu] to algojob %p", user_id, algojob);
controller.cpp         SERVER_ILOG("SendUserUpdateToAlgoJob: Sent update_user [user_id=%llu] to algojob %p", user_id, algojob);
controller.cpp             SERVER_ELOG("SendAppTokenToAllJobs: algo_job_id=%llu is a nullptr - skipping", pair.first);
controller.cpp             SERVER_ELOG("SendAppTokenToAllJobs: algojob=%p has not yet established connection - skipping", algojob);
controller.cpp         SERVER_ELOG("SendAppTokenToJob: algojob ptr was unexpectedly a nullptr!");
controller.cpp         SERVER_ELOG("SendAppTokenToJob: algojob=%p has not yet established connection!", algojob);
controller.cpp         SERVER_ELOG("SendAppTokenToJob: Failed to send update_app_token to algojob %p", algojob);
controller.cpp     SERVER_ILOG("SendAppTokenToJob: Sent update_app_token to algojob %p", algojob);
controller.cpp         SERVER_ILOG("Tracking child." " inst_id=%s" " order_id=%s", algo->inst_id.to_string(), child_id.to_string());
controller.cpp             SERVER_ILOG("Untracking child." " inst_id=%s" " order_id=%s", algo->inst_id.to_string(), child_id.to_string());
controller.cpp         SERVER_ILOG("DownloadOrderTagDefaults: OTD download is not required for algo_inst_id=%s " "because OTD feature is disabled on the current server", algo_inst_id.to_string());
controller.cpp         SERVER_ILOG("DownloadOrderTagDefaults: OTD download is not required for algo_inst_id=%s " "because it's not an SSE algo", algo_inst_id.to_string());
controller.cpp         SERVER_ILOG("DownloadOrderTagDefaults: OTD download is not required for algo_inst_id=%s " "because this is algoserver_debug", algo_inst_id.to_string());
controller.cpp         SERVER_ILOG("DownloadOrderTagDefaults: OTD download is not required for algo_inst_id=%s " "because this algo instance is recovering (it should use OTDs downloaded in its former life)", algo_inst_id.to_string());
controller.cpp         SERVER_WLOG("DownloadOrderTagDefaults: OTD download is not required for algo_inst_id=%s " "because primary_market_id is missing", algo_inst_id.to_string());
controller.cpp         SERVER_ILOG("DownloadOrderTagDefaults: OTD download is not required for algo_inst_id=%s " "because primary_market_id is synthetic", algo_inst_id.to_string());
controller.cpp         SERVER_ILOG("DownloadOrderTagDefaults: OTD download is not required for algo_inst_id=%s " "because it is driving an ASE/AGG instrument", algo_inst_id.to_string());
controller.cpp         SERVER_ILOG("DownloadOrderTagDefaults: OTD download is not required for algo_inst_id=%s " "because it is driving an ASE/AGG instrument", algo_inst_id.to_string());
controller.cpp         SERVER_DLOG("DownloadOrderTagDefaults: Download is not required for algo_inst_id=%s because " "download is already pending, or, OTD's have been downloaded and are waiting in IPC queue to be sent to job", algo_inst_id.to_string());
controller.cpp     SERVER_ILOG("DownloadOrderTagDefaults: Attempting to send OTD NOS for algo_inst_id=%s...", algo_inst_id.to_string());
controller.cpp         SERVER_WLOG("DownloadOrderTagDefaults: Failed to send OTD NOS for algo_inst_id=%s! " "This error is not fatal - continuing without OTDs!", algo_inst_id.to_string());
controller.cpp     SERVER_ILOG("DownloadOrderTagDefaults: Sent OTD NOS for algo_inst_id=%s and awaiting response!", algo_inst_id.to_string());
controller.cpp         SERVER_ILOG("ProcessRequest: Drop requet=%s for recovering algo=%s", ALGOJOB_REQUEST_ID_STR[request.id], ttuuid(request.inst_id).to_string());
controller.cpp             SERVER_ILOG("RESERVED: ProcessRequest() user_id=%llu, job_id=%u, reserved=%d, algojob->uid=%llu, owned_algos=%u", request.user_id, algojob->algojob_id, algojob->reserved, algojob->user_id, algojob->owned_algos.size());
controller.cpp                     SERVER_ELOG("failed to process algojob__request_handle_user_disconnect: " "user_id=%llu " "error=algoserver__error_memory_alloc", request.user_id);
controller.cpp             SERVER_ILOG("ProcessRequest: Received TRIAGE CLI Cmd!");
controller.cpp                 SERVER_ELOG("ProcessRequest: Params on the request are incomplete and we couldn't find the algo! " "Skip sending failure OrderCancelReject for: algo=%s request=%s", ttuuid(request.inst_id).to_string(), ALGOJOB_REQUEST_ID_STR[request.id]);
controller.cpp             SERVER_ELOG("ProcessRequest: ProcessOrderReviewApproveViaUpdate failed! " "Sending failure OrderCancelReject for: algo=%s request=%s", ttuuid(request.inst_id).to_string(), ALGOJOB_REQUEST_ID_STR[request.id]);
controller.cpp             SERVER_ILOG("ProcessRequest: This request is trivial and doesn't require a failure response. " "Skip sending failure ER for: algo=%s request=%s", ttuuid(request.inst_id).to_string(), ALGOJOB_REQUEST_ID_STR[request.id]);
controller.cpp                 SERVER_ELOG("Error processing disconnect");
controller.cpp             SERVER_WLOG("ProcessDisconnectCommand connection_id=%llu sending STOP to [algo=%s]", algo->connection_id, algo->inst_id.to_string());
controller.cpp                 SERVER_WLOG("[algo_inst_id=%s]: Skip Cleanup", algo->inst_id.to_string());
controller.cpp                 SERVER_ILOG("TryAlgoCleanup: Algo stopped: " "algo->inst_id=%s ", algo->inst_id.to_string());
controller.cpp     SERVER_ILOG("New algojob connected [client_connection->socket=%d]. Add connection_data=%p to s_connections", client_connection->socket, conn_data);
controller.cpp                 SERVER_WLOG("JOB0 disconnected. Respawning....");
controller.cpp                 SERVER_WLOG("DestroyClient can not found algojob=%p.", algojob);
controller.cpp         SERVER_ILOG("DestroyClient: Found algojob_id=%llu", algojob->algojob_id);
controller.cpp         SERVER_WLOG("DestroyClient: Remove connection_data=%p from s_connections", conn_data);
controller.cpp             SERVER_ILOG("CheckOrderTagDownloadTimeouts: Order Tag download timed out: " "algo_inst_id=%s " "request_time_ns=%llu", algo_inst_ttuuid.to_string(), request_time);
controller.cpp                 SERVER_ILOG("CheckJob:PeriodicTask: found RUNNING dead Algojob [%d]", dead_pid);
controller.cpp                     SERVER_ELOG("CheckJob:PeriodicTask: GetJobProcessStatus failed. Will try on next attempt");
controller.cpp             SERVER_ILOG("CheckJob:PeriodicTask: found stale Algojob process." " stale_jobs=%s" " status=%s", std::to_string(stale_jobs), std::to_string(status));
controller.cpp         SERVER_ILOG("HandleRemoveClassOneTwo: algo_inst_id=%s. Skip due to generate_synthetic_leg_fill", ttuuid(algo_inst_id).to_string());
controller.cpp         SERVER_DLOG( "process response from algojob %p response->id=[%s]", (void*)algojob, ALGO_RESPONSE_ID_STR[*id] );
controller.cpp                     SERVER_ELOG("Failed to get algo_instr_Id, can not re-populate inst_id=%s", tt::algoutil::ttuuid(response->inst_id).to_string());
controller.cpp                     SERVER_ELOG("Failed to recreate algo from snapshot");
controller.cpp                     SERVER_ILOG("Recreated [algo:%s]: algo_instr_Id=%llu, user_id=%llu. state=%s algo_type=%s", reconn_algo->inst_id.to_string(), reconn_algo->instr_id, reconn_algo->user_id, ALGO_STATE_STR[reconn_algo->state], TTSDK_ALGO_TYPE_STR[response->params.algo_type] );
controller.cpp             SERVER_ILOG("Algojob_%llu has finished sending snapshot of algos", response->job_id);
controller.cpp             SERVER_ILOG("Algojob_%llu received LOOPBACK order request, size=%u", response->job_id, response->data.loopback_order_request.payload_size);
controller.cpp                     SERVER_ELOG("!! Error !! Failure processing LOOPBACK data [%u]", error);
controller.cpp             SERVER_ELOG("ProcessClientRequest: unknown response->id=%d ", (int)response->id);
controller.cpp         SERVER_ELOG( "Error[%s] while processing algojob response=[%s]", ALGOSERVER_ERROR_STR[error], ALGO_RESPONSE_ID_STR[*id] );
controller.cpp         SERVER_WLOG("***********************************************");
controller.cpp         SERVER_WLOG("* Killing Algojob_%llu result=%d *", algojob->algojob_id, ret);
controller.cpp         SERVER_WLOG("***********************************************");
controller.cpp         SERVER_WLOG("***********************************************");
controller.cpp         SERVER_WLOG("* Killing JOB0 result=%d *", ret);
controller.cpp         SERVER_WLOG("***********************************************");
controller.cpp     SERVER_ILOG("HOW BAD IS sizeof(ttsdk_params_internal)=%d", sizeof(ttsdk_params_internal));
controller.cpp     SERVER_ILOG("HOW BAD IS sizeof(algojob__request)=%d", sizeof(algojob__request));
controller.cpp     SERVER_ILOG("HOW BAD IS sizeof(algoserver__request)=%d", sizeof(algoserver__request));
controller.cpp     SERVER_ILOG("HOW BAD IS sizeof(user_obj)=%d", sizeof(user_obj));
controller.cpp     SERVER_ILOG("ConfigXml: algojob_bin=%s", algojob_bin);
controller.cpp     SERVER_ILOG("ConfigXml: algojob_bin_prefix=%s", algojob_bin_prefix);
controller.cpp     SERVER_ILOG("ConfigXml: algojob_user=%s", algojob_user);
controller.cpp     SERVER_ILOG("Exiting! mapToAlgoJobData.size=%u", mapToAlgoJobData.size());
controller.cpp                 SERVER_ILOG("RequestDownloadUser: Nothing to do since download_status=%s for user_id=%llu", std::string(status == user_info_download_status::completed ? "completed" : "pending"), user_id);
controller.cpp             SERVER_ILOG("RequestDownloadUser: Attempting new download since download_status=failed for user_id=%llu", user_id);
controller.cpp             SERVER_ILOG("RequestDownloadUser: Server is remote so setting download_status=completed for user_id=%llu", user_id);
controller.cpp         SERVER_ILOG("RequestDownloadUser: Starting async download for user_id=%llu onto TTUS Worker Thread...", user_id);
controller.cpp             SERVER_ILOG("RequestDownloadUser: Async download is now pending for user_id=%llu", user_id);
controller.cpp             SERVER_ELOG("RequestDownloadUser Async download failed to start for user_id=%llu", user_id);
controller.cpp         SERVER_ELOG("Check_Job1: GetJobProcessStatus failed. Will sleep 2 sec to allow exsting job to reconnect. cmd=\"%s\"", status.cmd);
controller.cpp         SERVER_ILOG("Check_Job1: %s. cmd=\"%s\"", result, status.cmd);
controller.cpp             SERVER_ILOG("Check_Job1:CmdOutput: %s", data);
controller.cpp         SERVER_ELOG("ProcessOrderFillUpdate: Algo not found. inst_id=%s", ttuuid(request.inst_id).to_string());
controller.cpp     SERVER_ILOG("ProcessOrderFillUpdate: inst_id=%s cl_ord_id=%llu user_request_id=%llu orig_cl_ord_id=%llu ", algo->inst_id.to_string(), user_request_id, cl_ord_id, orig_cl_ord_id);
controller.cpp         SERVER_ELOG("ProcessOrderPass: Failed with error=Algojob not found (inst_id=%s)", ttuuid(algoserver_request.inst_id).to_string());
controller.cpp         SERVER_ELOG("ProcessOrderPass: Failed with error=Algo not found (inst_id=%s)", ttuuid(algoserver_request.inst_id).to_string());
controller.cpp         SERVER_ELOG("ProcessOrderPass: Failed with error=%s (inst_id=%s)", error, ttuuid(algoserver_request.inst_id).to_string());
controller.cpp     SERVER_ILOG("ProcessOrderPass: Sending OBP request (user_request_id=%llu, user_id=%llu) to algojob=%llu", request_data->request.user_request_id, request_data->request.user_id, algojob->algojob_id);
controller.cpp         SERVER_ELOG("ProcessOrderReviewApproveViaUpdate: Algo not found. inst_id=%s", ttuuid(algoserver_request.inst_id).to_string());
controller.cpp         SERVER_ELOG("ProcessOrderReviewApproveViaUpdate: algo:%s missing review_status or review_user_id", algo->inst_id.to_string());
controller.cpp     SERVER_ILOG("ProcessOrderReviewApproveViaUpdate: inst_id=%s review_status=%s review_user_id=%llu", algo->inst_id.to_string(), TTSDK_ReviewStatusToString(new_review_status), new_review_user_id);
controller.cpp         SERVER_ELOG("ProcessOrderReviewApproveViaUpdate: Error=%s, user_request_id=%llu", ALGOSERVER_ERROR_STR[algoserver__error_memory_alloc], algoserver_request.user_request_id);
controller.cpp     SERVER_ILOG( "ProcessOrderReviewApproveViaUpdate: user_request_id=%llu, user_id=%llu algojob=%llu", request_data->request.user_request_id, request_data->request.user_id, algojob->algojob_id);
controller.cpp         SERVER_ELOG("ProcessOrderReviewApproveViaFillUpdate: Not allowed for currently working algos. inst_id=%s", ttuuid(algoserver_request.inst_id).to_string());
controller.cpp         SERVER_ELOG("ProcessTextUpdateViaFillUpdate: Not allowed for currently working algos. inst_id=%s", ttuuid(algoserver_request.inst_id).to_string());
controller.cpp         SERVER_ELOG("ProcessDeployHeldOrder: Error=%s, user_request_id=%llu user_id=%llu ", ALGOSERVER_ERROR_STR[error], request.user_request_id, request.user_id);
controller.cpp         SERVER_ELOG("ProcessDeployHeldOrder: " "algo_inst_id=%s " "user_request_id=%llu " "user_id=%llu " "Only SSE can be placed as HELD", algo->inst_id.to_string(), request.user_request_id, request.user_id);
controller.cpp     SERVER_ILOG("ProcessRequestToHeldOrder: request=%s, user_request_id=%llu algo_inst_id=%s", ALGOJOB_REQUEST_ID_STR[request.id], request.user_request_id, algo->inst_id.to_string());
controller.cpp             SERVER_ELOG("ProcessRequestToHeldOrder: Request failed! request=%s, user_request_id=%llu algo_inst_id=%s", ALGOJOB_REQUEST_ID_STR[request.id], request.user_request_id, algo->inst_id.to_string());
controller.cpp         SERVER_WLOG("ProcessRequestToHeldOrder: Drop request=%s user_request_id=%llu SSE algo=%s", ALGOJOB_REQUEST_ID_STR[request.id], request.user_request_id, algo->inst_id.to_string());
controller.cpp     SERVER_ILOG("ProcessRequestToPausedOrder: request=%s, user_request_id=%llu algo_inst_id=%s", ALGOJOB_REQUEST_ID_STR[request.id], request.user_request_id, algo->inst_id.to_string());
controller.cpp         SERVER_ILOG("ProcessRequestToPausedOrder: Converting stop request into a special request " "to resume first and then cancel immediately afterwards: " "user_request_id=%llu " "algo_inst_id=%s", request.user_request_id, algo->inst_id.to_string());
controller.cpp         SERVER_WLOG("ProcessRequestToPausedOrder: Drop request=%s user_request_id=%llu SSE algo=%s", ALGOJOB_REQUEST_ID_STR[request.id], request.user_request_id, algo->inst_id.to_string());
controller.cpp     SERVER_ILOG("[algo_inst_id=%s]: ProcessDelayedFill: for " "child_order_id=%s " "child_order_seq=%llu " "count=%llu", algo_inst_id.to_string(), child_order_id, child_order_seq, count);
controller.cpp         SERVER_ELOG("[algo_inst_id=%s]: ProcessDelayedFill: " "Failed to find algo for " "child_order_id=%s " "child_order_seq=%llu", algo_inst_id.to_string(), child_order_id, child_order_seq);
controller.cpp         SERVER_ILOG("[algo_inst_id=%s]: Send delayed_fill=%s " "should_generate_synthetic_leg_fill become false", algo_inst_id.to_string(), er->ShortDebugString().to_std());
controller.cpp         SERVER_ELOG("[algo_inst_id=%s]: Cannot get primary_market_id", algo_inst_id.to_string());
controller.cpp             SERVER_ELOG("[algo_inst_id=%s]: Drop delayed_fill ", "child_order_id=%s " "child_order_seq=%llu " "count=%llu", algo_inst_id.to_string(), child_order_id, child_order_seq, count);
controller.cpp             SERVER_ILOG("[algo_inst_id=%s]: Requeue delayed_fill ", "child_order_id=%s " "child_order_seq=%llu " "count=%llu", algo_inst_id.to_string(), child_order_id, child_order_seq, count);
controller.cpp     SERVER_ILOG("[algo_inst_id=%s]: er successfully augmented! " "Send delayed_fill=%s ", algo_inst_id.to_string(), er->ShortDebugString().to_std());
controller.cpp         SERVER_ELOG("[algo_inst_id=%s]: ProcessChildFill: " "Failed to find algo for order_id=%s", algo_inst_id.to_string(), order_id_string);
controller.cpp             SERVER_WLOG("[algo_inst_id=%s]: ProcessChildFill: Skip synthetic_order_type=%s", algo_inst_id.to_string(), TTSDK_ORDER_SYNTHETIC_TYPE_STR[synthetic_order_type]);
controller.cpp         SERVER_WLOG("[algo_inst_id=%s]: ProcessChildFill: algo has parent_order_id=%s. Must be child of OCO.", algo_inst_id.to_string(), ttuuid(parent_order_id).to_string());
controller.cpp         SERVER_ILOG("[algo_inst_id=%s]: ProcessChildFill: spread fill! " "Cache and wait for job fill (either come in soon or requeued through ProcessDelayedFill " "reporting_type=%s " "order_sequence=%llu " "order_id=%s " "total_expected_qty_across_legs_per_lot=%0.8f " "native_spread_fills_received.size=%zu ", algo_inst_id.to_string(), MultiLegReportingType_Name(child_fill->multi_leg_reporting_type()).to_std() .substr(MULTI_LEG_REPORTING_TYPE_PREFIX_SIZE), seq, order_id_string, cached_native_spread_fill.total_expected_qty_across_legs_per_lot, algo->native_spread_fills_received.size());
controller.cpp         SERVER_ELOG("[algo_inst_id=%s]: ProcessChildFill failed to find spread fill " "order_id=%s " "seq=%llu ", algo_inst_id.to_string(), order_id_string, seq);
controller.cpp         SERVER_ILOG("[algo_inst_id=%s]: ProcessChildFill: Add leg fill! " "reporting_type=%s " "order_sequence=%llu " "order_id=%s " "instrument_id=%llu " "last_qty=%0.8f " "synthetic_fills_sent.size=%zu ", algo_inst_id.to_string(), MultiLegReportingType_Name(child_fill->multi_leg_reporting_type()).to_std().substr(MULTI_LEG_REPORTING_TYPE_PREFIX_SIZE), seq, order_id_string, child_fill->instrument_id(), child_fill->last_qty(), algo->synthetic_fills_sent.size());
controller.cpp         SERVER_ILOG("[algo_inst_id=%s]: ProcessChildFill: Algo already sent spread_fill " "[order_sequence=%llu " "order_id=%s] with " "cached_native_spread_fill.algo_er_sequence=%llu " "head_sent=%d " "total_sent=%llu ", algo_inst_id.to_string(), seq, order_id_string, cached_native_spread_fill.algo_er_sequence, head_sent, cached_native_spread_fill.total_sent);
controller.cpp             SERVER_ELOG("[algo_inst_id=%s]: Cannot get primary_market_id", algo_inst_id.to_string());
controller.cpp                SERVER_ILOG("[algo_inst_id=%s]: ProcessChildFill: All legs sent " "[order_sequence=%llu " "order_id=%s] with " "total_sent=%llu " "spread_qty=%0.8f " "total_sent_qty_across_legs=%0.8f " "total_expected_qty_across_legs_per_lot=%0.8f " "total_expected_qty_across_legs=%0.8f " "native_spread_fills_received.size=%zu " "synthetic_fills_sent.size=%zu ", algo_inst_id.to_string(), seq, order_id_string, cached_native_spread_fill.total_sent, spread_qty, cached_native_spread_fill.total_sent_qty_across_legs, cached_native_spread_fill.total_expected_qty_across_legs_per_lot, cached_native_spread_fill.total_expected_qty_across_legs_per_lot*spread_qty, algo->native_spread_fills_received.size(), algo->synthetic_fills_sent.size());
controller.cpp                SERVER_ILOG("[algo_inst_id=%s]: ProcessChildFill: one more leg sent " "[order_sequence=%llu " "order_id=%s] with " "total_sent=%llu " "spread_qty=%0.8f " "total_sent_qty_across_legs=%0.8f " "total_expected_qty_across_legs_per_lot=%0.8f " "total_expected_qty_across_legs=%0.8f", algo_inst_id.to_string(), seq, order_id_string, cached_native_spread_fill.total_sent, spread_qty, cached_native_spread_fill.total_sent_qty_across_legs, cached_native_spread_fill.total_expected_qty_across_legs_per_lot, cached_native_spread_fill.total_expected_qty_across_legs_per_lot*spread_qty);
controller.cpp         SERVER_ELOG("[algo_inst_id=%s]: send_synthetic_leg_fill failed to find leg info for instrument_id=%llu", inst_id.to_string(), leg_instrument_id);
controller.cpp     SERVER_ILOG("[algo_inst_id=%s]: send_synthetic_leg_fill: " "leg info=[instrument_id=%llu " "ratio=%0.8f " "cum_qty=%0.8f " "avg_px=%0.8f] " "child_fill=[last_qty=%0.8f, last_px=%0.8f] " "algo_order_qty=%0.8f ", inst_id.to_string(), leg_info.instrument_id, leg_info.ratio, leg_info.cum_qty, leg_info.avg_px, last_qty, last_px, params.order_qty);
controller.cpp     SERVER_ILOG("[algo_inst_id=%s]: Send synthetic_leg_fill=%s ", inst_id.to_string(), child_fill->ShortDebugString().to_std());
controller.cpp         SERVER_DLOG("[algo_inst_id=%s]: should_generate_synthetic_leg_fill=false", inst_id.to_string());
controller.cpp         SERVER_WLOG("[algo_inst_id=%s]: failed to find spread fill " "order_id=%s " "seq=%llu ", inst_id.to_string(), order_id, seq);
controller.cpp     SERVER_ILOG("[algo_inst_id=%s] augment ER for " "[order_id=%s " "seq=%llu] " "Copied fills_grp_size=%zu " "key=%s " "total_sent_qty_across_legs=%0.8f " "synthetic_fills_sent.size=%zu ", inst_id.to_string(), order_id, seq, fills_grp_size, key, cached_native_spread_fill.total_sent_qty_across_legs, synthetic_fills_sent.size());
controller.cpp             SERVER_ILOG("[algo_inst_id=%s]: send_synthetic_leg_fill SKIPPING: sequence mismatch " "[order_id=%s " "seq=%llu] " "total_sent=%llu " "leg_fill_order_id=%s " "leg_fill->last_qty=%0.8f " "leg_fill->order_sequence=%llu ", inst_id.to_string(), order_id, seq, total_sent, leg_fill_order_id.to_string(), leg_fill->last_qty(), leg_fill->order_sequence());
controller.cpp                 SERVER_ILOG("[algo_inst_id=%s]: send_synthetic_leg_fill SKIPPING: order_id mismatch " "[order_id=%s " "seq=%llu] " "total_sent=%llu " "leg_fill_order_id=%s " "leg_fill->last_qty=%0.8f ", inst_id.to_string(), order_id, seq, total_sent, leg_fill_order_id.to_string(), leg_fill->last_qty());
controller.cpp                     SERVER_ILOG("[algo_inst_id=%s]: send_synthetic_leg_fill OK " "[order_id=%s " "seq=%llu] " "total_sent=%llu " "total_sent_qty_across_legs=%0.8f " "total_expected_qty_across_legs_per_lot=%0.8f " "leg_fill->last_qty=%0.8f " "primary_market_id=%u ", inst_id.to_string(), order_id, seq, total_sent, cached_native_spread_fill.total_sent_qty_across_legs, cached_native_spread_fill.total_expected_qty_across_legs_per_lot, leg_fill->last_qty(), primary_market_id);
controller.cpp                     SERVER_ELOG("[algo_inst_id=%s]: send_synthetic_leg_fill failed " "[order_id=%s " "seq=%llu] ", inst_id.to_string(), order_id, seq);
controller.cpp         SERVER_ILOG("[algo_inst_id=%s]: All legs sent! [order_id=%s seq=%llu] total_sent=%zu " "spread_qty=%0.8f " "total_sent_qty_across_legs=%0.8f " "total_expected_qty_across_legs_per_lot=%0.8f " "total_expected_qty_across_legs=%0.8f " "leg_size=%zu " "native_spread_fills_received.size=%zu " "synthetic_fills_sent.size=%zu ", inst_id.to_string(), order_id, seq, total_sent, spread_qty, cached_native_spread_fill.total_sent_qty_across_legs, cached_native_spread_fill.total_expected_qty_across_legs_per_lot, cached_native_spread_fill.total_expected_qty_across_legs_per_lot*spread_qty, leg_infos.size(), native_spread_fills_received.size(), synthetic_fills_sent.size());
controller.cpp         SERVER_WLOG("[algo_inst_id=%s]: Not all legs sent! [order_id=%s seq=%llu] total_sent=%zu " "spread_qty=%0.8f " "total_sent_qty_across_legs=%0.8f " "total_expected_qty_across_legs_per_lot=%0.8f " "total_expected_qty_across_legs=%0.8f " "leg_size=%zu " "found_matching_leg=%d ", inst_id.to_string(), order_id, seq, total_sent, spread_qty, cached_native_spread_fill.total_sent_qty_across_legs, cached_native_spread_fill.total_expected_qty_across_legs_per_lot, cached_native_spread_fill.total_expected_qty_across_legs_per_lot*spread_qty, leg_infos.size(), found_matching_leg);
controller.cpp         SERVER_WLOG("[algo_inst_id=%s]: has no algo type. Will not generate synthetic leg fill", inst_id.to_string());
controller.cpp         SERVER_ILOG("[algo_inst_id=%s]: will generate synthetic leg fill", inst_id.to_string());
controller.cpp     SERVER_ILOG("DownloadInstrument: inst_id=%s: Starting synchronous instrument download: " "uri=%s", algo_instance_id, uri.str());
controller.cpp         SERVER_ELOG("DownloadInstrument: inst_id=%s: Instrument download failed: " "exception=%s", algo_instance_id, e.what());
controller.cpp     SERVER_ILOG("DownloadInstrument: inst_id=%s: Instrument download succeeded: " "response=%s", algo_instance_id, response);
controller.cpp             SERVER_ELOG("ParseInstrument: inst_id=%s: [result][status] missing!", algo_instance_id);
controller.cpp             SERVER_ELOG("ParseInstrument: inst_id=%s: [result][status][stat] missing!", algo_instance_id);
controller.cpp             SERVER_ELOG("ParseInstrument: inst_id=%s: [result][status][stat]=%s!", algo_instance_id, stat);
controller.cpp             SERVER_ELOG("ParseInstrument: inst_id=%s: [instrument] missing!", algo_instance_id);
controller.cpp             SERVER_ILOG("ParseInstrument: inst_id=%s: SYNTHETIC instrument parse succeeded: " "marketId=%llu " "productId=(not available) " "productTypeId=(not available) " "productFamilyId=(not available)", algo_instance_id, marketId);
controller.cpp         SERVER_ILOG("ParseInstrument: inst_id=%s: Instrument parse succeeded: " "marketId=%llu " "productId=%llu " "productTypeId=%llu " "productFamilyId=%llu " "firstLegInstrumentId=%llu (0 means absent)", algo_instance_id, marketId, productId, productTypeId, productFamilyId, firstLegInstrumentId);
controller.cpp         SERVER_ELOG("ParseInstrument: inst_id=%s: Exception=[%s] thrown during parse!", algo_instance_id, e.what());
controller.cpp     SERVER_ILOG("DownloadProduct: inst_id=%s: Starting synchronous product download: " "uri=%s", algo_instance_id, uri.str());
controller.cpp         SERVER_ELOG("DownloadProduct: inst_id=%s: Product download failed: " "exception=%s", algo_instance_id, e.what());
controller.cpp     SERVER_ILOG("DownloadProduct: inst_id=%s: Product download succeeded: " "response=%s", algo_instance_id, response);
controller.cpp             SERVER_ELOG("ParseProduct: inst_id=%s: [result][status] missing!", algo_instance_id);
controller.cpp             SERVER_ELOG("ParseProduct: inst_id=%s: [result][status][stat] missing!", algo_instance_id);
controller.cpp             SERVER_ELOG("ParseProduct: inst_id=%s: [result][status][stat]=%s!", algo_instance_id, stat);
controller.cpp             SERVER_ELOG("ParseProduct: inst_id=%s: [product] missing!", algo_instance_id);
controller.cpp         SERVER_ILOG("ParseProduct: inst_id=%s: Product parse succeeded: " "productTypeId=%llu " "productFamilyId=%llu", algo_instance_id, productTypeId, productFamilyId);
controller.cpp         SERVER_ELOG("ParseProduct: inst_id=%s: Exception=[%s] thrown during parse!", algo_instance_id, e.what());
controller.cpp     SERVER_ILOG("RequestDownloadRiskLimits: Server Main Thread is requesting async downlonad onto TTUS Worker Thread: " "inst_id=%s " "user_request_id=%llu", algo_instance_id, user_request_id);
controller.cpp     SERVER_ILOG("GetOrCreateRiskLimitsCache: " "user_id=%llu " "account_id=%llu " "instr_id=%llu", user_id, account_id, instr_id);
controller.cpp         SERVER_ILOG("GetOrCreateRiskLimitsCache: New Risk Limit cache created. " "user_id=%llu " "account_id=%llu " "instr_id=%llu", user_id, account_id, instr_id);
controller.cpp         SERVER_WLOG("UpdateAlgoParamsUsingOrderTags: Failed to find algo_data " "but this algo instance will proceed without Order Tags: " "algo_inst_id=%s", algo_inst_id.to_string());
controller.cpp         SERVER_ILOG("UpdateAlgoParamsUsingOrderTags: " "algo_inst_id=%s " "account=%s", algo_inst_id.to_string(), std::string(account));
controller.cpp         SERVER_ILOG("UpdateAlgoParamsUsingOrderTags: " "algo_inst_id=%s " "account_override=%s", algo_inst_id.to_string(), std::string(account_override));
controller.cpp         SERVER_WLOG("UpdateRequestParamsUsingOrderTags: inst_id was null " "but this algo instance will proceed without Order Tags: " "user_request_id=%llu", request_data->request.user_request_id);
controller.cpp         SERVER_WLOG("UpdateRequestParamsUsingOrderTags: Failed to encode class_1_2_fields " "but this algo instance will proceed without Order Tags: " "algo_inst_id=%s " "user_request_id=%llu", algo_inst_id.to_string(), request_data->request.user_request_id);
controller.cpp         SERVER_WLOG("UpdateRequestParamsUsingOrderTags: Failed to find algo_data " "but this algo instance will proceed without Order Tags: " "algo_inst_id=%s " "user_request_id=%llu", algo_inst_id.to_string(), request_data->request.user_request_id);
controller.cpp         SERVER_ILOG("UpdateRequestParamsUsingOrderTags: " "algo_inst_id=%s " "user_request_id=%llu " "account=%s", algo_inst_id.to_string(), request_data->request.user_request_id, std::string(account));
controller.cpp         SERVER_ILOG("UpdateRequestParamsUsingOrderTags: " "algo_inst_id=%s " "user_request_id=%llu " "account_override=%s", algo_inst_id.to_string(), request_data->request.user_request_id, std::string(account_override));
controller.cpp     SERVER_ILOG("ProcessOrderTagDownload: Order Tags downloaded and notified on Server Main Thread: " "algo_inst_id=%s " "download_result=%s", algo_inst_id.to_string(), order_tag_download.download_result ? std::string("true") : std::string("false"));
controller.cpp         SERVER_ILOG("ProcessOrderTagDownload: Download info was unexpectedly missing but this error is not fatal - " "the algo instance will still start without Order Tags: " "algo_inst_id=%s", algo_inst_id.to_string());
controller.cpp         SERVER_WLOG("ProcessOrderTagDownload: Order Tags download failed but this error is not fatal - " "the algo instance will still start without Order Tags: " "algo_inst_id=%s", algo_inst_id.to_string());
controller.cpp     SERVER_ILOG("ProcessRiskLimitsDownload: Risk Limits received on Server Main Thread: " "user_id=%llu " "account_id=%llu " "instr_id=%llu", risk_limits_download.user_id, risk_limits_download.account_id, risk_limits_download.instr_id);
controller.cpp         SERVER_ELOG("ProcessRiskLimitsDownload: Cache was unexpectedly absent at this point! " "New cache was created nonetheless and we will proceed to populate it with the downloaded limits: " "user_id=%llu " "account_id=%llu " "instr_id=%llu", risk_limits_download.user_id, risk_limits_download.account_id, risk_limits_download.instr_id);
controller.cpp     SERVER_ILOG("dest_cb=%zu id=%lu account_count=%lu", dest_cb, algojob_request->id, algojob_request->data.user_update.account_count);
controller.cpp         SERVER_ELOG("restore_algojob_request error. cb=%zu cb1=%zu", cb, cb1);
controller.cpp             SERVER_ELOG("compare_algojob__requests error. cb=%zu cb1=%zu cb2=%zu", cb, cb1, cb2);
controller.cpp     SERVER_ILOG("%s", ss.str());
main.cpp                 SERVER_ILOG("Waiting for thread shutdown." " name=%s", m_name);
main.cpp     SERVER_ILOG("Parsing TTUS connection_ids=[%s]", connection_ids);
main.cpp         SERVER_ILOG("Added connection_id=%s", connection_id);
main.cpp     SERVER_ILOG("Parsing TTUS account_ids=[%s]", account_ids);
main.cpp         SERVER_ILOG("Added connection_id=%s", account_id);
main.cpp     SERVER_ILOG("Parsing TTUS company_ids=[%s]", company_ids);
main.cpp         SERVER_ILOG("Added company_id=%s", company_id);
main.cpp         SERVER_ELOG("Read AlgoServer config failed");
main.cpp         SERVER_ELOG("failed to get SelfBinaryName");
main.cpp         SERVER_ELOG("failed to make path. path=%s", std::string(algoserver__variable_state_path));
main.cpp     SERVER_ILOG("Initializing AlgoServer. build_date=" BUILD_DATE " build_commit=" BUILD_COMMIT);
main.cpp     SERVER_ILOG("ConfigXml: client_id =%s", client_id);
main.cpp     SERVER_ILOG("ConfigXml: client_secret =%s", Elide(client_secret, 4));
main.cpp     SERVER_ILOG("ConfigXml: ttid_url =%s", ttid_url);
main.cpp     SERVER_ILOG("ConfigXml: admin_url =%s", admin_url);
main.cpp     SERVER_ILOG("ConfigXml: risk_url =%s", risk_url);
main.cpp     SERVER_ILOG("ConfigXml: risk_ws_url =%s", risk_ws_url);
main.cpp     SERVER_ILOG("ConfigXml: ssl_ca_path =%s", ssl_ca_path);
main.cpp     SERVER_ILOG("ConfigXml: ttus_config_xml =%s", ttus_config_xml);
main.cpp     SERVER_ILOG("ConfigXml: jobCount =%d", jobCount);
main.cpp         SERVER_ILOG("Detected ASAN_OPTIONS=%s", std::string(asan_options));
main.cpp         SERVER_ELOG("Note: ASAN_OPTIONS are not defined when running instrumented build");
main.cpp         SERVER_ELOG("Failed to init env. error=%s", std::string(err.what()));
main.cpp     SERVER_WLOG(oss.str());
main.cpp             SERVER_ELOG("Init HSM Proxy connection failed [%u]", algoserver_error);
main.cpp             SERVER_ELOG("Invalid zookeeper config");
main.cpp         SERVER_ELOG("Init comm failed: %s", ALGOSERVER_ERROR_STR[algoserver_error]);
main.cpp         SERVER_ILOG("Created Risk Sender for Child order: market=%u account=%llu", risk_sender.market_id, risk_sender.account_id);
main.cpp             SERVER_WLOG(oss.str());
main.cpp          SERVER_ELOG("Failed to init PDS. url=%s", pds_url);
main.cpp         SERVER_ELOG("Init retrieve SecurityExchanges from PDS failed");
main.cpp         SERVER_ELOG("Algojob Load Balancer initialization failed");
main.cpp                 SERVER_ELOG("Developer feature [enable_expedited_ttus_download] is enabled on a chef-deployed machine!");
main.cpp                 SERVER_ELOG("Developer feature [enable_expedited_ttus_download] is enabled outside of internal environment!");
main.cpp             SERVER_ILOG("Developer feature [enable_expedited_ttus_download] enabled: Downloading specific TTUS objects!");
main.cpp                 SERVER_ELOG("TTUS_Web Connections download failed");
main.cpp                 SERVER_ELOG("TTUS_Web Accounts download failed");
main.cpp                 SERVER_ELOG("TTUS_Web Companies download failed");
main.cpp                 SERVER_ELOG("TTUS_Web Connections download failed");
main.cpp                 SERVER_ELOG("TTUS_Web Accounts download failed");
main.cpp                 SERVER_ELOG("TTUS_Web Companies download failed");
main.cpp         SERVER_ILOG("Testing for PDS maintenance. url=%s", pds_url);
main.cpp                 SERVER_WLOG("Not all PDS query succeed");
main.cpp                 SERVER_ILOG("PDS query batch %d succeed", ++succeed_batches);
main.cpp             SERVER_ELOG("PDS in maintenance. url=%s", pds_url);
main.cpp             SERVER_ELOG("Ledger download failed");
main.cpp         SERVER_ILOG("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
main.cpp         SERVER_ILOG("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Startup complete!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
main.cpp         SERVER_ILOG("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
main.cpp             SERVER_ELOG("AlgoServer_ControllerMain failed error=%s", ALGOSERVER_ERROR_STR[algoserver_error] );
main.cpp     SERVER_ILOG("Shutting down. main_flags=%s", std::bitset<num_bits_needed>(main_flags).to_string());
main.cpp         SERVER_ILOG("ConfigXml: datacenter_name=%s", datacenter_name);
main.cpp         SERVER_ILOG("ConfigXml: instance_name=%s", instance_name);
main.cpp         SERVER_ILOG("ConfigXml: minLogLevel=%d", static_cast<int>(minLogLevel));
main.cpp         SERVER_ILOG("ConfigXml: algoserver__is_remote_env=%s", algoserver__is_remote_env?"true":"false");
main.cpp         SERVER_ILOG("ConfigXml: " MAX_SSE_ALGOS_PER_USER "=%d", algoserver__max_sse_algos_per_user);
main.cpp         SERVER_ILOG("ConfigXml: " MAX_ADL_ALGOS_PER_USER "=%d", algoserver__max_adl_algos_per_user);
main.cpp         SERVER_ILOG("ConfigXml: " INCLUDE_ALL_ALGO_STATUSES "=%d", algoserver__include_all_algo_statuses);
main.cpp         SERVER_ELOG("Read AlgoServer config failed: %s", std::string(e.what()));
main.cpp         SERVER_ELOG( "Problem opening file=%s to write server_instance_id=%s", std::string(file_path), std::string(uuid_str) );
main.cpp         SERVER_ELOG( "Problem writing server_instance_id=%s to file=%s, ferror=%d", std::string(uuid_str), std::string(file_path), ferr );
main.cpp         SERVER_ILOG( "Using persisted algoserver__inst_id_string=%s, algoserver__instance_identifier_name=%s", std::string(algoserver__inst_id_string), algoserver__instance_identifier_name );
main.cpp     SERVER_WLOG( "main: Generating new algoserver__inst_id_string=%s, algoserver__instance_identifier_name=%s", std::string(algoserver__inst_id_string), algoserver__instance_identifier_name );
comm_lbm.cpp     SERVER_ILOG( "lbm: UME store %d: %s %s success. RegID %d, Flags %x %sOLD[SQN %d] %sNOACKS Source %s", ume_registration_ex->store_index, std::string(ume_registration_ex->store), function_string, ume_registration_ex->registration_id, ume_registration_ex->flags, ume_registration_ex->flags & LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD ? "+" : "-", ume_registration_ex->sequence_number, ume_registration_ex->flags & LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_NOACKS ? "+" : "-", std::string(topic_name) );
comm_lbm.cpp         SERVER_ILOG("lbm: Source %s connected to %s", std::string(topic_name), std::string(static_cast<char*>(data)));
comm_lbm.cpp         SERVER_ILOG("lbm: Source %s disconnected from %s", std::string(topic_name), std::string(static_cast<char*>(data)));
comm_lbm.cpp         SERVER_ILOG("lbm: Error registering source with UME store: %s", std::string(static_cast<char*>(data)));
comm_lbm.cpp         SERVER_ILOG("lbm: UME store registration success. RegID %u Source %s", ume_registration->registration_id, std::string(topic_name));
comm_lbm.cpp         SERVER_ILOG("lbm: UME DEREGISTRATION IS COMPLETE_EX Source %s", std::string(topic_name));
comm_lbm.cpp         SERVER_ILOG("lbm: UME registration complete. SQN %d. Flags %x %sQUORUM Source %s", ume_registration_complete->sequence_number, ume_registration_complete->flags, ume_registration_complete->flags & LBM_SRC_EVENT_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM ? "+" : "-", std::string(topic_name));
comm_lbm.cpp             SERVER_WLOG("lbm: UME store %d: %s message NOT stable!! SQN %d (cd %s). Flags %x %sLOSS %sTIMEOUT Source %s", ume_ack_ex_info->store_index, std::string(ume_ack_ex_info->store), ume_ack_ex_info->sequence_number, msg_clientd, ume_ack_ex_info->flags, ume_ack_ex_info->flags & LBM_SRC_EVENT_UME_MESSAGE_NOT_STABLE_FLAG_LOSS ? "+" : "-", ume_ack_ex_info->flags & LBM_SRC_EVENT_UME_MESSAGE_NOT_STABLE_FLAG_TIMEOUT ? "+" : "-", std::string(topic_name));
comm_lbm.cpp             SERVER_WLOG("lbm: UME message NOT stable!! SQN %d (cd %s). Flags %x %sLOSS %sTIMEOUT Source %s", ume_ack_ex_info->sequence_number, msg_clientd, ume_ack_ex_info->flags, ume_ack_ex_info->flags & LBM_SRC_EVENT_UME_MESSAGE_NOT_STABLE_FLAG_LOSS ? "+" : "-", ume_ack_ex_info->flags & LBM_SRC_EVENT_UME_MESSAGE_NOT_STABLE_FLAG_TIMEOUT ? "+" : "-", std::string(topic_name));
comm_lbm.cpp         SERVER_ILOG("lbm: UME message reclaimed (ex) - sequence number %d (cd %s). Flags %x Source %s", ume_ack_ex_info->sequence_number, msg_clientd, ume_ack_ex_info->flags, std::string(topic_name));
comm_lbm.cpp         SERVER_ELOG("lbm: UME store: %s Source %s", std::string(static_cast<char*>(data)), std::string(topic_name));
comm_lbm.cpp         SERVER_ILOG("lbm: Flight Size Notification. Type: %s. Inflight is %s specified flight size Source %s", flight_size_notification_type, flight_size_notification_state, std::string(topic_name));
comm_lbm.cpp     SERVER_ILOG("using the following string %s to generate session id: 0x%016llX", std::string(topic_name), session_id);
comm_lbm.cpp         SERVER_ELOG("lbm: Failed to set ume_session_id, topic: %s error=%s", std::string(topic_name), std::string(ex.what()));
comm_lbm.cpp         SERVER_ELOG("Failed to create Source, topic: %s error=%s", std::string(topic_name), std::string(ex.what()));
comm_lbm.cpp             SERVER_WLOG("Timed out after waiting %d sec for UME_REGISTRATION_COMPLETE. Will rely on LBM_TRANSACTION_LOGGER to switch to LBM", (int)(UMP_REGISTRATION_TIMEOUT_NS / NANOSECONDS_PER_SECOND));
comm_lbm.cpp             SERVER_ELOG("Timed out after waiting %d sec for UME_REGISTRATION_COMPLETE", (int)(UMP_REGISTRATION_TIMEOUT_NS / NANOSECONDS_PER_SECOND));
comm_lbm.cpp         SERVER_ELOG( "LOST. topic=%s source=%s seq_num=%x", std::string(msg.TopicName()), std::string(msg.Source()), msg.SequenceNumber() );
comm_lbm.cpp         SERVER_ELOG( "LOST BURST. topic=%s source=%s seq_num=%x", std::string(msg.TopicName()), std::string(msg.Source()), msg.SequenceNumber() );
comm_lbm.cpp         SERVER_DLOG("Beginning of transport session. Topic=%s lbm_source=%s", std::string(msg.TopicName()), std::string(msg.Source()));
comm_lbm.cpp         SERVER_DLOG("End of transport session. Topic=%s lbm_source=%s", std::string(msg.TopicName()), std::string(msg.Source()));
comm_lbm.cpp         SERVER_ELOG( "No sources found for topic=%s.", std::string(msg.TopicName()) );
comm_lbm.cpp         SERVER_ELOG( "UME registration error: ", std::string(msg.TopicName()), std::string(msg.Source()), std::string(msg.Data()) );
comm_lbm.cpp         SERVER_ILOG( "UME registration successful. topic=%s source=%s SrcRegID %u RcvRegID %u.", std::string(msg.TopicName()), std::string(msg.Source()), reg->src_registration_id, reg->rcv_registration_id );
comm_lbm.cpp         SERVER_ILOG( "UME registration successful. topic=%s source=%s store %u: %s " "SrcRegID %u RcvRegID %u Flags %x. %s %sNOCACHE %sRPP %s", std::string(msg.TopicName()), std::string(msg.Source()), reg->store_index, std::string(reg->store), reg->src_registration_id, reg->rcv_registration_id, reg->flags, std::string(sqn), reg->flags & LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE ? "+" : "-", reg->flags & LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_RPP ? "+" : "-", std::string(sid) );
comm_lbm.cpp         SERVER_ILOG( "UME registration complete. " "topic=%s source=%s SQN %x Flags %x. " "%sQUORUM " "%sRXREQMAX " "%s", std::string(msg.TopicName()), std::string(msg.Source()), reg->sequence_number, reg->flags, reg->flags & LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM ? "+" : "-", reg->flags & LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_RXREQMAX ? "+" : "-", std::string(sid) );
comm_lbm.cpp         SERVER_ILOG( "UME deregistration successful. " "topic=%s source=%s store %u: %s " "SrcRegID %u RcvRegID %u Flags %x. " "%s" "%sNOCACHE " "%sRPP", std::string(msg.TopicName()), std::string(msg.Source()), dereg->store_index, std::string(dereg->store), dereg->src_registration_id, dereg->rcv_registration_id, dereg->flags, std::string(sqn), dereg->flags & LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE ? "+" : "-", dereg->flags & LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_RPP ? "+" : "-" );
comm_lbm.cpp         SERVER_ILOG( "UME deregistration complete. topic=%s source=%s", std::string(msg.TopicName()), std::string(msg.Source()) );
comm_lbm.cpp         SERVER_ILOG( "UME registration change. topic=%s source=%s data=%s", std::string(msg.TopicName()), std::string(msg.Source()), std::string(msg.Data()) );
comm_lbm.cpp     SERVER_ILOG("lbm_version %s", std::string(v));
comm_lbm.cpp             SERVER_ELOG("Clean up: side_channel_recver;");
comm_lbm.cpp             SERVER_ELOG("Clean up: side_channel_sender;");
comm_lbm.cpp             SERVER_ELOG("Clean up: recver;");
comm_lbm.cpp             SERVER_ELOG("Clean up: edge_recver;");
comm_lbm.cpp             SERVER_ELOG("Clean up: oc_recver;");
comm_lbm.cpp             SERVER_ELOG("Clean up: bookie_sender;");
comm_lbm.cpp             SERVER_ELOG("Clean up: s_algo_sender");
comm_lbm.cpp             SERVER_ELOG("Clean up: user_group_sender;");
comm_lbm.cpp         SERVER_ELOG("Clean up: lbm_lbm_transaction_logger;");
comm_lbm.cpp             SERVER_ELOG("Clean up: lbm_context;");
comm_lbm.cpp     SERVER_ILOG("Creating LBM Context config_file=%s app_name=%s", std::string(config_file), std::string(app_name));
comm_lbm.cpp     SERVER_ILOG("Creating receiver topic=%s", std::string(topic_name));
comm_lbm.cpp     SERVER_ILOG("Creating side channel receiver topic=%s", std::string(topic_name));
comm_lbm.cpp     SERVER_ILOG("Creating side channel sender topic=%s", std::string(topic_name));
comm_lbm.cpp     SERVER_ILOG("Creating receiver EdgeServer topic=%s", std::string(topic_name));
comm_lbm.cpp     SERVER_ILOG("Creating sender Bookie topic=%s", std::string(bookie_topic_name));
comm_lbm.cpp         SERVER_ILOG("ConfigXml: use_lbm_transaction_logger=%d", s_use_lbm_transaction_logger);
comm_lbm.cpp             SERVER_ILOG("Creating LBM Transaction Logger dir_path=%s ump_flight_size=%d", dir_path, ump_flight_size);
comm_lbm.cpp         SERVER_ILOG("ConfigXml: ump_ensemble=%s", ump_ensemble);
comm_lbm.cpp             SERVER_ILOG("Creating UMP sender topic=%s", std::string(algo_sender_topic_name), ump_ensemble);
comm_lbm.cpp                 SERVER_ELOG("Failed to create sender topic=%s", std::string(algo_sender_topic_name));
comm_lbm.cpp                 SERVER_WLOG("ConfigXml: inconsistent config. s_use_ump=false but use_lbm_transaction_logger=true. Setting use_lbm_transaction_logger=false");
comm_lbm.cpp             SERVER_ILOG("Creating LBM sender topic=%s", std::string(algo_sender_topic_name));
comm_lbm.cpp                 SERVER_ELOG("Failed to create sender topic=%s error=%s", std::string(algo_sender_topic_name), std::string(ex.what()));
comm_lbm.cpp     SERVER_ILOG("Creating receiver OC topic=%s", std::string(topic_name));
comm_lbm.cpp     SERVER_ILOG("Creating source for User Group topic=%s", USER_GROUP_TOPIC_STRING);
comm_lbm.cpp         SERVER_ILOG("Creating Triage Action Topic=%s", std::string(triage_action_topic_name));
comm_lbm.cpp         SERVER_ILOG("Creating Triage Action Topic=%s", std::string(triage_action_topic_name));
comm_lbm.cpp         SERVER_ILOG("Creating Triage Action Topic=%s", std::string(triage_action_topic_name));
comm_lbm.cpp         SERVER_ILOG("Creating Triage Action Topic=%s", std::string(triage_action_topic_name));
comm_lbm.cpp     SERVER_ILOG("AlgoServer_ShutdownComm Started");
comm_lbm.cpp     SERVER_ILOG("AlgoServer_ShutdownComm Ended");
comm_lbm.cpp         SERVER_ELOG("Error no algo channel sender for account_id=%llu", connection_id);
comm_lbm.cpp             SERVER_WLOG("AlgoServer_SendAlertExecutionReport: lbm_error=%s use_lbm_transaction_logger=%d", std::string(ex.what()), s_use_lbm_transaction_logger);
comm_lbm.cpp         SERVER_ELOG("%s: Cannot create algo sidechannel sender for account_id=%llu", logInfo, account_id);
comm_lbm.cpp             SERVER_WLOG("%s: lbm_error=%s without channel=%llu", logInfo, std::string(ex.what()), account_id);
comm_lbm.cpp             SERVER_WLOG("%s: lbm_error=%s channel=%d", logInfo, std::string(ex.what()), account_id);
comm_lbm.cpp         SERVER_WLOG( "AlgoServer_SendAlert: Encode failed: %s", ALGOSERVER_ERROR_STR[algoserver_error] );
comm_lbm.cpp         SERVER_WLOG("SendExportValue: Encode failed: %s account_id=%llu", ALGOSERVER_ERROR_STR[algoserver_error], connection_id);
comm_lbm.cpp         SERVER_ELOG( "Encode failed for response=%s. algoserver_error=%s", ALGO_RESPONSE_ID_STR[response->id], ALGOSERVER_ERROR_STR[algoserver_error] );
comm_lbm.cpp             SERVER_ELOG("Error no algo channel sender for account_id=%llu", response->connection_id);
comm_lbm.cpp             SERVER_ELOG("Skip lbm send, encoded_size=0");
comm_lbm.cpp                 SERVER_WLOG("Error sending response: : lbm_error=%s use_lbm_transaction_logger", std::string(ex.what()), s_use_lbm_transaction_logger);
comm_lbm.cpp         SERVER_WLOG("Error sending request, lbm_error=%s", std::string(ex.what()));
comm_lbm.cpp     SERVER_ILOG("TransferAlgo: sending book download request for algoserver_id=%s", algoserver_id);
comm_lbm.cpp     SERVER_ILOG("TransferAlgo response received on LBM thread");
comm_lbm.cpp         SERVER_ILOG("Duplicate, book download response received, ignoring");
comm_lbm.cpp         SERVER_ILOG("Book download response received");
comm_lbm.cpp     SERVER_ILOG("Sending book download request");
comm_lbm.cpp     SERVER_ILOG("DownloadOrderTagCallback: OTD ER received on LBM Thread!");
comm_lbm.cpp         SERVER_ILOG("DownloadOrderTagCallback: Forwarded Order Tags to Server Main Thread: " "algo_inst_id=%s", algo_inst_ttuuid.to_string());
comm_lbm.cpp         SERVER_WLOG("AlgoServer_SendOrderTagNewOrderSingle: Error sending OTD NOS: algo_inst_id is missing but OTD error is not fatal: " "algo_inst_id=MISSING");
comm_lbm.cpp         SERVER_WLOG("AlgoServer_SendOrderTagNewOrderSingle: Error sending OTD NOS: Unable to find primary_market_id but OTD error is not fatal: " "algo_inst_id=%s", algo_inst_id.to_string());
comm_lbm.cpp         SERVER_WLOG("AlgoServer_SendOrderTagNewOrderSingle: Error sending OTD NOS: Unable to find sender but OTD error is not fatal: " "algo_inst_id=%s", algo_inst_id.to_string());
comm_lbm.cpp     SERVER_ILOG("AlgoServer_SendOrderTagNewOrderSingle: Sending OTD NOS: " "topic=OC.ORDERTAG.%u " "algo_inst_id=%s", market_id, algo_inst_id.to_string());
comm_lbm.cpp         SERVER_WLOG("AlgoServer_SendOrderTagNewOrderSingle: Error sending OTD NOS: LBM send failed but OTD error is not fatal: " "algo_inst_id=%s " "lbm_exception=%s", algo_inst_id.to_string(), std::string(ex.what()));
comm_lbm.cpp         SERVER_WLOG("AlgoServer_SendOrderTagNewOrderSingle: Error sending OTD NOS: LBM Request Ptr is null but OTD error is not fatal: " "algo_inst_id=%s", algo_inst_id.to_string());
comm_lbm.cpp     SERVER_ILOG("AlgoServer_SendOrderTagNewOrderSingle: Sent OTD NOS: " "algo_inst_id=%s", algo_inst_id.to_string());
comm_lbm.cpp     SERVER_ILOG("AlgoServer_EmplaceOrderTagRequestPtr: Emplaced ptr: " "algo_inst_id=%s " "s_ordertag_requests.size()=%d", algo_inst_id.to_string(), s_ordertag_requests.size());
comm_lbm.cpp     SERVER_ILOG("AlgoServer_EraseOrderTagRequestPtr: Erased ptr: " "algo_inst_id=%s " "s_ordertag_requests.size()=%d", algo_inst_id.to_string(), s_ordertag_requests.size());
comm_lbm.cpp         SERVER_ELOG("Error sending child cancel: Unable to find sender." " order_id=%s", order_id.to_string());
comm_lbm.cpp     SERVER_ILOG("Sending child cancel on market_id=%u account_id=%llu", market_id, params.account);
comm_lbm.cpp         SERVER_ELOG("Error sending child cancel: LBM send failed." " order_id=%s error=%s", order_id.to_string(), std::string(ex.what()));
comm_lbm.cpp             SERVER_ELOG("Error creating algo sender. account_id=%llu error=%s %s use_lbm_transaction_logger=%d", account_id, ALGOUTIL_ERROR_STR[algoutil__error_create_lbm_channel_source], std::string(ex.what()), s_use_lbm_transaction_logger);
comm_lbm.cpp         SERVER_ILOG("Created algo channel sender. account_id=%llu use_lbm_transaction_logger=%d", account_id, s_use_lbm_transaction_logger);
comm_lbm.cpp             SERVER_ELOG("Error creating algo sender. account_id=%llu error=%s %s useTransactionLogger=%d", account_id, ALGOUTIL_ERROR_STR[algoutil__error_create_lbm_channel_source], std::string(ex.what()), s_use_lbm_transaction_logger);
comm_lbm.cpp         SERVER_ILOG("Created algo channel sender. account_id=%llu useTransactionLogger=%d", account_id, s_use_lbm_transaction_logger);
comm_lbm.cpp             SERVER_ELOG("Failed to create Risk topic=%s. error=%s", std::string(topic_name), std::string(ex.what()));
comm_lbm.cpp         SERVER_ELOG("Error creating child sender." " market_id=%u" " account_id=%llu" " error=%s", mkt_id, account_id, std::string(ex.what()));
comm_lbm.cpp     SERVER_ILOG("Created child cancel channel sender. account_id=%llu market=%u", account_id, mkt_id);
comm_lbm.cpp         SERVER_WLOG("Error sending response: Lbm send failed. lbm_error=%s", std::string(ex.what()));
comm_lbm.cpp     SERVER_ILOG("Creating sender OC Ordertag topic=%s", std::string(oc_ordertag_sender_topic_name));
comm_lbm.cpp         SERVER_ELOG("No Channel sender for user_group_id=%llu", user_group_id);
comm_lbm.cpp         SERVER_ILOG("Send to %s topic with channel sender for user_group_id=%llu", USER_GROUP_TOPIC_STRING, user_group_id);
comm_lbm.cpp         SERVER_ELOG("Failed to send through channel sender for user_group_id=%llu", user_group_id);
comm_lbm.cpp         SERVER_ELOG("Cannot change the LbmSenderMode because use_lbm_transaction_logger=%d", s_use_lbm_transaction_logger);
comm_lbm.cpp     SERVER_ILOG("SetLbmSenderMode to %s", useUMP ?"UMP":"LBM");
comm_lbm.cpp     SERVER_ILOG("SetLbmSenderMode to %s %s", useUMP ? "UMP" : "LBM", newState);
order_passing_manager.cpp         SERVER_ELOG("[algo=%s] OrderPass::%s. Failed: %s", algo->inst_id.to_string(), request, error);
order_passing_manager.cpp         SERVER_ELOG("[algo=%s] OrderPass::%s. Failed: %s", algo->inst_id.to_string(), request, error);
order_passing_manager.cpp         SERVER_ELOG("[algo=%s] OrderPass::%s. Failed: %s", algo->inst_id.to_string(), request, error);
order_passing_manager.cpp         SERVER_ELOG("[algo=%s] OrderPass::%s. Failed: %s", algo->inst_id.to_string(), request, error);
order_passing_manager.cpp         SERVER_ELOG("[algo=%s] OrderPass::%s. Failed: %s", algo->inst_id.to_string(), request, error);
order_passing_manager.cpp         SERVER_ELOG("[algo=%s] OrderPass::%s. Failed: %s", algo->inst_id.to_string(), request, error);
order_passing_manager.cpp         SERVER_ELOG("[algo=%s] OrderPass::Init: Failed: %s", algo->inst_id.to_string(), error);
order_passing_manager.cpp         SERVER_ILOG("[algo=%s] OrderPass::Init: Setting original_group_id=%llu", algo->inst_id.to_string(), order_pass.group_ids.current_group_id);
order_passing_manager.cpp         SERVER_ELOG("[algo=%s] OrderPass::Init: Failed: %s before_transition_current_group_id=%ull after_transition_current_group_id=%ull", algo->inst_id.to_string(), error, before_transition_group_ids.current_group_id, order_pass.group_ids.current_group_id);
order_passing_manager.cpp     SERVER_ILOG("[algo=%s] OrderPass::Init: Attempting transition: " "BEFORE: [state=%s %s current_user_id=%llu] " "ORDER: [%s] " "AFTER: [state=%s %s current_user_id=%llu]", algo->inst_id.to_string(), OrderPassToString(before_transition_state), GroupIDsToString(before_transition_group_ids), before_transition_current_user_id, GroupIDsToString(order_pass.group_ids), OrderPassToString(order_pass_init), GroupIDsToString(after_transition_group_ids), order_pass.current_user_id);
order_passing_manager.cpp         SERVER_ELOG("[algo=%s] OrderPass::Accept: Failed: %s", algo->inst_id.to_string(), error);
order_passing_manager.cpp     SERVER_ILOG("[algo=%s] OrderPass::Accept: Attempting transition: " "BEFORE: [state=%s %s current_user_id=%llu] " "ORDER: [%s] " "AFTER: [state=%s %s current_user_id=%llu]", algo->inst_id.to_string(), OrderPassToString(before_transition_state), GroupIDsToString(before_transition_group_ids), before_transition_current_user_id, GroupIDsToString(order_pass.group_ids), OrderPassToString(order_pass_accept), GroupIDsToString(after_transition_group_ids), order_pass.current_user_id);
order_passing_manager.cpp         SERVER_ELOG("[algo=%s] OrderPass::Reject: Failed: %s", algo->inst_id.to_string(), error);
order_passing_manager.cpp     SERVER_ILOG("[algo=%s] OrderPass::Reject: Attempting transition: " "BEFORE: [state=%s %s current_user_id=%llu] " "ORDER: [%s] " "AFTER: [state=%s %s current_user_id=%llu]", algo->inst_id.to_string(), OrderPassToString(before_transition_state), GroupIDsToString(before_transition_group_ids), before_transition_current_user_id, GroupIDsToString(order_pass.group_ids), OrderPassToString(order_pass_reject), GroupIDsToString(after_transition_group_ids), order_pass.current_user_id);
order_passing_manager.cpp         SERVER_ELOG("[algo=%s] OrderPass::Undo: Failed: %s", algo->inst_id.to_string(), error);
order_passing_manager.cpp     SERVER_ILOG("[algo=%s] OrderPass::Undo: Attempting transition: " "BEFORE: [state=%s %s current_user_id=%llu] " "ORDER: [%s] " "AFTER: [state=%s %s current_user_id=%llu]", algo->inst_id.to_string(), OrderPassToString(before_transition_state), GroupIDsToString(before_transition_group_ids), before_transition_current_user_id, GroupIDsToString(order_pass.group_ids), OrderPassToString(order_pass_undo), GroupIDsToString(after_transition_group_ids), order_pass.current_user_id);
order_passing_manager.cpp     SERVER_ILOG("[algo=%s] OrderPass::SetChild: Successfully prepared request: " "state=set_child " "current_user_id=%llu " "%s ", algo->inst_id.to_string(), order_pass.current_user_id, GroupIDsToString(order_pass.group_ids));
order_passing_manager.cpp         SERVER_ELOG("[algo=%s] OrderPass::Handle: Can not handle request=%s. Unrecognized OBP state", algo->inst_id.to_string(), OrderPassToString(order_pass.state));
auth.cpp         SERVER_ILOG("Problem reading HSM config file.");
auth.cpp         SERVER_ELOG("Invalid environment");
auth.cpp             SERVER_WLOG("token_signer missing config" " name=%s" " error=%s", name, ALGOUTIL_ERROR_STR[error]);
auth.cpp             SERVER_ILOG("Bypassing HSM Proxy (no connection to HSM Proxy is needed) - " "will use internal private keys to renew tokens locally on algoserver.");
auth.cpp             SERVER_WLOG("token_signer missing config" " name=%s" " error=%s", name, ALGOUTIL_ERROR_STR[error]);
auth.cpp             SERVER_WLOG("token_signer missing config" " name=%s" " error=%s", name, ALGOUTIL_ERROR_STR[error]);
auth.cpp             SERVER_WLOG("token_signer missing config" " name=%s" " error=%s", name, ALGOUTIL_ERROR_STR[error]);
auth.cpp             SERVER_WLOG("token_signer missing config" " name=%s" " error=%s", name, ALGOUTIL_ERROR_STR[error]);
auth.cpp             SERVER_WLOG("token_signer missing config" " name=%s" " error=%s", name, ALGOUTIL_ERROR_STR[error]);
auth.cpp             SERVER_WLOG("token_signer missing config" " name=%s" " error=%s", name, ALGOUTIL_ERROR_STR[error]);
auth.cpp         SERVER_ELOG( "Poll timed out or encountered an error while awaiting response from HSM proxy. error=%s", strerror(errno) );
auth.cpp         SERVER_ELOG( "Problem receiving JSON response from HSM proxy. error=%s", ALGOUTIL_ERROR_STR[error] );
auth.cpp             SERVER_ELOG( "Problem sending JSON request to HSM Proxy. request=%s error=%s", request, ALGOUTIL_ERROR_STR[error] );
auth.cpp                 SERVER_ELOG( "Problem receiving JSON response from HSM Proxy. bad_response=%s error=%s", bad_response, ALGOUTIL_ERROR_STR[error] );
auth.cpp             SERVER_ELOG("HSM Proxy rejected the sign request. error_msg=%s", (response_json["errorMsg"]).as_string());
auth.cpp         SERVER_ILOG("HSM Proxy successfully signed request.");
auth.cpp         SERVER_ELOG("Exception was thrown. exception=%s", std::string(ex.what()));
auth.cpp         SERVER_ELOG( "AlgoServer_DeleteUserTokenOnDisk: Failed to delete user token on disk:" "user_id=%llu " "errno=%s " "token_path=%s ", user_id, std::string(strerror(errno)), std::string(auth_token_file_path) );
auth.cpp         SERVER_ILOG("Sending curl request to AUTH server: %s", std::string(post_buffer));
auth.cpp         SERVER_ILOG("Received curl response from AUTH server: %s ..... %s", std::string(response_data.data.get(), 64), std::string(response_data.data.get() + strlen(response_data.data.get()) - 64, 64));
auth.cpp         SERVER_ILOG("Attempting TIER 1 method (Refresh Token) user_id=%llu", user_id);
auth.cpp             SERVER_ILOG("Successfully renewed via TIER 1. user_id=%llu", user_id);
auth.cpp             SERVER_DLOG("NewTkn=%s", access_token);
auth.cpp         SERVER_ILOG("Attempting TIER 2 method (token-download-request) user_id=%llu", user_id);
auth.cpp             SERVER_ILOG("Successfully renewed via TIER 2. user_id=%llu", user_id);
auth.cpp             SERVER_DLOG("NewTkn=%s", access_token);
auth.cpp         SERVER_ILOG("Attempting TIER 3 method (New Connection). user_id=%llu", user_id);
auth.cpp             SERVER_ILOG("Successfully renewed via TIER 3. user_id=%llu", user_id);
auth.cpp             SERVER_DLOG("NewTkn=%s", access_token);
auth.cpp         SERVER_ELOG("Failed to re-sign token. user_id=%llu old_token=%s", user_id, Elide(access_token, 16));
auth.cpp         SERVER_ELOG("Failed to re-sign token. user_id=%llu error=%s", user_id, std::string(e.what()));
auth.cpp         SERVER_ELOG("Failed to connect to HSM Proxy.");
auth.cpp     SERVER_ILOG("Connected successfully to HSM Proxy.");
auth.cpp         SERVER_ILOG("Destroyed HSM Proxy connection.");
auth.cpp         SERVER_ILOG( "Problem re-signing token. User=%llu, Msg=%s OldTkn=%s", user_id, std::string(ex.what()), access_token );
auth.cpp         SERVER_ILOG( "Unknown problem re-signing token. User=%llu OldTkn=%s", user_id, access_token );
main.cpp         ALGO_ELOG("!! Error !! TTSDKPriceUpdateCallback() Did not find PARENT!!!, user_data=%p, ", user_data);
main.cpp         ALGO_WLOG("SSE received Price error=%s, but no algo found. user_data=%p", std::string(error), user_data);
main.cpp     ALGO_ILOG("[%s] CleanupParent", parent->GetOrderIDString());
main.cpp     ALGO_ILOG("now parentOrders.size()=%d", parentOrders.size());
main.cpp     ALGO_ILOG("OnUnloadSO: Shutting down logging");
main.cpp         ALGO_ELOG("[nullptr OnStart]: Failed to create SSE type from params." " type=%s", TTSDK_ORDER_SYNTHETIC_TYPE_STR[sse_type]);
main.cpp         ALGO_ELOG("[%s OnStart]: Failed to get SSE type from params ", newParent->GetOrderIDString());
main.cpp         ALGO_ELOG("[%s OnStart]: Failed to get account_id from params ", newParent->GetOrderIDString());
main.cpp         ALGO_ELOG("[%s OnStart]: Failed permission check. order_id=%s error=%s sse_type=%s account_id=%llu", GetAlgoName(), newParent->GetOrderIDString(), TTSDK_ERROR_STR[error], TTSDK_ORDER_SYNTHETIC_TYPE_STR[sse_type], account_id);
main.cpp         ALGO_ELOG("[%s OnStart]: Failed to get instrument from params order_id=%s error=%s ", GetAlgoName(), newParent->GetOrderIDString(), TTSDK_ERROR_STR[error]);
main.cpp         ALGO_ELOG("[%s OnStart]: Failed to download instrument order_id=%s instr=%llu error=%s", GetAlgoName(), newParent->GetOrderIDString(), instrId, TTSDK_ERROR_STR[error]);
main.cpp         ALGO_ELOG("[%s OnStart]: order_id=%s Validation Failed: %s", GetAlgoName(), newParent->GetOrderIDString(), errorMsg);
main.cpp             ALGO_ELOG("[%s OnStart]: Failed to open price subscription order_id=%s instr=%llu error=%s", GetAlgoName(), newParent->GetOrderIDString(), instrId, TTSDK_ERROR_STR[to_underlying(error)]);
main.cpp         ALGO_ELOG("[%s OnStart]: OnStartAlgo returned failure, rejecting order." " order_id=%s" " instr=%llu", GetAlgoName(), newParent->GetOrderIDString(), instrId);
main.cpp     ALGO_ILOG("[%s OnStart]: Succeed! sse_type=%s ", newParent->GetOrderIDString(), TTSDK_ORDER_SYNTHETIC_TYPE_STR[sse_type]);
main.cpp         ALGO_ELOG("[%s OnRecoverAlgo]: Failed to get instrument from params order_id=%s error=%s", GetAlgoName(), newParent->GetOrderIDString(), TTSDK_ERROR_STR[error]);
main.cpp         ALGO_ELOG(error_msg);
main.cpp             ALGO_ELOG(error_msg);
main.cpp         ALGO_ILOG("[%s OnRecoverAlgo]: order_id=%s Insert newParent=%p", GetAlgoName(), newParent->GetOrderIDString(), newParent.get());
main.cpp         ALGO_WLOG("[%s OnRecoverAlgo]: order_id=%s Found existing order=%p", GetAlgoName(), newParent->GetOrderIDString(), existing);
main.cpp     ALGO_WLOG("[%s OnUpdateAlgo]: order_id=%s Order not found", GetAlgoName(), std::string(order_id_str));
main.cpp         ALGO_ELOG("[%s OnResumeAlgo]: Failed to get instrument from params order_id=%s error=%s", GetAlgoName(), newParent->GetOrderIDString(), TTSDK_ERROR_STR[error]);
main.cpp         ALGO_ELOG(error_msg);
main.cpp             ALGO_ELOG(error_msg);
main.cpp         ALGO_ILOG("[%s OnResumeAlgo]: order_id=%s Insert newParent=%p", GetAlgoName(), newParent->GetOrderIDString(), newParent.get());
main.cpp         ALGO_WLOG("[%s OnResumeAlgo]: order_id=%s Found existing order=%p", GetAlgoName(), newParent->GetOrderIDString(), existing);
main.cpp         ALGO_ILOG("[%s OnPauseAlgo]: Call to OnPauseAlgo returned %s order_id=%s", GetAlgoName(), TTSDK_ERROR_STR[result], object->GetOrderIDString());
main.cpp     ALGO_WLOG("[%s OnPauseAlgo]: order_id=%s Order not found", GetAlgoName(), std::string(order_id_str));
main.cpp         ALGO_ILOG("[%s OnStopAlgo]: Call to OnStopAlgo returned %s order_id=%s", GetAlgoName(), TTSDK_ERROR_STR[result], object->GetOrderIDString());
main.cpp     ALGO_WLOG("[%s OnStopAlgo]: order_id=%s Order not found", GetAlgoName(), std::string(order_id_str));
main.cpp         ALGO_ILOG("[%s RegisterUserData]: Found order_id=%s in parentOrders collection and set algo_user_data", GetAlgoName(), std::string(order_id_str));
main.cpp     ALGO_ELOG("[%s RegisterUserData]: Failed to find order_id=%s in parentOrders collection!", GetAlgoName(), std::string(order_id_str));
icebergparent.cpp     ALGO_ILOG("[%s:%s] OnChildAdd: order_id=%s limitPrc=%0.8f OQ=%0.8f WQ=%0.8f", m_name, GetOrderIDString(), childOrder->GetOrderIDString(), limitPrice, orderQuantity, workingQuantity);
icebergparent.cpp     ALGO_ILOG("[%s:%s] OnChildReplace:" "external=%d " "requestsPending=%d " "isChildOrderPassing=%d " "child=[order_id=%s price=%0.8f order_qty=%0.8f working_qty=%0.8f]" "parent=[cum_qty=%0.8f order_qty=%0.8f]" "ActionInProgress=%s " "ActivityBlockedReason=%s ", m_name, GetOrderIDString(), external, requestsPending, isChildOrderPassing, childOrder->GetOrderIDString(), limitPrice, orderQuantity, workingQuantity, parentCumQty, parentOrdQty, USER_ACTION_STR[to_underlying(GetActionInProgress())], ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]);
icebergparent.cpp         ALGO_WLOG("[%s:%s] OnChildReplace unrelated to parent change!", m_name, GetOrderIDString());
icebergparent.cpp             ALGO_ILOG("[%s:%s] OnChildReplace:" " Increased parent qty from %0.8f to %0.8f", m_name, GetOrderIDString(), parentOrdQty, newQuantity);
icebergparent.cpp     ALGO_ILOG("[%s:%s] OnChildCancel: " "order_id=%s " "external=%i " "ActionInProgress=%s", GetName(), GetOrderIDString(), childOrder->GetOrderIDString(), external, USER_ACTION_STR[to_underlying(GetActionInProgress())]);
icebergparent.cpp     ALGO_ILOG("[%s:%s] OnChildFill:" " order_id=%s" " limit_price=%0.8f" " order_qty=%0.8f" " working_qty=%0.8f" " fill_qty=%0.8f" " fill_price=%0.8f" " fill_type=%s", m_name, GetOrderIDString(), child_order->GetOrderIDString(), limit_price, order_quantity, working_quantity, fill_quantity, fill_price, FILL_TYPE_STR[to_underlying(fill_type)]);
icebergparent.cpp     ALGO_ELOG("[%s:%s] OnChildRequestFailure: " "order_id=%s " "requests_pending=%d " "status_flags=[%s] " "timeout=%d " "ActionInProgress=%s", GetName(), GetOrderIDString(), childOrder->GetOrderIDString(), requests_pending, OrderStatusFlagsString(status_flags), timeout, USER_ACTION_STR[to_underlying(GetActionInProgress())]);
icebergparent.cpp     ALGO_ELOG("[%s:%s] OnChildReject: " "order_id=%s " "external=%d " "requests_pending=%d " "message=%s " "ActionInProgress=%s", GetName(), GetOrderIDString(), childOrder->GetOrderIDString(), external, requestsPending, std::string(message), USER_ACTION_STR[to_underlying(GetActionInProgress())]);
icebergparent.cpp         ALGO_DLOG("[%s:%s] ParentOrderTestHarness: StartWorking: Scheduling custom event: " "event_type=%u", m_name, GetOrderIDString(), GetTestHarness()->m_eventToScheduleInStartWorking);
icebergparent.cpp         ALGO_ILOG("[%s:%s] StartWorking: Failed to calculate child price:%s", m_name, GetOrderIDString(), error_str);
icebergparent.cpp             ALGO_ELOG("[%s:%s] StartWorking: Failed to add child order." " error=%s", m_name, GetOrderIDString(), TTSDK_ORDER_ERR_STR[error]);
icebergparent.cpp     ALGO_ILOG("[%s:%s] HandleUpdate: result=%s", m_name, GetOrderIDString(), TTSDK_ERROR_STR[result]);
icebergparent.cpp         ALGO_ILOG("[%s:%s] HandleUpdate: old_disclosed_type=%s new_disclosed_value=%s ", m_name, GetOrderIDString(), VALUE_TYPE_STR[to_underlying(GetDisclosedValueType())], VALUE_TYPE_STR[to_underlying(requestDiscValType)]);
icebergparent.cpp         ALGO_ILOG("[%s:%s] HandleUpdate: old_disclosed_value=%0.8f new_disclosed_value=%0.8f ", m_name, GetOrderIDString(), GetDisclosedValue(), disclosedVal);
icebergparent.cpp         ALGO_ILOG("[%s:%s] HandleUpdate: new display_qty=%0.8f ", m_name, GetOrderIDString(), display_qty);
icebergparent.cpp         ALGO_DLOG("[%s:%s] No child changes required", m_name, GetOrderIDString());
icebergparent.cpp         ALGO_ILOG("[%s:%s] HandleUpdate: Failed to change order." " error=%s", m_name, GetOrderIDString(), TTSDK_ORDER_ERR_STR[order_error]);
icebergparent.cpp         ALGO_ILOG("[%s:%s] HandleActionFinished:" " Activity blocked prevented slice from being added." " reason=%s", m_name, GetOrderIDString(), ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]);
icebergparent.cpp                  ALGO_ILOG("[%s:%s] HandleActionFinished: Placing new slice.", m_name, GetOrderIDString());
icebergparent.cpp                 ALGO_ILOG("[%s:%s] HandleActionFinished:" " No new slice needed, working_qty=0 but ASE child still active", m_name, GetOrderIDString());
icebergparent.cpp             ALGO_ILOG("[%s:%s] HandleActionFinished: No new slice needed." " working_qty=%0.8f", m_name, GetOrderIDString(), childWrkQty);
icebergparent.cpp     ALGO_ILOG("[%s:%s] ResumeWorking:" " order_qty=%0.8f" " limit_prc=%0.8f" " trg_prc=%0.8f" " synth_status=%d " " cum_filled_qty=%0.8f" " ladder_display=%d" " order_type=%s ", m_name, GetOrderIDString(), GetOrderQuantity(), GetLimitPrice(), GetTriggerPrice(), GetSynthStatus(), GetCumFillQuantity(), GetLadderDisplay(), TTSDK_OrderTypeToString(GetType()));
icebergparent.cpp         ALGO_ILOG("[%s:%s] ResumeWorking: Child Info: " "order_ptr=%p " "order_id=%s " "order_type=%s " "order_side=%d " "order_qty=%0.8f " "filled_qty=%0.8f " "order_working_qty=%0.8f " "order_prc=%0.8f " "order_trg_prc=%0.8f " "time_sent=%llu ", m_name, GetOrderIDString(), static_cast<void*>(childOrder.get()), childOrder->GetOrderIDString(), TTSDK_OrderTypeToString(childOrder->GetType()), childOrder->GetSide(), childOrder->GetOrderQty(), childOrder->GetFilledQty(), childOrder->GetWorkingQty(), childOrder->GetLimitPrice(), childOrder->GetTriggerPrice(), childOrder->GetTimeSent());
icebergparent.cpp         ALGO_ILOG("[%s:%s] ResumeWorking: Child is %s! " "order_id=%s " "order_working_qty=%0.8f " "childOrders_size=%zu", m_name, GetOrderIDString(), fp_gt(childOrder->GetWorkingQty(), 0.0) ? "still working" : "not working", childOrder->GetOrderIDString(), childOrder->GetWorkingQty(), m_childOrders.size());
icebergparent.cpp         ALGO_ELOG("[%s:%s] ResumeWorking:" " Iceberg order recovery failed. No child order!", m_name, GetOrderIDString());
icebergparent.cpp     ALGO_ILOG("[%s:%s] ResumeWorking:" " mostRecentChild=%s", m_name, GetOrderIDString(), mostRecentChild->GetOrderIDString());
icebergparent.cpp         ALGO_ILOG("[%s:%s] ResumeWorking: No working orders so sending new slice.", m_name, GetOrderIDString());
icebergparent.cpp         ALGO_ILOG("[%s:%s] ResumeWorking: Primary order is still working, so no" " need to send a new slice.", m_name, GetOrderIDString());
icebergparent.cpp                         ALGO_ILOG("[%s:%s] SendNextSlice: m_childOrders is non-empty," " so changing an existing SomChildOrder.", m_name, GetOrderIDString());
icebergparent.cpp                     ALGO_ILOG("[%s:%s] SendNextSlice: m_childOrders is empty," " so adding a new SomChildOrder.", m_name, GetOrderIDString());
icebergparent.cpp                     ALGO_ELOG("[%s:%s] SendNextSlice Failed:" " new_child_qty=%0.8f" " child_prc=%0.8f" " error=%s", m_name, GetOrderIDString(), slice_qty, price, TTSDK_ORDER_ERR_STR[error]);
icebergparent.cpp             ALGO_ELOG("[%s:%s] SendNextSlice: Failed to calculate child price:%s", m_name, GetOrderIDString(), price_error);
icebergparent.cpp         ALGO_ELOG("[%s:%s] SendNextSlice: Not sending next slice." "Either a UserAction is in progress or there is an ActivityBlockedReason." " ActionInProgress=%s " " ActivityBlockedReason=%s", m_name, GetOrderIDString(), USER_ACTION_STR[to_underlying(GetActionInProgress())], ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]);
icebergparent.cpp         ALGO_ILOG("[%s:%s] GenerateSliceSchedule: cause=%s. " "About to clear current_schedule=%s", m_name, GetOrderIDString(), GenerateSliceScheduleCauseAsString[cause], GetSliceSummary());
icebergparent.cpp         ALGO_ILOG("[%s:%s] cause=%s No remaining qty to generate slice schedule", m_name, GetOrderIDString(), GenerateSliceScheduleCauseAsString[cause]);
icebergparent.cpp         ALGO_WLOG("[%s:%s] cause=%s GenerateSliceSchedule failed!" " remaining_qty=%0.0f" " disc_qty=%f", m_name, GetOrderIDString(), GenerateSliceScheduleCauseAsString[cause], remaining_qty, disc_qty);
icebergparent.cpp         ALGO_ILOG("[%s:%s] cause=%s GenerateSliceSchedule: new=%s", m_name, GetOrderIDString(), GenerateSliceScheduleCauseAsString[cause], GetSliceSummary());
icebergparent.cpp     ALGO_DLOG("[%s:%s] GetPlacedQuantity %0.8f", m_name, GetOrderIDString(), placedQty);
autohedger.cpp         ALGO_WLOG("[AutoHedger:%s] Unsubscribing from options service in destructor", GetOrderIDString());
autohedger.cpp     ALGO_ILOG("[%s:%s] OnChildAdd: limitPrc=%0.8f OQ=%0.8f WQ=%0.8f", m_name, GetOrderIDString(), limitPrice, orderQuantity, workingQuantity);
autohedger.cpp     ALGO_ILOG("[%s:%s] OnChildReplace: " "order_id=%s " "limitPrc=%0.8f " "OQ=%0.8f " "WQ=%0.8f " "external=%d " "requestsPending=%d", m_name, GetOrderIDString(), childOrder->GetOrderIDString(), limitPrice, orderQuantity, workingQuantity, external, requestsPending);
autohedger.cpp     ALGO_ILOG("[%s:%s] OnChildCancel: " "order_id=%s " "external=%i " "ActionInProgress=%s", m_name, GetOrderIDString(), childOrder->GetOrderIDString(), external, USER_ACTION_STR[to_underlying(GetActionInProgress())]);
autohedger.cpp         ALGO_ELOG("[%s:%s] OnChildCancel: Dropping. m_optionsOrder=nullptr.", m_name, GetOrderIDString());
autohedger.cpp         ALGO_DLOG("[%s:%s] OnChildCancel: Dropping Hedge callback.", m_name, GetOrderIDString());
autohedger.cpp     ALGO_ILOG("[%s:%s] OnChildFill: order_id=%s limitPrc=%0.8f OQ=%0.8f WQ=%0.8f FQ=%0.8f FlPrc=%0.8f fill_type=%s", m_name, GetOrderIDString(), child_order->GetOrderIDString(), limit_price, order_quantity, working_quantity, fill_quantity, fill_price, FILL_TYPE_STR[to_underlying(fill_type)]);
autohedger.cpp         ALGO_ELOG("[%s:%s] OnChildFill: Dropping callback - m_optionsOrder was unexpectedly a nullptr.", m_name, GetOrderIDString());
autohedger.cpp     ALGO_ELOG("[%s:%s] OnChildRequestFailure: " "requests_pending=%d " "status_flags=[%s] " "timeout=%d " "ActionInProgress=%s", m_name, GetOrderIDString(), requests_pending, OrderStatusFlagsString(status_flags), timeout, USER_ACTION_STR[to_underlying(GetActionInProgress())]);
autohedger.cpp     ALGO_ELOG("[%s:%s] OnChildReject: " "order_id=%s " "external=%d " "requests_pending=%d " "message=%s " "ActionInProgress=%s", m_name, GetOrderIDString(), childOrder->GetOrderIDString(), external, requestsPending, std::string(message), USER_ACTION_STR[to_underlying(GetActionInProgress())]);
autohedger.cpp     ALGO_DLOG("[AutoHedger:%s] OnPositionReserveAdd instrument_id=%llu m_futuresInstrumentId=%llu", GetOrderIDString(), instr_id, m_futuresInstrumentId);
autohedger.cpp                     ALGO_ELOG("[AutoHedger:%s] delta callback with incorrect orderId; subscriptionID=(%llu, %d) futures_instrument_id=%llu delta=%0.4f", subscriberID, std::get<0>(subscriptionID), std::get<1>(subscriptionID), futures_instrument_id, delta);
autohedger.cpp                 ALGO_ILOG("[AutoHedger:%s] futures_instrument_id=%llu delta=%0.4f", subscriberID, futures_instrument_id, delta);
autohedger.cpp                 ALGO_DLOG("[AutoHedger:%s]", " options-delta Callback on deleted order_id", subscriberID);
autohedger.cpp                     ALGO_ELOG("[AutoHedger:%s] delta callback with incorrect orderId; subscriptionID=(%llu, %d) response_code=%d message=%s", subscriberID, std::get<0>(subscriptionID), std::get<1>(subscriptionID), eventCode, message);
autohedger.cpp                 ALGO_ILOG("[AutoHedger:%s] response_code=%d message=%s", subscriberID, eventCode, message);
autohedger.cpp     ALGO_ILOG("[AutoHedger:%s] futures_instrument_id=%llu delta=%0.4f", GetOrderIDString(), futures_instrument_id, delta);
autohedger.cpp     ALGO_ILOG("[AutoHedger:%s]:CheckAutoHedgerInitializationComplete .. m_autoHedgerInitFlags=0x%x, m_futuresInstrumentId=%llu, m_optionsOrder=%d, m_hedgePROrder=%d m_hedgePROrder->IsWorking()=%d", GetOrderIDString(), m_autoHedgerInitFlags, m_futuresInstrumentId, m_optionsOrder ? 1: 0, m_hedgePROrder ? 1: 0, (m_hedgePROrder && m_hedgePROrder->IsWorking()) ? 1 : 0 );
autohedger.cpp             ALGO_ELOG("[AutoHedger:%s]:CheckAutoHedgerInitializationComplete: Failed to download underlying instrument m_futuresInstrumentId=%llu error=%s", GetOrderIDString(), m_futuresInstrumentId, std::string(TTSDK_ERROR_STR[download_error]));
autohedger.cpp     ALGO_ILOG("[%s:%s]: m_autoHedgerInitFlags=0x%x", m_name, GetOrderIDString(), m_autoHedgerInitFlags);
autohedger.cpp             ALGO_ILOG("[%s:%s]: Placing Position Reserve; hedgeInstrument_id=%llu hedgeInstrumentName=%s pr_qty=%0.8f", m_name, GetOrderIDString(), m_futuresInstrumentId, std::string( TTSDK_GetInstrName(m_futures_instr) ), prQty);
autohedger.cpp             ALGO_ELOG("[%s:%s]: Hedge Position Reserve failed." " pr_qty=%0.8f", m_name, GetOrderIDString(), prQty);
autohedger.cpp         ALGO_ILOG("[%s:%s] StartWorking: Failed to calculate child price:%s", m_name, GetOrderIDString(), error);
autohedger.cpp     ALGO_ILOG("[%s:%s] Add m_optionsOrder=%p", m_name, GetOrderIDString(), (void*)m_optionsOrder.get());
autohedger.cpp     ALGO_ILOG("[%s:%s] INIT_HEDGE_PR", m_name, GetOrderIDString());
autohedger.cpp     ALGO_ELOG("[%s:%s] HandleUpdate should not be called", m_name, GetOrderIDString());
autohedger.cpp     ALGO_ILOG("[%s:%s] ResumeWorking: Printing algo params: " "order_qty=%.8f " "limit_prc=%0.8f " "synth_status=%s " "order_type=%s", m_name, GetOrderIDString(), GetOrderQuantity(), GetLimitPrice(), TTSDK_SYNTH_STATUS_STR[GetSynthStatus()], TTSDK_OrderTypeToString(GetType()));
autohedger.cpp     ALGO_ILOG("[%s:%s] ResumeWorking: Iterating through attached SomChildOrders, " "hedging each fill in a piece-meal fashion.", m_name, GetOrderIDString());
autohedger.cpp         ALGO_ILOG("[%s:%s] ResumeWorking: Order Info: " "order_ptr=%p " "order_id=%s " "order_type=%s " "order_side=%d " "order_qty=%0.8f " "order_working_qty=%0.8f " "order_prc=%0.8f " "order_trg_prc=%0.8f ", m_name, GetOrderIDString(), static_cast<void *>(childOrder.get()), childOrder->GetOrderIDString(), TTSDK_OrderTypeToString(childOrder->GetType()), childOrder->GetSide(), childOrder->GetOrderQty(), childOrder->GetWorkingQty(), childOrder->GetLimitPrice(), childOrder->GetTriggerPrice());
autohedger.cpp                 ALGO_ELOG("[%s:%s] ResumeWorking: Duplicate m_optionsOrder detected - " "the recovery process will fail.", m_name, GetOrderIDString());
autohedger.cpp                 ALGO_ILOG("[%s:%s] ResumeWorking: m_optionsOrder=%p", m_name, GetOrderIDString(), (void*)m_optionsOrder.get());
autohedger.cpp         ALGO_WLOG("[%s:%s] ResumeWorking: Fills while algo was down do not send hedge. detected_fill_qty=%0.8f, m_cumFillQty=%0.8f", m_name, GetOrderIDString(), cumFillQty, m_cumFillQty );
autohedger.cpp             ALGO_ELOG("[%s:%s] ResumeWorking: AutoHedger order recovery failed due to an unexpected scenario: " "failureOccurred=%s m_optionsOrder=%s", m_name, GetOrderIDString(), failureOccurred ? "true" : "false", m_optionsOrder == nullptr ? "nullptr" : "Not working");
autohedger.cpp         ALGO_ELOG("[%s:%s] HedgePrimaryFill: No action, No futures instrument_id or delta", m_name, GetOrderIDString());
autohedger.cpp     ALGO_ILOG("[%s:%s]: Hedge order fillQty=%0.8f hedgeQty=%0.8f, m_unhedgedQty=%0.8f", m_name, GetOrderIDString(), fill_quantity, hedgeQty, m_unhedgedQty);
autohedger.cpp         ALGO_ILOG("[%s:%s] Add hedgeOrder=%p", m_name, GetOrderIDString(), (void*)hedgeOrder.get());
autohedger.cpp             ALGO_ILOG("[%s:%s] SendSuspendStatus on disconnect " "syn_status=%s", GetName(), GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[status]);
autohedger.cpp                 ALGO_ILOG("[%s:%s] SendSuspendStatus on disconnect " "m_autoHedgerOrderType=%d; NativeStopTriggered=false", GetName(), GetOrderIDString(), m_autoHedgerOptionOrderType);
autohedger.cpp                 ALGO_ILOG("[%s:%s] HandlePriceError: Disconnect Ignored " "m_autoHedgerOrderType=%d; m_optionsOrder=%s; NativeStopTriggered=%s", GetName(), GetOrderIDString(), m_autoHedgerOptionOrderType, m_optionsOrder ? "Exist": "Not exist", m_optionsOrder ? std::to_string(m_optionsOrder->NativeStopTriggered()): "N/A");
autohedger.cpp             ALGO_ILOG("[%s:%s] HandlePriceError: Disconnect Ignored " "syn_status=%s", GetName(), GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[status]);
singlechildparent.cpp         ALGO_ILOG("[%s:%s] StartWorking: Publishing trigger report: " "last_trg_qty=%0.8f " "trg_prc=%0.8f", GetName(), GetOrderIDString(), GetLastTrgQty(), GetTriggerPrice());
singlechildparent.cpp     ALGO_ILOG("[%s:%s] HandleUpdate: " " synth_status=%s" " childOrdersSize=%zd" " childPRExists=%s", GetName(), GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[GetSynthStatus()], this->m_childOrders.size(), m_childPR ? std::string("true") : std::string("false"));
singlechildparent.cpp     ALGO_ILOG("[%s:%s] HandleUpdate: Sending requests with the following" " (note: some fields may be invalid depending on the sequence):" " pending_change_subtasks=%s" " target_price=%0.8f" " target_qty=%0.8f" " target_pr_qty=%0.8f", GetName(), GetOrderIDString(), std::to_string(m_pending_change_subtasks), m_targetNewPrice, m_targetNewQty, m_targetPRQty);
singlechildparent.cpp     ALGO_ILOG("[%s:%s] HandleUpdate: ProcessPendingChangeTasks returned error=%s", GetName(), GetOrderIDString(), TTSDK_ERROR_STR[error]);
singlechildparent.cpp     ALGO_ILOG("[%s:%s] OnChildAdd: " "order_id=%s" "limitPrc=%0.8f " "OQ=%0.8f " "WQ=%0.8f", GetName(), GetOrderIDString(), childOrder->GetOrderIDString(), limitPrice, orderQuantity, workingQuantity);
singlechildparent.cpp     ALGO_ILOG("[%s:%s] OnChildReplace:" " order_id=%s" " price=%0.8f" " order_qty=%0.8f" " working_qty=%0.8f" " external=%d" " requests_pending=%d", GetName(), GetOrderIDString(), childOrder->GetOrderIDString(), limitPrice, orderQuantity, workingQuantity, external, requestsPending);
singlechildparent.cpp     ALGO_ILOG("[%s:%s] OnChildCancel: " "order_id=%s " "external=%i " "ActionInProgress=%s", GetName(), GetOrderIDString(), childOrder->GetOrderIDString(), external, USER_ACTION_STR[to_underlying(GetActionInProgress())]);
singlechildparent.cpp     ALGO_ELOG("[%s:%s] OnChildRequestFailure: " "order_id=%s " "requests_pending=%d " "status_flags=[%s] " "timeout=%d " "ActionInProgress=%s", GetName(), GetOrderIDString(), childOrder->GetOrderIDString(), requests_pending, OrderStatusFlagsString(status_flags), timeout, USER_ACTION_STR[to_underlying(GetActionInProgress())]);
singlechildparent.cpp     ALGO_ELOG("[%s:%s] OnChildReject: " "order_id=%s " "external=%d " "requests_pending=%d " "message=%s " "ActionInProgress=%s", GetName(), GetOrderIDString(), childOrder->GetOrderIDString(), external, requestsPending, std::string(message), USER_ACTION_STR[to_underlying(GetActionInProgress())]);
singlechildparent.cpp     ALGO_ILOG("[%s:%s] ResumeWorking:" " order_qty=%0.8f" " limit_prc=%0.8f" " trg_prc=%0.8f" " synth_status=%d " " cum_filled_qty=%0.8f" " ladder_display=%d" " order_type=%s " " children_size=%d", m_name, GetOrderIDString(), GetOrderQuantity(), GetLimitPrice(), GetTriggerPrice(), GetSynthStatus(), GetCumFillQuantity(), GetLadderDisplay(), TTSDK_OrderTypeToString(GetType()), children_size);
singlechildparent.cpp         ALGO_ILOG("[%s:%s] ResumeWorking: Child Info: " "order_ptr=%p " "order_id=%s " "order_type=%s " "order_side=%d " "order_qty=%0.8f " "filled_qty=%0.8f " "order_working_qty=%0.8f " "order_prc=%0.8f " "order_trg_prc=%0.8f " "time_sent=%llu ", m_name, GetOrderIDString(), static_cast<void*>(childOrder.get()), childOrder->GetOrderIDString(), TTSDK_OrderTypeToString(childOrder->GetType()), childOrder->GetSide(), childOrder->GetOrderQty(), childOrder->GetFilledQty(), childOrder->GetWorkingQty(), childOrder->GetLimitPrice(), childOrder->GetTriggerPrice(), childOrder->GetTimeSent());
singlechildparent.cpp         ALGO_ELOG("[%s:%s] ResumeWorking: no triggered_child found.", m_name, GetOrderIDString());
singlechildparent.cpp         ALGO_ELOG("[%s:%s] ResumeWorking: triggered_child not working", m_name, GetOrderIDString());
timeduration.cpp         ALGO_ELOG("[%s:%s] Invalid Child TIF" " child_tif=%d", m_name, GetOrderIDString(), child_tif);
timeduration.cpp             ALGO_ELOG("[%s:%s] End time is in the past." " now=%lld" " end_time=%lld", m_name, GetOrderIDString(), now.time_since_epoch().count(), m_endTime.time_since_epoch().count());
timeduration.cpp             ALGO_ILOG("[%s:%s] Start time updated to current time." " old_start=%lld" " new_start=%lld" " end_time=%lld", m_name, GetOrderIDString(), m_startTime.time_since_epoch().count(), now.time_since_epoch().count(), m_endTime.time_since_epoch().count());
timeduration.cpp     ALGO_ILOG("[%s:%s] StartWorking." " start_time=%lld" " end_time=%lld" " duration=%lld", m_name, GetOrderIDString(), m_startTime.time_since_epoch().count(), m_endTime.time_since_epoch().count(), m_duration.count());
timeduration.cpp             ALGO_ELOG("[%s:%s] Failed to arm timer." " start_time=%llu", m_name, GetOrderIDString(), t);
timeduration.cpp         ALGO_ELOG("[%s:%s] StartWaiting failed to create timer." " error=%s", m_name, GetOrderIDString(), std::string(ex.what()));
timeduration.cpp         ALGO_ELOG("[%s:%s] ActuallyStartWorking failed to create timer." " error=%s", m_name, GetOrderIDString(), std::string(ex.what()));
timeduration.cpp         ALGO_ILOG("[%s:%s] HandleTimeSliceEvent: Ready to send next slice." " timeslice_revision=%lu" " schedule_revision=%lu" " slice_state_info=%s", m_name, GetOrderIDString(), timeSliceRevision, curTimeSliceRevision, std::to_string(isInSlicingMode));
timeduration.cpp         ALGO_ILOG("[%s:%s] HandleTimeSliceEvent determined that the next slice can't be honored due to an invalid state." " timeslice_revision=%lu" " schedule_revision=%lu" " slice_state_info=%s", m_name, GetOrderIDString(), timeSliceRevision, curTimeSliceRevision, std::to_string(isInSlicingMode));
timeduration.cpp         ALGO_ILOG("[%s:%s] HandleTimeSliceEvent: Skipping half life event" " timeslice_revision=%lu" " schedule_revision=%lu" " slice_state_info=%s", m_name, GetOrderIDString(), timeSliceRevision, curTimeSliceRevision, std::to_string(isInSlicingMode));
timeduration.cpp         ALGO_ILOG("[%s:%s] HandleHalfLifeEvent applying leftover action at half life", m_name, GetOrderIDString());
timeduration.cpp         ALGO_WLOG("[%s:%s] HandleHalfLifeEvent triggered without leftover action time == half life", m_name, GetOrderIDString());
timeduration.cpp             ALGO_ILOG("[%s:%s] OnChildReplace: completed and now requires a new schedule. Generating now." " is_external=%d" " is_request_pending=%d" " slice_state_info=%s" " WQ=%0.8f" " prev_working_qty=%0.8f", m_name, GetOrderIDString(), is_external, is_request_pending, std::to_string(isInSlicingMode), working_qty, child->GetPrevOrderInfo().working_quantity);
timeduration.cpp             ALGO_ILOG("[%s:%s] OnChildReplace: determined that generating and slicing was not applicable." " is_external=%d" " is_request_pending=%d" " slice_state_info=%s" " WQ=%0.8f" " prev_working_qty=%0.8f", m_name, GetOrderIDString(), is_external, is_request_pending, std::to_string(isInSlicingMode), working_qty, child->GetPrevOrderInfo().working_quantity);
timeduration.cpp             ALGO_ILOG("[%s:%s] OnChildCancel: completed and now requires a new schedule. Generating now." " is_external=%d" " slice_state_info=%s", m_name, GetOrderIDString(), is_external, std::to_string(isInSlicingMode));
timeduration.cpp             ALGO_ILOG("[%s:%s] OnChildCancel: determined that generating and slicing was not applicable." " is_external=%d" " slice_state_info=%s", m_name, GetOrderIDString(), is_external, std::to_string(isInSlicingMode));
timeduration.cpp         ALGO_WLOG("[%s:%s] HandlePostDurationChange: All children have been detected as cancelled and running duration has ended. Tearing down algo." " duration=%lld", m_name, GetOrderIDString(), m_duration.count());
timeduration.cpp         ALGO_ILOG("[%s:%s] HandlePostDurationChange: Adjusting Parent Order Qty." " old_order_qty=%0.8f" " new_order_qty=%0.8f", m_name, GetOrderIDString(), orderQty, placedQty);
timeduration.cpp             ALGO_WLOG("[%s:%s] ValidateUpdate: Encountered an attempt to change order quantity after duration lapsed." " duration=%0.8f" " requested_order_qty=%0.8f" " current_order_qty=%0.8f", m_name, GetOrderIDString(), calc_duration.count(), requested_ord_qty, current_ord_qty);
timeduration.cpp     ALGO_ILOG("[%s:%s] ValidateUpdate: " "is_duration_based=%d " "has_request_dur=%d " "has_request_dur_unit=%d " "request_dur=%ld " "request_dur_unit=%d " "has_request_start_ms=%d " "has_request_end_ms=%d " "request_start_ms=%ld " "request_end_ms=%ld ", m_name, GetOrderIDString(), is_duration_based, has_request_dur, has_request_dur_unit, request_dur, request_dur_unit, has_request_start_ms, has_request_end_ms, request_start_ms, request_end_ms);
timeduration.cpp             ALGO_WLOG("[%s:%s] ValidateUpdate: Cannot change the duration type from \"Duration\" to \"Start/End\"", m_name, GetOrderIDString());
timeduration.cpp             ALGO_WLOG("[%s:%s] ValidateUpdate: Cannot change the duration type from \"Start/End\" to \"Duration\"", m_name, GetOrderIDString());
timeduration.cpp     ALGO_ILOG("[%s:%s] ValidateUpdate: " "start_ms=%ld " "end_ms=%ld " "dur_unit=%d " "dur=%ld " "interval=%d " "disc_qty=%0.8f " "value_type=%d " "is_duration_based=%d " "request_start_ms=%ld " "request_end_ms=%ld " "request_dur_unit=%d " "request_dur=%ld " "request_interval=%d " "request_disc_qty=%0.8f " "request_value_type=%d ", m_name, GetOrderIDString(), start_ms, end_ms, dur_unit, dur, interval, disc_qty, value_type, is_duration_based, request_start_ms, request_end_ms, request_dur_unit, request_dur, request_interval, request_disc_qty, (int)request_value_type);
timeduration.cpp         ALGO_WLOG("[%s:%s] ValidateUpdate: Cannot change the interval from %d to %d", m_name, GetOrderIDString(), interval, request_interval);
timeduration.cpp         ALGO_ILOG("[%s:%s] ValidateUpdate: Ensuring that new_end is in the future: now=%lld old_end=%lld new_end=%lld", m_name, GetOrderIDString(), now.time_since_epoch(), m_endTime.time_since_epoch(), new_end.time_since_epoch());
timeduration.cpp         ALGO_ILOG("[%s:%s] HandleUpdate: completed and now requires a new schedule. Generating now." " result=%s" " slice_state_info=%s" " OldWQ=%0.8f" " WQ=%0.8f" " has_timing_changed=%d", m_name, GetOrderIDString(), TTSDK_ERROR_STR[result], std::to_string(isInSlicingMode), old_qty, new_qty, has_timing_changed);
timeduration.cpp         ALGO_ILOG("[%s:%s] HandleUpdate: determined that generating and slicing was not applicable." " result=%s" " slice_state_info=%s" " OldWQ=%0.8f" " WQ=%0.8f" " has_timing_changed=%d", m_name, GetOrderIDString(), TTSDK_ERROR_STR[result], std::to_string(isInSlicingMode), old_qty, new_qty, has_timing_changed);
timeduration.cpp             ALGO_ILOG("[%s:%s] HandleActionFinished(UserAction::Change): Change completed which requires a new schedule. Generating now." " slice_state_info=%s", m_name, GetOrderIDString(), std::to_string(isInSlicingMode));
timeduration.cpp             ALGO_ILOG("[%s:%s] HandleActionFinished(UserAction::Change): determined that generating and slicing was not applicable." " slice_state_info=%s" " was_action_successful=%s", m_name, GetOrderIDString(), std::to_string(isInSlicingMode), wasActionSuccessful ? "true" : "false");
timeduration.cpp         ALGO_ILOG("[%s:%s] OnStopAlgo: Stop slice timer", m_name, GetOrderIDString());
timeduration.cpp         ALGO_ILOG("[%s:%s] OnStopAlgo: Stop half life timer", m_name, GetOrderIDString());
timeduration.cpp             ALGO_ILOG("[%s:%s] GenerateAndStartSlicing: No remaining qty to generate slice schedule.", m_name, GetOrderIDString());
timeduration.cpp                 ALGO_ELOG("[%s:%s] SliceAndScheduleTimer: Failed to arm half life timer." " interval=%llu", m_name, GetOrderIDString(), slice_time);
timeduration.cpp                 ALGO_ELOG("[%s:%s] SliceAndScheduleTimer: Failed to arm slice timer." " interval=%llu", m_name, GetOrderIDString(), slice_time);
timeduration.cpp         ALGO_ILOG("[%s:%s] SliceAndScheduleTimer: determine that the timer doesn't need to be reset.", m_name, GetOrderIDString());
timeduration.cpp     ALGO_ILOG("[%s:%s] GenerateSliceSchedule:" " order_qty=%0.8f" " placed_qty=%0.8f" " recalculate=%d", m_name, GetOrderIDString(), order_qty, placed_qty, recalculate);
timeduration.cpp         ALGO_ILOG("[%s:%s] GenerateSliceSchedule: No remaining qty to generate slice schedule." " schedule_revision=%lu" " remaining_qty=%0.8f", m_name, GetOrderIDString(), newRevision, remaining_qty);
timeduration.cpp         ALGO_ILOG("[%s:%s] GenerateSliceSchedule: Duration reduced." " duration=%lld" " schedule_revision=%lu", m_name, GetOrderIDString(), m_duration.count(), newRevision);
timeduration.cpp         ALGO_WLOG("[%s:%s] GenerateSliceSchedule: Unable to generate slice schedule." " disc_value=%0.8f" " disc_value_type=%s" " interval=%lld" " schedule_revision=%lu", m_name, GetOrderIDString(), GetDisclosedValue(), VALUE_TYPE_STR[to_underlying(GetDisclosedValueType())], m_interval.count(), newRevision);
timeduration.cpp         ALGO_ILOG("[%s:%s] GenerateSliceSchedule: Generated new slice schedule. schedule_revision=%lu %s", m_name, GetOrderIDString(), newRevision, GetSliceSummary());
timeduration.cpp         ALGO_DLOG("[%s:%s] UpdateTimeDurationParamsForSyncChange: Comparing now vs. generic_start_time for update to Duration Start Time: " "now=%lld " "generic_start_time=%lld", m_name, GetOrderIDString(), now.time_since_epoch(), generic_start_time.time_since_epoch());
timeduration.cpp             ALGO_DLOG("[%s:%s] UpdateTimeDurationParamsForSyncChange: We are PAST the Generic Start Time!", m_name, GetOrderIDString());
timeduration.cpp             ALGO_DLOG("[%s:%s] UpdateTimeDurationParamsForSyncChange: We are BEFORE the Generic Start Time!", m_name, GetOrderIDString());
timeduration.cpp         ALGO_DLOG("[%s:%s] UpdateTimeDurationParamsForSyncChange: Comparing now vs. generic_start_time for update to Duration End Time: " "now=%lld " "generic_start_time=%lld", m_name, GetOrderIDString(), now.time_since_epoch(), generic_start_time.time_since_epoch());
timeduration.cpp             ALGO_DLOG("[%s:%s] UpdateTimeDurationParamsForSyncChange: We are PAST the Generic Start Time!", m_name, GetOrderIDString());
timeduration.cpp             ALGO_DLOG("[%s:%s] UpdateTimeDurationParamsForSyncChange: We are BEFORE the Generic Start Time!", m_name, GetOrderIDString());
timeduration.cpp             ALGO_ELOG("[%s:%s] UpdateTimeDurationParamsForSyncChange: " "Failed to compute new End Time using new Duration and/or new Duration Base Unit! " "This is unexpected and the user change will be ignored!", m_name, GetOrderIDString());
timeduration.cpp     ALGO_ILOG("[%s:%s] UpdateTimeDurationParamsForSyncChange: Updated params: " "[Params for when DurationType=StartEnd: request_start_ms=%llu request_end_ms=%llu] " "[Params for when DurationType=Duration: request_dur_unit=%d request_dur=%d] " "[Params for when SliceType=Interval: request_interval=%d] " "[Params for when SliceType=Disclosed: request_disc_qty=%f request_value_type=%d] " "[General Params (in ms): now=%lld m_startTime=%lld m_endTime=%lld m_duration=%lld]", m_name, GetOrderIDString(), request_start_ms, request_end_ms, static_cast<int>(request_dur_unit), request_dur, request_interval, request_disc_qty, static_cast<int>(request_value_type), now.time_since_epoch(), m_startTime.time_since_epoch(), m_endTime.time_since_epoch(), m_duration.count());
timeduration.cpp         ALGO_DLOG("[%s:%s] ComputeNewEndTime: m_endTime was uninitialized!", m_name, GetOrderIDString());
timeduration.cpp     ALGO_ILOG("[%s:%s] ComputeNewEndTime: " "[old_duration_raw=%lld old_duration_unit=%d old_duration_ms=%lld] " "[new_duration_raw=%lld new_duration_unit=%d new_duration_ms=%lld] " "[old_end_time=%lld new_end_time=%lld]", m_name, GetOrderIDString(), old_duration_raw, static_cast<int>(old_duration_unit), old_duration_ms.count(), new_duration_raw, static_cast<int>(new_duration_unit), new_duration_ms.count(), old_end_time.time_since_epoch(), new_end_time.time_since_epoch());
timeduration.cpp         ALGO_WLOG("[%s:%s] GenerateSliceSchedule: EndTime has passed so new schedule is not applicable. Skipping." " duration=%lld" " schedule_revision=%lu", m_name, GetOrderIDString(), m_duration.count(), newRevision);
timeduration.cpp             ALGO_ILOG("[%s:%s] GenerateSliceSchedule: Interval is greater than the duration. Generating a single slice." " interval=%lld" " num_slices=%lld" " existing_slices=%lld" " duration=%lld" " required_qty=%0.8f" " schedule_revision=%lu", m_name, GetOrderIDString(), m_interval.count(), num_slices, existing_slices, m_duration.count(), required_qty, newRevision);
timeduration.cpp             ALGO_ILOG("[%s:%s] GenerateSliceSchedule: Executing GenerateIntervalBasedSlices." " required_qty=%0.8f" " num_slices=%zu" " existing_slices=%lld" " variance=%d" " min_qty=%0.8f" " seed=%u" " schedule_seed=%u" " schedule_revision=%lu", m_name, GetOrderIDString(), required_qty, num_slices, existing_slices, variance, min_qty, m_seed, GetScheduleSeed(), newRevision);
parentorder.cpp     ALGO_ILOG("[Factory]: Create Parent: order_id=%s algo=%s", m_order_id_str, m_name);
parentorder.cpp     ALGO_ILOG("[%s:%s]: Destruction! And will UnSubscribePrice", m_name, GetOrderIDString());
parentorder.cpp     ALGO_ILOG("[%s:%s]: OnPositionReserveAdd: " "order_id=%s " "OQ=%0.8f " "ActivityBlockedReason=%s " "ActionInProgress=%s ", m_name, GetOrderIDString(), m_childPR->GetOrderIDString(), m_childPR->GetInflightOrderQty(), ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())], USER_ACTION_STR[to_underlying(GetActionInProgress())]);
parentorder.cpp     ALGO_ILOG("[%s:%s]: CheckInitializationProgress" " flags=%u", m_name, GetOrderIDString(), m_initFlags);
parentorder.cpp             ALGO_ILOG("[%s:%s]: CheckInitializationProgress: Setting exec_restatement_reason to: ORDER_ACCEPTED", m_name, GetOrderIDString());
parentorder.cpp         ALGO_ILOG("[%s:%s]: SetPriceDriftCheckRules: Exempt from check given the algo type: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ILOG("[%s:%s]: SetPriceDriftCheckRules: Exempt from check since instrument is synthetic: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetPriceDriftCheckRules: GetEnableAlgoRiskChecks Failed: " "account_id=%llu " "error=%s", m_name, GetOrderIDString(), GetAccountID(), error_msg);
parentorder.cpp         ALGO_ILOG("[%s:%s]: SetPriceDriftCheckRules: Exempt from check since Algo Risk Check is disabled: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_WLOG("[%s:%s]: SetPriceDriftCheckRules: Outright OneMinTicks param not set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetPriceDriftCheckRules: Failed to retrieve Outright OneMinTicks param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_WLOG("[%s:%s]: SetPriceDriftCheckRules: Outright OneMinPercent param not set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetPriceDriftCheckRules: Failed to retrieve Outright OneMinPercent param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_WLOG("[%s:%s]: SetPriceDriftCheckRules: Outright ThreeMinTicks param not set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetPriceDriftCheckRules: Failed to retrieve Outright ThreeMinTicks param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_WLOG("[%s:%s]: SetPriceDriftCheckRules: Outright ThreeMinPercent param not set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetPriceDriftCheckRules: Failed to retrieve Outright ThreeMinPercent param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_WLOG("[%s:%s]: SetPriceDriftCheckRules: Outright LifetimeTicks param not set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetPriceDriftCheckRules: Failed to retrieve Outright LifetimeTicks param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_WLOG("[%s:%s]: SetPriceDriftCheckRules: Outright LifetimePercent param not set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetPriceDriftCheckRules: Failed to retrieve Outright LifetimePercent param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_WLOG("[%s:%s]: SetPriceDriftCheckRules: Spread OneMinTicks param not set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetPriceDriftCheckRules: Failed to retrieve Spread OneMinTicks param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_WLOG("[%s:%s]: SetPriceDriftCheckRules: Spread OneMinPercent param not set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetPriceDriftCheckRules: Failed to retrieve Spread OneMinPercent param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_WLOG("[%s:%s]: SetPriceDriftCheckRules: Spread ThreeMinTicks param not set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetPriceDriftCheckRules: Failed to retrieve Spread ThreeMinTicks param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_WLOG("[%s:%s]: SetPriceDriftCheckRules: Spread ThreeMinPercent param not set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetPriceDriftCheckRules: Failed to retrieve Spread ThreeMinPercent param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_WLOG("[%s:%s]: SetPriceDriftCheckRules: Spread LifetimeTicks param not set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetPriceDriftCheckRules: Failed to retrieve Spread LifetimeTicks param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_WLOG("[%s:%s]: SetPriceDriftCheckRules: Spread LifetimePercent param not set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetPriceDriftCheckRules: Failed to retrieve Spread LifetimePercent param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_WLOG("[%s:%s]: SetPriceDriftCheckRules: [is_spread_or_strategy] param not set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetPriceDriftCheckRules: Failed to retrieve [is_spread_or_strategy] param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ILOG("[%s:%s]: SetPriceDriftCheckRules: Exempt from check since no limits are set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp     ALGO_ILOG("[%s:%s]: SetPriceDriftCheckRules (zero means not set): " "pdci_one_min_ticks=%u " "pdci_one_min_pct=%u " "pdci_three_min_ticks=%u " "pdci_three_min_pct=%u " "pdci_lifetime_ticks=%u " "pdci_lifetime_pct=%u " "spdci_one_min_ticks=%u " "spdci_one_min_pct=%u " "spdci_three_min_ticks=%u " "spdci_three_min_pct=%u " "spdci_lifetime_ticks=%u " "spdci_lifetime_pct=%u " "is_spread_or_strategy=%d", m_name, GetOrderIDString(), risk_limits.pdci_one_min_ticks, risk_limits.pdci_one_min_pct, risk_limits.pdci_three_min_ticks, risk_limits.pdci_three_min_pct, risk_limits.pdci_lifetime_ticks, risk_limits.pdci_lifetime_pct, risk_limits.spdci_one_min_ticks, risk_limits.spdci_one_min_pct, risk_limits.spdci_three_min_ticks, risk_limits.spdci_three_min_pct, risk_limits.spdci_lifetime_ticks, risk_limits.spdci_lifetime_pct, risk_limits.is_spread_or_strategy);
parentorder.cpp         ALGO_ILOG("[%s:%s]: SetAverageTradeSizeChecker: Exempt from check since instrument is synthetic: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetAverageTradeSizeChecker: GetEnableAlgoRiskChecks Failed: " "error=%s " "account_id=%llu", m_name, GetOrderIDString(), error_msg, GetAccountID());
parentorder.cpp         ALGO_ILOG("[%s:%s]: SetAverageTradeSizeChecker: Exempt from check since Algo Risk Check is disabled: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetAverageTradeSizeChecker: Failed to retrieve MaxChildSliceSize param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ILOG("[%s:%s]: SetAverageTradeSizeChecker: Exempt from check since Max Child Slice Percentage is not set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp     ALGO_ILOG("[%s:%s]: SetAverageTradeSizeChecker: " "account_id=%llu " "max_child_slice_size=%zu", m_name, GetOrderIDString(), GetAccountID(), risk_limits.max_child_slice_size);
parentorder.cpp             ALGO_ELOG("[%s:%s]: SetAverageTradeSizeChecker: Failed to retrieve AverageTradeSize param during recovery: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ILOG("[%s:%s]: SetAverageTradeSizeChecker: Retrieved AverageTradeSize from params during recovery: " "account_id=%llu " "average_trade_size=%f", m_name, GetOrderIDString(), GetAccountID(), average_trade_size);
parentorder.cpp     ALGO_ILOG("[%s:%s]: SetAverageTradeSizeChecker: Spawning one-off worker thread to perform HDS download: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ILOG("[%s:%s]: SetMaxOrderRateChecker: Exempt from check since instrument is synthetic: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetMaxOrderRateChecker: GetEnableAlgoRiskChecks Failed: " "account_id=%llu " "error=%s", m_name, GetOrderIDString(), GetAccountID(), error_msg);
parentorder.cpp         ALGO_ILOG("[%s:%s]: SetMaxOrderRateChecker: Exempt from check since Algo Risk Check is disabled: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetMaxOrderRateChecker: Failed to retrieve MaxNumberOfCancels param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ELOG("[%s:%s]: SetMaxOrderRateChecker: Failed to retrieve MaxNumberOfUpdates param: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp         ALGO_ILOG("[%s:%s]: SetMaxOrderRateChecker: Exempt from check since both Max Number Of Cancels and Max Number Of Updates are not set: " "account_id=%llu", m_name, GetOrderIDString(), GetAccountID());
parentorder.cpp     ALGO_ILOG("[%s:%s]: SetMaxOrderRateChecker: " "m_account_id=%llu " "m_max_number_of_updates=%u " "m_max_number_of_cancels=%u", m_name, GetOrderIDString(), GetAccountID(), risk_limits.max_number_of_updates, risk_limits.max_number_of_cancels);
parentorder.cpp     ALGO_ILOG("[%s:%s]: OnStartAlgo: Starting algo", m_name, GetOrderIDString());
parentorder.cpp         ALGO_ILOG("[%s:%s] marking PR initialized:" " enabled=%d" " supported=%d", m_name, GetOrderIDString(), env::instance().is_sse_pr_enabled(), SupportsPR());
parentorder.cpp         ALGO_ILOG("[%s:%s] marking Price subscribed:", m_name, GetOrderIDString());
parentorder.cpp     ALGO_ILOG("[%s:%s]: OnStartAlgo: Finished." " success=%d", m_name, GetOrderIDString(), success);
parentorder.cpp         ALGO_ILOG("[%s:%s]: Placing Position Reserve." " pr_qty=%0.8f", m_name, GetOrderIDString(), pr_qty);
parentorder.cpp             ALGO_ELOG("[%s:%s]: Placing Position Reserve failed." " pr_qty=%0.8f", m_name, GetOrderIDString(), pr_qty);
parentorder.cpp     ALGO_ILOG("[%s:%s]: OnRecoverAlgo: Recovering algo." " error_code=%s" " error_msg=%s", m_name, GetOrderIDString(), TTSDK_ERROR_STR[error_code], error_msg);
parentorder.cpp         ALGO_ILOG("[%s:%s]: Parent marking PR initialized." " enabled=%d" " supported=%d", m_name, GetOrderIDString(), env::instance().is_sse_pr_enabled(), SupportsPR());
parentorder.cpp     ALGO_ILOG("[%s:%s]: OnResumeAlgo: Resuming algo." " error_code=%s" " error_msg=%s", m_name, GetOrderIDString(), TTSDK_ERROR_STR[error_code], error_msg);
parentorder.cpp     ALGO_ILOG("[%s:%s]: Parent marking PR initialized." " enabled=%d" " supported=%d", m_name, GetOrderIDString(), env::instance().is_sse_pr_enabled(), SupportsPR());
parentorder.cpp         ALGO_ILOG("[%s:%s]: OnScheduledEvent: StopAlgo", m_name, GetOrderIDString());
parentorder.cpp             ALGO_ELOG("[%s:%s]: OnScheduledEvent(HDSDownloadResponse): Failing algo because HDS download response arrived at an unexpected algo state: " "activity_blocked_reason=%s", m_name, GetOrderIDString(), ACTIVITY_BLOCK_STR[static_cast<unsigned char>(activity_blocked_reason)]);
parentorder.cpp             ALGO_ELOG("[%s:%s]: OnScheduledEvent(HDSDownloadResponse): Failing algo because HDS download failed", m_name, GetOrderIDString());
parentorder.cpp         ALGO_ILOG("[%s:%s]: OnScheduledEvent(HDSDownloadResponse): HDS download successful: " "average_trade_size=%f", m_name, GetOrderIDString(), hds_response->average_trade_size);
parentorder.cpp         ALGO_ILOG("[%s:%s]: OnScheduledEvent: FailAlgo", m_name, GetOrderIDString());
parentorder.cpp         ALGO_ILOG("[%s:%s]: UpdateParamsForStop: Full fill." " fill_qty=%0.8f" " fill_price=%0.8f" " cum_qty=%0.8f" " OQ=%0.8f", m_name, GetOrderIDString(), fill_qty, fill_price, m_cum_fill_qty, GetOrderQuantity());
parentorder.cpp         ALGO_ILOG("[%s:%s]: UpdateParamsForStop: Cancelled." " cum_qty=%0.8f" " OQ=%0.8f", m_name, GetOrderIDString(), m_cum_fill_qty, GetOrderQuantity());
parentorder.cpp     ALGO_ILOG("[%s:%s]: Stop Requested.", m_name, GetOrderIDString());
parentorder.cpp     ALGO_ILOG("[%s:%s]: CompleteAction: " "working_qty=%0.8f " "display_qty=%0.8f " "ActionInProgress=%s ", m_name, GetOrderIDString(), working_qty, display_qty, USER_ACTION_STR[to_underlying(GetActionInProgress())]);
parentorder.cpp         ALGO_WLOG("[%s:%s] CompleteAction: Failed to promote FIX params for accept response: " "error=%s " "IGNORE this warning if FIX is not involved!", m_name, GetOrderIDString(), TTSDK_ERROR_STR[ttsdk_error]);
parentorder.cpp         ALGO_ILOG("[%s:%s] CompleteAction: Promoted FIX params for accept response", m_name, GetOrderIDString());
parentorder.cpp         ALGO_WLOG("[%s:%s] CompleteAction: Failed to promote cl_ord_id params: " "error=%s ", m_name, GetOrderIDString(), TTSDK_ERROR_STR[ttsdk_error]);
parentorder.cpp         ALGO_ILOG("[%s:%s] CompleteAction: Promoted cl_ord_id params: cl_ord_id=%llu orig_cl_ord_id=%llu", m_name, GetOrderIDString(), cl_ord_id, orig_cl_ord_id);
parentorder.cpp     ALGO_ILOG("[%s:%s]: CompleteEndTimeAction: " "working_qty=%0.8f " "display_qty=%0.8f " "ActionInProgress=%s ", m_name, GetOrderIDString(), working_qty, display_qty, USER_ACTION_STR[to_underlying(GetActionInProgress())]);
parentorder.cpp     ALGO_ILOG("[%s:%s]: CompleteDelete: ActionInProgress=%s", m_name, GetOrderIDString(), USER_ACTION_STR[to_underlying(GetActionInProgress())]);
parentorder.cpp     ALGO_ILOG("[%s:%s]: CompletePause: ActionInProgress=%s", m_name, GetOrderIDString(), USER_ACTION_STR[to_underlying(GetActionInProgress())]);
parentorder.cpp         ALGO_WLOG("[%s:%s] CompletePause: Failed to promote cl_ord_id params: " "error=%s ", m_name, GetOrderIDString(), TTSDK_ERROR_STR[ttsdk_error]);
parentorder.cpp         ALGO_ILOG("[%s:%s] CompletePause: Promoted cl_ord_id params: cl_ord_id=%llu orig_cl_ord_id=%llu", m_name, GetOrderIDString(), cl_ord_id, orig_cl_ord_id);
parentorder.cpp     ALGO_ILOG("[%s:%s]: RejectAction: " "ActionInProgress=%s " "reason=%s", m_name, GetOrderIDString(), USER_ACTION_STR[to_underlying(GetActionInProgress())], message);
parentorder.cpp     ALGO_ILOG("[ParentOrder:%s]: UpdateParamsForSyncChange:" " requested_qty=%0.8f" " requested_prc=%0.8f" " requested_working_qty=%0.8f" " new_qty=%0.8f" " new_prc=%0.8f" " new_working_qty=%0.8f", GetOrderIDString(), new_order_qty, new_order_prc, working_qty, GetOrderQuantity(), GetLimitPrice(), GetWorkingQuantity());
parentorder.cpp         ALGO_ILOG("[%s:%s]: SendFill sending update to account for overfill." " cum_fill_qty=%0.8f" " fill_qty=%0.8f" " OQ=%0.8f" " new_ord_qty=%0.8f", m_name, GetOrderIDString(), m_cum_fill_qty, fill_qty, GetOrderQuantity(), new_ord_qty);
parentorder.cpp     ALGO_ILOG("[%s:%s]: SendFill." " fill_qty=%0.8f " " fill_price=%0.8f " " cum_qty=%0.8f " " OQ=%0.8f " "child_fill=[order_id=%s, " "order_sequence=%llu, " "trade_date=%llu, ] " "fills_grp_size=%zu serialized_size=%zu ", m_name, GetOrderIDString(), fill_qty, fill_price, m_cum_fill_qty, GetOrderQuantity(), child_id.to_string(), order_sequence, trade_date, out_params->fills_grp.fills_grp_size, out_params->fills_grp.struct_size);
parentorder.cpp             ALGO_ILOG("[%s:%s]: SendFill: Suppressed scheduling a (redundant) stop since algo is already stopping. " "action_in_progress=%s", m_name, GetOrderIDString(), USER_ACTION_STR[to_underlying(action_in_progress)]);
parentorder.cpp         ALGO_ILOG("[%s:%s]: SendUpdate." " force_send=%d" " wq=%0.8f" " disp_qty=%0.8f" " oq=%0.8f" " ot=%s" " tif=%s" " synth_status=%s" " last_wq=%0.8f" " last_disp_qty=%0.8f" " last_oq=%0.8f" " last_ot=%s" " last_tif=%s" " last_synth_status=%s", m_name, GetOrderIDString(), force_send, working_qty, display_qty, GetOrderQuantity(), TTSDK_OrderTypeToString((ttsdk_order_type)GetType()), TTSDK_TIFToString((ttsdk_time_in_force)GetTIF()), TTSDK_SYNTH_STATUS_STR[GetSynthStatus()], m_lastUpdate.working_quantity, m_lastUpdate.display_quantity, m_lastUpdate.order_quantity, TTSDK_OrderTypeToString((ttsdk_order_type)m_lastUpdate.orderType), TTSDK_TIFToString((ttsdk_time_in_force)m_lastUpdate.time_in_force), TTSDK_SYNTH_STATUS_STR[m_lastUpdate.synth_status]);
parentorder.cpp     ALGO_ILOG("[%s:%s] RequestFail." " reason=%s", m_name, GetOrderIDString(), msg);
parentorder.cpp     ALGO_ILOG("[%s:%s] OnError." " error=%s" " current_action=%s" " synth_status=%s", m_name, GetOrderIDString(), std::string(error), ACTIVITY_BLOCK_STR[static_cast<unsigned char>(m_activityBlockedReason)], TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]);
parentorder.cpp             ALGO_ILOG("[%s:%s] ignore tick_size_change. synth_status=%s.", m_name, GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[current_synth_status]);
parentorder.cpp                 ALGO_ILOG("[%s:%s] Handle tick_size_change: Re-Download instrument." " synth_status=%s" " tick_table_id=%llu" " new_tick_table_id=%llu" " count=%u" " new_count=%u" " tick_size=%lf" " new_tick_size=%lf", m_name, GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[current_synth_status], before_tick_table_id, (reinterpret_cast<ttsdk_instr_data*>(m_instr))->tick_table_id, before_count, m_instr_snap->tick_table.count, before_tick_size, m_instr_snap->tick_size);
parentorder.cpp     ALGO_ILOG("[%s:%s] SetActivityBlockedReason. " "old=%s " "new=%s", m_name, GetOrderIDString(), ACTIVITY_BLOCK_STR[static_cast<unsigned char>(m_activityBlockedReason)], ACTIVITY_BLOCK_STR[static_cast<unsigned char>(reason)]);
parentorder.cpp     ALGO_ILOG(ss.str());
parentorder.cpp     ALGO_ILOG("[%s:%s] SetActionInProgress. " " old=%s" " new=%s", m_name, GetOrderIDString(), USER_ACTION_STR[to_underlying(m_action_in_progress)], USER_ACTION_STR[to_underlying(action)]);
parentorder.cpp     ALGO_ILOG("[%s:%s] ClearActionInProgress. last_action=%s", m_name, GetOrderIDString(), USER_ACTION_STR[to_underlying(last)]);
parentorder.cpp         ALGO_ILOG("[%s:%s] Clear ChangeSubTask " "current=%s ", m_name, GetOrderIDString(), CHANGE_SUBTASK_STR[to_underlying(m_change_subtask)]);
parentorder.cpp         ALGO_ILOG("[%s:%s] Set ChangeSubTask " "current=%s " "new=%s ", m_name, GetOrderIDString(), CHANGE_SUBTASK_STR[to_underlying(m_change_subtask)], CHANGE_SUBTASK_STR[to_underlying(task)]);
parentorder.cpp         ALGO_ILOG("[%s:%s] Clear DeletionSubTask " "current=%s ", m_name, GetOrderIDString(), DELETION_SUBTASK_STR[to_underlying(m_deletion_sub_task)]);
parentorder.cpp         ALGO_ILOG("[%s:%s] Set DeletionSubTask " "current=%s " "new=%s ", m_name, GetOrderIDString(), DELETION_SUBTASK_STR[to_underlying(m_deletion_sub_task)], DELETION_SUBTASK_STR[to_underlying(task)]);
parentorder.cpp         ALGO_ILOG("[%s:%s] Clear PauseSubTask " "current=%s ", m_name, GetOrderIDString(), PAUSE_SUBTASK_STR[to_underlying(m_pause_sub_task)]);
parentorder.cpp         ALGO_ILOG("[%s:%s] Set PauseSubTask " "current=%s " "new=%s ", m_name, GetOrderIDString(), PAUSE_SUBTASK_STR[to_underlying(m_pause_sub_task)], PAUSE_SUBTASK_STR[to_underlying(task)]);
parentorder.cpp         ALGO_ILOG("[%s:%s] Clear ETAGoToMarketSubTask." " current=%s", m_name, GetOrderIDString(), ETA_GOTOMARKET_SUBTASK_STR[to_underlying(m_eta_gotomarket_sub_task)]);
parentorder.cpp         ALGO_ILOG("[%s:%s] Set ETAGoToMarketSubTask." " current=%s" " new=%s", m_name, GetOrderIDString(), ETA_GOTOMARKET_SUBTASK_STR[to_underlying(m_eta_gotomarket_sub_task)], ETA_GOTOMARKET_SUBTASK_STR[to_underlying(task)]);
parentorder.cpp     ALGO_ILOG("[%s:%s] RecoverySubTask " "current=%s " "new=%s ", m_name, GetOrderIDString(), RECOVERY_SUBTASK_STR[to_underlying(m_recovery_subtask)], RECOVERY_SUBTASK_STR[to_underlying(task)]);
parentorder.cpp     ALGO_ILOG("[%s:%s] ResumeSubTask " "current=%s " "new=%s ", m_name, GetOrderIDString(), RESUME_SUBTASK_STR[to_underlying(m_resume_subtask)], RESUME_SUBTASK_STR[to_underlying(task)]);
parentorder.cpp     ALGO_ILOG("[%s:%s] SetForfeitRecovery: " "new_val=%d " "reason=%s", m_name, GetOrderIDString(), new_val, reason);
parentorder.cpp     ALGO_ILOG("[%s:%s] SetForfeitResume: " "new_val=%d " "reason=%s", m_name, GetOrderIDString(), new_val, reason);
parentorder.cpp         ALGO_ILOG("[%s:%s] CheckOTTIF encountered a synthetic instrument." " instrument_id=%llu" " name=%s", m_name, GetOrderIDString(), GetInstrID(), instr_data->name);
parentorder.cpp         ALGO_ELOG("[%s:%s] CheckOTTIF encountered instrument with no product!" " instrument_id=%llu" " product_id=%llu" " name=%s", m_name, GetOrderIDString(), GetInstrID(), instr_data->instr_snap.product_id, instr_data->name);
parentorder.cpp         ALGO_WLOG("[%s:%s] CheckOTTIF failed to find OTTIF but SSE will start anyway! " " product_id=%llu" " required_ottif=%s", m_name, GetOrderIDString(), instr_data->instr_snap.product_id, required_ottif_str);
parentorder.cpp             ALGO_ILOG("[%s:%s] CheckOTTIF check passed." " required_ottif=%s", m_name, GetOrderIDString(), required_ottif_str);
parentorder.cpp     ALGO_ILOG("[%s:%s] CheckOTTIF check failed." " product_id=%llu" " symbol=%s" " supported_ottif=[%s]" " required_ottif=%s", m_name, GetOrderIDString(), instr_data->instr_snap.product_id, instr_data->product->symbol, tt::algoutil::print::ToString(instr_data->product->ottif.entries), required_ottif_str);
parentorder.cpp     ALGO_WLOG("[%s:%s] OnChildResurrected: Child order (order_id=%s) resurrected unexpectedly! Failing algo!", m_name, GetOrderIDString(), childOrder->GetOrderIDString());
parentorder.cpp         ALGO_ILOG("[%s:%s] OnChildOrderEvent: Receive Xfer Full Fill", m_name, GetOrderIDString());
parentorder.cpp         ALGO_ILOG("[%s:%s] ProcessPendingChangeTasks: Empty",m_name,GetOrderIDString());
parentorder.cpp             ALGO_WLOG("[%s:%s] ProcessPendingChangeTasks: task=None",m_name,GetOrderIDString());
parentorder.cpp             ALGO_ILOG("[%s:%s] ProcessPendingChangeTasks: task=ChangeChildren",m_name,GetOrderIDString());
parentorder.cpp             ALGO_ILOG("[%s:%s] ProcessPendingChangeTasks: task=ChangePositionReserve",m_name,GetOrderIDString());
parentorder.cpp         ALGO_ELOG("[%s:%s] ChangePositionReserve: m_childPR=nullptr",m_name,GetOrderIDString());
parentorder.cpp     ALGO_ILOG("[%s:%s] HandleUpdate:SetChangeSubTasks: " "[currentPrc=%0.8f " "requestPrc=%0.8f] " "[currentQty=%0.8f " "requstQty=%0.8f] " "pending_changes=%s ", m_name, GetOrderIDString(), currentPrice, requestPrice, currentQty, requestQty, std::to_string(m_pending_change_subtasks));
parentorder.cpp         ALGO_DLOG("[%s:%s] CheckAverageTradeSize: Exempt!", m_name, GetOrderIDString());
parentorder.cpp         ALGO_DLOG("[%s:%s] UpdateAndCheckMaxOrderRate: Exempt!", m_name, GetOrderIDString());
parentorder.cpp     ALGO_ILOG("%s", ss.str());
slicerparent.cpp         ALGO_ILOG("[%s:%s] OnScheduledEvent: CompleteSlicerActionAsDelete fired", m_name, GetOrderIDString());
slicerparent.cpp     ALGO_ILOG("[%s:%s] OnChildAdd. limitPrc=%0.8f OQ=%0.8f WQ=%0.8f", m_name, GetOrderIDString(), limitPrice, orderQuantity, workingQuantity);
slicerparent.cpp     ALGO_ILOG("[%s:%s] OnChildReplace. limitPrc=%0.8f OQ=%0.8f WQ=%0.8f external=%d requestsPending=%d", m_name, GetOrderIDString(), limitPrice, orderQuantity, workingQuantity, external, requestsPending);
slicerparent.cpp     ALGO_ILOG("[%s:%s] OnChildCancel." " order_id=%s" " external=%i" " GetActionInProgress=%s" " any_child_inflight=%d", m_name, GetOrderIDString(), childOrder->GetOrderIDString(), external, USER_ACTION_STR[to_underlying(GetActionInProgress())], isAnyChildInflight);
slicerparent.cpp             ALGO_ILOG("[%s:%s] OnChildCancel. Setting change to stop when completed." " req_ord_qty=%0.8f" " cum_filled_qty=%0.8f", m_name, GetOrderIDString(), new_ord_qty, cum_filled);
slicerparent.cpp     ALGO_ELOG("[%s:%s] OnChildRequestFailure." " requests_pending=%d" " status_flags=[%s%s%s%s]" " timeout=%d" " action_in_progress=%d", m_name, GetOrderIDString(), requests_pending, status_flags & ttsdk_external_order_event ? "external_order_event|" : "", status_flags & ttsdk_risk_reject_event ? "risk_reject_event|" : "", status_flags & ttsdk_max_order_rate_reject_event ? "max_order_rate_reject_event|" : "", status_flags & ttsdk_order_download_failed_event ? "order_download_failed_event|" : "", timeout, GetActionInProgress());
slicerparent.cpp     ALGO_ELOG("[%s:%s] OnChildReject. external=%d requests_pending=%d message=%s action_in_progress=%d", m_name, GetOrderIDString(), external, requestsPending, (message != nullptr) ? std::string(message) : "", GetActionInProgress());
slicerparent.cpp     ALGO_ILOG("[%s:%s] HandleUpdate." " result=%s", m_name, GetOrderIDString(), TTSDK_ERROR_STR[result]);
slicerparent.cpp     ALGO_ILOG("[%s:%s] HandleActionFinished." " perform_pending=%d" " last_action=%s" " was_action_successful=%s", m_name, GetOrderIDString(), performPending, USER_ACTION_STR[to_underlying(lastAction)], wasActionSuccessful ? "true" : "false");
slicerparent.cpp         ALGO_ILOG("[%s:%s] SendQtySafeUpdate: Increased parent qty." " old_qty=%0.8f" " new_qty=%0.8f" " placed_qty=%0.8f", m_name, GetOrderIDString(), orderQty, newOrderQty, placedQty);
slicerparent.cpp                 ALGO_ILOG("[%s:%s] MergeLeftoverAction: No quantity for next slice, nothing to merge to.", m_name, GetOrderIDString());
slicerparent.cpp                 ALGO_ELOG("[%s:%s] MergeLeftoverAction: Failed to change order." " error=%s", m_name, GetOrderIDString(), std::string(TTSDK_ORDER_ERR_STR[error]));
slicerparent.cpp     ALGO_ILOG("[%s:%s] PayUpLeftoverAction: called for child orders size=%zu", m_name, GetOrderIDString(), m_childOrders.size());
slicerparent.cpp             ALGO_ELOG("[%s:%s] PayUpLeftoverAction: child failed to apply leftover." " error=%s", m_name, GetOrderIDString(), std::string(TTSDK_ORDER_ERR_STR[error]));
slicerparent.cpp     ALGO_ILOG("[%s:%s] GoToMarketLeftoverAction: called for child orders size=%zu", m_name, GetOrderIDString(), m_childOrders.size());
slicerparent.cpp             ALGO_ELOG("[%s:%s] GoToMarketLeftoverAction: child failed to apply leftover." " error=%s", m_name, GetOrderIDString(), std::string(TTSDK_ORDER_ERR_STR[error]));
slicerparent.cpp     ALGO_ILOG("[%s:%s] LeaveLeftoverAction: called for child orders size=%zu", m_name, GetOrderIDString(), m_childOrders.size());
slicerparent.cpp             ALGO_ELOG("[%s:%s] LeaveLeftoverAction: child failed to apply leftover." " error=%s", m_name, GetOrderIDString(), std::string(TTSDK_ORDER_ERR_STR[error]));
slicerparent.cpp         ALGO_ILOG("[%s:%s] ApplyLeftoverAction: UserAction::Change in progress, skip adding slice", m_name, GetOrderIDString());
slicerparent.cpp         ALGO_ILOG("[%s:%s] ApplyLeftoverAction: UserAction::Delete in progress, skip adding slice", m_name, GetOrderIDString());
slicerparent.cpp         ALGO_ILOG("[%s:%s] ApplyLeftoverAction: UserAction::Pause in progress, skip adding slice", m_name, GetOrderIDString());
slicerparent.cpp     ALGO_ILOG("[%s:%s] ApplyLeftoverAction." " action=%s" " child_order_count=%zu", m_name, GetOrderIDString(), LEFT_OVER_ACTION_STR[to_underlying(action)], m_childOrders.size());
slicerparent.cpp     ALGO_ILOG("[%s:%s] ScheduleCompleteActionAsDelete", m_name, GetOrderIDString());
slicerparent.cpp         ALGO_ILOG("[%s:%s] ResumeWorking: Child Info: " "order_ptr=%p " "order_id=%s " "order_type=%s " "order_side=%d " "order_qty=%0.8f " "filled_qty=%0.8f " "order_working_qty=%0.8f " "order_prc=%0.8f " "order_trg_prc=%0.8f " "time_sent=%llu " "curr_childOrders_size=%zu ", m_name, GetOrderIDString(), static_cast<void*>(childOrder.get()), childOrder->GetOrderIDString(), TTSDK_OrderTypeToString(childOrder->GetType()), childOrder->GetSide(), childOrder->GetOrderQty(), childOrder->GetFilledQty(), childOrder->GetWorkingQty(), childOrder->GetLimitPrice(), childOrder->GetTriggerPrice(), childOrder->GetTimeSent(), m_childOrders.size());
slicerparent.cpp     ALGO_ILOG("[%s:%s] ResumeWorking Completed." " order_qty=%0.8f" " orig_order_qty=%0.8f" " limit_prc=%0.8f" " trg_prc=%0.8f" " synth_status=%d" " cum_filled_qty=%0.8f" " orig_cum_filled_qty=%0.8f" " ladder_display=%d" " order_type=%s" " total_order_qty=%0.8f" " total_cum_fill_qty=%0.8f" " total_placed_qty=%0.8f" " childOrders_size=%zu", m_name, GetOrderIDString(), GetOrderQuantity(), orig_order_qty, GetLimitPrice(), GetTriggerPrice(), GetSynthStatus(), GetCumFillQuantity(), orig_cum_fill_qty, GetLadderDisplay(), TTSDK_OrderTypeToString(GetType()), totalOrderQty, totalCumFillQty, GetPlacedQuantity(), m_childOrders.size());
slicerparent.cpp                         ALGO_ELOG("[%s:%s] ReduceQuantity: DeleteOrder failed. error=%s", m_name, GetOrderIDString(), TTSDK_ORDER_ERR_STR[delete_error]);
slicerparent.cpp                         ALGO_ELOG("[%s:%s] ReduceQuantity: Failed to Change/Delete child order. error=%s", m_name, GetOrderIDString(), TTSDK_ORDER_ERR_STR[error]);
slicerparent.cpp             ALGO_ILOG("[%s:%s] PlaceSliceOrder: encountered a zero slice. Skipping.", m_name, GetOrderIDString());
slicerparent.cpp                 ALGO_ELOG("[%s:%s] PlaceSliceOrder: Failed to place slice order!" " error=\"%s\"" " reason=\"%s\"" " order_type=%s", m_name, GetOrderIDString(), error_str, failure_reason, TTSDK_OrderTypeToString(order_type));
slicerparent.cpp             ALGO_ILOG("[%s:%s] PlaceSliceOrder." " order_type=%s" " limitPrc=%0.8f" " child_OQ=%0.8f", m_name, GetOrderIDString(), TTSDK_OrderTypeToString(order_type), price, new_qty);
slicerparent.cpp             ALGO_ELOG("[%s:%s] PlaceSliceOrder: Failed to add order" " order_type=%s" " limitPrc=%0.8f" " child_OQ=%0.8f" " error=%s", m_name, GetOrderIDString(), TTSDK_OrderTypeToString(order_type), price, new_qty, error_str);
options_delta_service.cpp         ALGO_ELOG("OptionsDeltaService: not able to start without " "greeks_obv_url, options_delta_polling_miliseconds and chef_environment");
options_delta_service.cpp         ALGO_ELOG( "OptionsDeltaService: Subscription not allowed in current state for %s for options_instrument_id=%llu use_id=%llu", subscriberID, std::get<0>(subscriptionID), std::get<1>(subscriptionID));
options_delta_service.cpp     ALGO_ILOG("OptionsDeltaService: Received subscription for client_id=%s, options_instrument_id=%llu user_id=%llu", subscriberID, std::get<0>(subscriptionID), std::get<1>(subscriptionID));
options_delta_service.cpp     ALGO_ILOG("OptionsDeltaService: Starting");
options_delta_service.cpp     ALGO_ILOG("OptionsDeltaService: Stopped");
options_delta_service.cpp             ALGO_ILOG("OptionsDeltaService: Ending subscription for client_id=%s, options_instrument_id=%llu use_id=%llu", subscriberID, std::get<0>(subscriptionID), std::get<1>(subscriptionID));
options_delta_service.cpp     ALGO_ELOG("OptionsDeltaService: Could not find subscription for client_id=%s, options_instrument_id=%llu use_id=%llu", subscriberID, std::get<0>(subscriptionID), std::get<1>(subscriptionID));
options_delta_service.cpp     ALGO_ILOG("OptionsDeltaService: Stoping with %llu items in queue.", m_taskQueue->size());
options_delta_service.cpp         ALGO_WLOG("OptionsDeltaService: count=%lu delta-webrequests and fanout total_duration=%lu", m_optionsDeltaSubscriptions.size(), (end_time - start_time));
options_delta_service.cpp             ALGO_WLOG("OptionsDeltaService: zero delta for:" " url='%s'" " response=%s", url.to_std(), response);
options_delta_service.cpp             ALGO_WLOG("OptionsDeltaService: failed to get data for" " url='%s'" " http_code=%ld" " response='%s'" " failure_reason='%s'", url, deltaObserver.http_code, deltaObserver.response, deltaObserver.failure_reason);
options_delta_service.cpp         ALGO_ELOG("OptionsDeltaService: request failed: Exception caught." " url=%s" " error=%s", url, errorMsg);
options_delta_service.cpp         ALGO_ELOG("OptionsDeltaService: request failed: Unknown exception caught." " url=%s", url);
obvparent.cpp         ALGO_ELOG("[OBV:%s]:ValidateStart: invalid Vol=%f", GetOrderIDString(), volatility);
obvparent.cpp         ALGO_ELOG("[OBV:%s]:ValidateStart: Market type=%s not supported by OBV", GetOrderIDString(), TTSDK_OrderTypeToString(GetType()));
obvparent.cpp         ALGO_ELOG("[OBV:%s]:ValidateStart: No underlying instrument instr=%s[%s]", GetOrderIDString(), instr_data->name, instr_data->alias);
obvparent.cpp         ALGO_ELOG("[OBV:%s]:ValidateStart: Failed to download underlying instrument underlying_instr_id=%llu error=%s", GetOrderIDString(), instr_data->instr_snap.underlying_instr_id, TTSDK_ERROR_STR[download_error]);
obvparent.cpp     ALGO_ILOG("[OBV:%s]:ValidateStart: " "volatility=%f, " "underlying_instr_id=%llu " "underlying_tick=%0.8f ", GetOrderIDString(), m_volatility, instr_data->instr_snap.underlying_instr_id, m_underlying_tick);
obvparent.cpp     ALGO_ILOG("[OBV:%s] OnChildAdd: order_id=%s limitPrc=%0.8f OQ=%0.8f WQ=%0.8f", GetOrderIDString(), childOrder->GetOrderIDString(), limitPrice, orderQuantity, workingQuantity);
obvparent.cpp     ALGO_DLOG("[OBV:%s] OnChildReplace: child: order_id=%s LimitPrc=%0.8f OQ=%0.8f WQ=%0.8f external=%i " "requestsPending=%i Parent: CumQty=%0.8f OQ=%0.8f", GetOrderIDString(), childOrder->GetOrderIDString(), limitPrice, orderQuantity, workingQuantity, external, requestsPending, parentCumQty, parentOrdQty);
obvparent.cpp             ALGO_ILOG("[OBV:%s] OnChildReplace: Increased parent qty from %0.8f to %0.8f", GetOrderIDString(), parentOrdQty, newQuantity);
obvparent.cpp             ALGO_ILOG("[OBV:%s] OnChildReplace: Unexpected: " "external=%d, " "requestsPending=%d, " "parentOrdQty=%0.8f, " "workingQuantity=%0.8f", GetOrderIDString(), external, requestsPending, parentOrdQty, workingQuantity);
obvparent.cpp     ALGO_ILOG("[%s:%s] OnChildCancel: " "order_id=%s " "external=%i " "ActionInProgress=%s", GetName(), GetOrderIDString(), childOrder->GetOrderIDString(), external, USER_ACTION_STR[to_underlying(GetActionInProgress())]);
obvparent.cpp     ALGO_ILOG("[OBV:%s] OnChildFill: order_id=%s limitPrc=%0.8f OQ=%0.8f WQ=%0.8f FQ=%0.8f FlPrc=%0.8f fill_type=%s", GetOrderIDString(), child_order->GetOrderIDString(), limit_price, order_quantity, working_quantity, fill_quantity, fill_price, FILL_TYPE_STR[to_underlying(fill_type)]);
obvparent.cpp     ALGO_ILOG("[OBV:%s] OnChildRequestFailure: order_id=%s, timeout=%d", GetOrderIDString(), childOrder->GetOrderIDString(), timeout);
obvparent.cpp     ALGO_ILOG("[OBV:%s] OnChildReject: order_id=%s, external=%d requestsPending=%d message=%s ", GetOrderIDString(), childOrder->GetOrderIDString(), external, requestsPending, std::string(message));
obvparent.cpp         ALGO_ELOG("[OBV:%s] OnPriceUpdate: price_snap=nullptr, price_sub=%llu, underlying=%s, underlying_id=%llu", GetOrderIDString(), price_sub, underlying_instr->instr_snap.alias, underlying_instr->instr_snap.instr_id);
obvparent.cpp             ALGO_ELOG("[OBV:%s]OnPriceUpdate: FuturePx=NaN", GetOrderIDString());
obvparent.cpp         ALGO_ILOG("[OBV:%s]OnPriceUpdate: Scheduled first Greek request. lo=%0.8f hi=%0.8f", GetOrderIDString(), lo, hi);
obvparent.cpp             ALGO_DLOG( "[OBV:%s] Buy/Call bid=%4.3f", GetOrderIDString(), reference);
obvparent.cpp             ALGO_DLOG( "[OBV:%s] Sell/Call ask=%4.3f", GetOrderIDString(), reference);
obvparent.cpp             ALGO_DLOG( "[OBV:%s] Buy/Put ask=%4.3f", GetOrderIDString(), reference);
obvparent.cpp             ALGO_DLOG( "[OBV:%s] Sell/Put bid=%4.3f", GetOrderIDString(), reference);
obvparent.cpp         ALGO_DLOG("[OBV:%s] no Theo map yet", GetOrderIDString());
obvparent.cpp         ALGO_ELOG("[OBV:%s]EvaluateChildOrder: FuturePx=NaN", GetOrderIDString());
obvparent.cpp     ALGO_DLOG("[OBV:%s]EvaluateChildOrder: futurePx=%f", GetOrderIDString(), futurePx); ttsdk_instr_data* option_instr = reinterpret_cast<ttsdk_instr_data*>(GetInstr());
obvparent.cpp             ALGO_ELOG("[OBV:%s]EvaluateChildOrder: Failed to get Theo with futurePx=%4.3f", GetOrderIDString(), futurePx);
obvparent.cpp         ALGO_DLOG("[OBV:%s]futurePx=%4.3f, theo=%4.3f, vol=%4.3f", GetOrderIDString(), futurePx, theoIter->second, m_volatility);
obvparent.cpp             ALGO_ELOG("[OBV:%s]EvaluateChildOrder: m_currTheo=NaN", GetOrderIDString());
obvparent.cpp                     ALGO_ILOG("[OBV:%s]Add Order " "option=%s " "option_id=%llu " "future=%s " "future_id=%llu " "futurePx=%4.3f " "volatility=%4.3f " "Add [qty=%4.3f @ theo=%4.3f]", GetOrderIDString(), option_instr->alias, option_instr->instr_snap.instr_id, future_instr->alias, future_instr->instr_snap.instr_id, futurePx, m_volatility, GetOrderQuantity(), m_currTheo);
obvparent.cpp                     ALGO_ELOG("[OBV:%s] Failed to add order, error=%s", GetOrderIDString(), TTSDK_ORDER_ERR_STR[add_error]);
obvparent.cpp                         ALGO_ELOG("[OBV:%s] Failed to change child, error=%s", GetOrderIDString(), TTSDK_ORDER_ERR_STR[change_error]);
obvparent.cpp                         ALGO_ILOG("[OBV:%s]ChangeOrder " "option=%s " "option_id=%llu " "future=%s " "future_id=%llu " "futurePx=%4.3f " "volatility=%4.3f " "Chg [qty=%4.3f @ current_theo=%4.3f prev_theo=%4.3f]", GetOrderIDString(), option_instr->alias, option_instr->instr_snap.instr_id, future_instr->alias, future_instr->instr_snap.instr_id, futurePx, m_volatility, GetOrderQuantity(), m_currTheo, m_prevTheo);
obvparent.cpp                     ALGO_DLOG("[OBV:%s]NOOP. Theo did not change. m_currTheo=%4.3f", GetOrderIDString(), m_currTheo);
obvparent.cpp         ALGO_ILOG("[OBV:%s] [%4.3f] = %4.3f", GetOrderIDString(), iter.first, iter.second);
obvparent.cpp     ALGO_ILOG("[OBV:%s] Theo Map updated: size=%u, Lo=%4.3f, hi=%4.3f", GetOrderIDString(), m_mapTheos.size(), m_mapPriceLo, m_mapPriceHi);
obvparent.cpp     ALGO_ELOG("[OBV:%s] OnGreekErrorCB: error=%s", GetOrderIDString(), error);
obvparent.cpp         ALGO_ILOG("[OBV:%s]: StartWorking about to subscribe Future: instr_id=%llu", GetOrderIDString(), underlying_instr->instr_snap.instr_id);
obvparent.cpp         ALGO_ELOG("[OBV:%s]: StartWorking Failed to open price subscription instr=%llu error=%s ", GetOrderIDString(), underlying_instr->instr_snap.instr_id, TTSDK_ERROR_STR[error_code]);
obvparent.cpp         ALGO_WLOG("[OBV:%s] HandleUpdate: Ignore price change", GetOrderIDString());
obvparent.cpp         ALGO_ILOG("[OBV:%s] HandleUpdate: No qty change", GetOrderIDString());
obvparent.cpp         ALGO_ILOG("[OBV:%s] HandleUpdate: requstQty=%0.8f Qty=%0.8f, but no child order yet", GetOrderIDString(), requestQty, GetOrderQuantity());
obvparent.cpp     ALGO_ILOG("[OBV:%s] HandleUpdate: requstQty=%0.8f Qty=%0.8f", GetOrderIDString(), requestQty, GetOrderQuantity());
obvparent.cpp         ALGO_ELOG("[OBV:%s] HandleUpdate failed to change order. error=%s", GetOrderIDString(), TTSDK_ORDER_ERR_STR[order_error]);
obvparent.cpp             ALGO_DLOG("[OBV:%s] Current bounds [%4.3f, %4.3f, %4.3f], NOT Fetching. lo_bound=%4.3f, hi_bound=%4.3f", GetOrderIDString(), m_mapPriceLo, reference, m_mapPriceHi, lo_bound, hi_bound);
obvparent.cpp         ALGO_WLOG("[OBV:%s] Current bounds [%4.3f, %4.3f, %4.3f], Can not Fetch [%4.3f, %4.3f]", GetOrderIDString(), m_mapPriceLo, reference, m_mapPriceHi, futLo, futHi);
obvparent.cpp     ALGO_ILOG("[OBV:%s] Current bounds [%4.3f, %4.3f, %4.3f], Now schedule Greek request [%4.3f, %4.3f]", GetOrderIDString(), m_mapPriceLo, reference, m_mapPriceHi, futLo, futHi);
obvparent.cpp     ALGO_ILOG("[OBV:%s] does not care about option price error=%s", GetOrderIDString(), std::string(error));
average_trade_size_checker.cpp     ALGO_ILOG("AverageTradeSizeChecker: ComputeMaxParticipationRate: inst_id=%s: " "average_trade_size=%f " "m_max_child_slice_size=%f " "m_max_participation_rate=%f", m_algo_inst_id, average_trade_size, m_max_child_slice_size, m_max_participation_rate);
average_trade_size_checker.cpp         ALGO_DLOG("AverageTradeSizeChecker: Check: inst_id=%s: Skipping since m_max_participation_rate is zero", m_algo_inst_id);
average_trade_size_checker.cpp     ALGO_ILOG("AverageTradeSizeChecker: Check: inst_id=%s: " "order_qty=%f " "m_max_participation_rate=%f " "qty_acceptable=%s", m_algo_inst_id, order_qty, m_max_participation_rate, std::string(qty_acceptable ? "true" : "false"));
average_trade_size_checker.cpp     ALGO_ILOG("DownloadAverageTradeSize: inst_id=%s: Starting average trade size download: " "uri=%s", algo_instance_id, uri.str());
average_trade_size_checker.cpp         ALGO_ELOG("DownloadAverageTradeSize: inst_id=%s: Average trade size download failed: " "exception=%s", algo_instance_id, e.what());
average_trade_size_checker.cpp     ALGO_ILOG("DownloadAverageTradeSize: inst_id=%s: Average trade size download succeeded: " "response=%s", algo_instance_id, response);
average_trade_size_checker.cpp             ALGO_ELOG("ParseAverageTradeSize: inst_id=%s: [result][status] missing!", algo_instance_id);
average_trade_size_checker.cpp             ALGO_ELOG("ParseAverageTradeSize: inst_id=%s: [result][status][stat] missing!", algo_instance_id);
average_trade_size_checker.cpp             ALGO_ELOG("ParseAverageTradeSize: inst_id=%s: [result][status][stat]=%s!", algo_instance_id, stat);
average_trade_size_checker.cpp             ALGO_ELOG("ParseAverageTradeSize: inst_id=%s: [result][pd] missing!", algo_instance_id);
average_trade_size_checker.cpp             ALGO_ELOG("ParseAverageTradeSize: inst_id=%s: [result][pd][pi] missing!", algo_instance_id);
average_trade_size_checker.cpp             ALGO_ELOG("ParseAverageTradeSize: inst_id=%s: [result][pd][pi] was empty!", algo_instance_id);
average_trade_size_checker.cpp                 ALGO_ILOG("ParseAverageTradeSize: inst_id=%s: No trades during the lookback period, disabling check: " "average_trade_size_string=%s " "average_trade_size=%f", algo_instance_id, average_trade_size_string, average_trade_size);
average_trade_size_checker.cpp             ALGO_ILOG("ParseAverageTradeSize: inst_id=%s: Setting average trade size: " "average_trade_size_string=%s " "average_trade_size=%f", algo_instance_id, average_trade_size_string, average_trade_size);
average_trade_size_checker.cpp         ALGO_ELOG("ParseAverageTradeSize: inst_id=%s: Exception=[%s] thrown during parse!", algo_instance_id, e.what());
average_trade_size_checker.cpp     ALGO_ILOG("ParseAverageTradeSize: inst_id=%s: Average trade size parse succeeded: " "average_trade_size=%f", algo_instance_id, average_trade_size);
timeslicer.cpp         ALGO_ELOG("[%s:%s] Invalid Child TIF" " child_tif=%d", m_name, GetOrderIDString(), child_tif);
timeslicer.cpp             ALGO_ILOG("[TimeSlicer]OnScheduleEvent - ScheduleSliceTimer");
timeslicer.cpp     ALGO_ILOG("[TimerSlicer]OnScheduledEvent %d", id);
timeslicer.cpp             ALGO_ILOG("[TimeSlicer]OnChildCancel ScheduleTimer");
timeslicer.cpp         ALGO_DLOG( "[TimeSlicer:%s] StartWorking failed to create timer error=%s", GetOrderIDString(), std::string(e.what()) );
timeslicer.cpp         ALGO_ILOG("[TimeSlicer:%s] HandleUpdate: " "Qty increased and no timer armed, adding slice child_OQ=%i ", GetOrderIDString(), new_qty);
timeslicer.cpp             ALGO_WLOG( "[TimeSlicer:%s] ScheduleSliceTimer: Failed to arm timer interval=%u", GetOrderIDString(), interval_ms );
timeslicer.cpp             ALGO_DLOG( "[TimeSlicer:%s] ScheduleSliceTimer: Timer armed interval_ms=%u ", GetOrderIDString(), interval_ms );
timeslicer.cpp             ALGO_WLOG( "[HalfLifeTimer:%s] ScheduleHalfLifeTimer: Failed to arm half life timer interval=%u", GetOrderIDString(), interval_ms );
timeslicer.cpp             ALGO_DLOG( "[HalfLifeTimer:%s] ScheduleHalfLifeTimer: Half life timer armed interval_ms=%u ", GetOrderIDString(), interval_ms );
timeslicer.cpp     ALGO_DLOG( "[TimeSlicer:%s] OnStopAlgo: Stop SliceTimer", GetOrderIDString() );
timeslicer.cpp             ALGO_ILOG("[%s:%s] SendSuspendStatus on disconnect " "syn_status=%s", GetName(), GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[status]);
timeslicer.cpp                         ALGO_ILOG("[%s:%s] SendSuspendStatus on disconnect " "WAT=true and WAT trigger=false", GetName(), GetOrderIDString());
timeslicer.cpp                 ALGO_ILOG("[%s:%s] HandlePriceError: Disconnect Ignored " "All children WAT applied", GetName(), GetOrderIDString());
timeslicer.cpp                 ALGO_ILOG("[%s:%s] HandlePriceError: Disconnect Ignored " "HasWAT=%d; hasChild=%d", GetName(), GetOrderIDString(), hasWat, hasChild);
timeslicer.cpp             ALGO_ILOG("[%s:%s] HandlePriceError: Disconnect Ignored " "syn_status=%s", GetName(), GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[status]);
timeslicer.cpp         ALGO_ILOG("[%s:%s] No remaining qty to generate slice schedule", m_name, GetOrderIDString());
timeslicer.cpp         ALGO_WLOG("[%s:%s] Unable to generate slice schedule." " remaining_qty=%0.0f" " disc_qty=%0.0f", m_name, GetOrderIDString(), remaining_qty, disc_qty);
timeslicer.cpp         ALGO_ILOG("[%s:%s] Generated new slice schedule. %s", m_name, GetOrderIDString(), GetSliceSummary());
timeslicer.cpp         ALGO_WLOG("[%s:%s] ShouldContinueSlicing: Suppressing the sending of next slice and rearming slice timer because: " "synth_status=%s " "activity_blocked_reason=%s", m_name, GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[synth_status], ACTIVITY_BLOCK_STR[to_underlying(activity_blocked_reason)]);
timeslicer.cpp         ALGO_WLOG("[%s:%s] ShouldContinueSlicing: Suppressing the sending of next slice and rearming slice timer because: " "action_in_progress=%s", m_name, GetOrderIDString(), USER_ACTION_STR[to_underlying(action_in_progress)]);
tlparent.cpp         ALGO_ILOG("[TLParent:%s]: OnWorkingPriceUpdate: New lastTrailBasePrice price " "limit_price=%0.8f " "m_trailingTriggerBase=%0.8f " "pre_trail_base_price=%0.8f " "trailsUp=%d " "error=%s", GetOrderIDString(), limitPrice, m_trailingTriggerBase, prevTrailBase, trailsUp, TTSDK_ORDER_ERR_STR[order_error]);
tlparent.cpp         ALGO_ILOG("[%s:%s]: StartWorking: " "m_trailingTriggerBase=%0.8f " "trailsUp=%d ", m_name, GetOrderIDString(), m_trailingTriggerBase, trailsUp);
tlparent.cpp         ALGO_ELOG("[%s:%s] SetChangeSubTasks: Failed to update Base Trailing Price! " "Target Price will not be updated: " "error=%s " "m_targetNewPrice=%f (unchanged)", GetName(), GetOrderIDString(), error, m_targetNewPrice);
tlparent.cpp     ALGO_ILOG("[%s:%s] HandleUpdate: " " synth_status=%s" " childOrdersSize=%zd" " childPRExists=%s", GetName(), GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[GetSynthStatus()], m_childOrders.size(), m_childPR ? std::string("true") : std::string("false"));
tlparent.cpp     ALGO_ILOG("[%s:%s] HandleUpdate: Sending requests with the following" " (note: some fields may be invalid depending on the sequence):" " pending_change_subtasks=[%s]" " target_price=%0.8f" " target_qty=%0.8f" " target_pr_qty=%0.8f", GetName(), GetOrderIDString(), std::to_string(m_pending_change_subtasks), m_targetNewPrice, m_targetNewQty, m_targetPRQty);
tlparent.cpp     ALGO_ILOG("[%s:%s] HandleUpdate: ProcessPendingChangeTasks returned error=%s", GetName(), GetOrderIDString(), TTSDK_ERROR_STR[error]);
tlparent.cpp             ALGO_ILOG("[%s:%s] HandleUpdate: Updating LimitTicksAway " "currentLimitTicksAway=%d " "requestLimitTicksAway=%d ", GetName(), GetOrderIDString(), GetLimitTicksAway(), GetLimitTicksAway(request_params));
tlparent.cpp         ALGO_ILOG("[TLParent:%s] HandleActionFinished: Simulating price update for missed price", GetOrderIDString());
tlparent.cpp             ALGO_ILOG("[%s:%s] SendSuspendStatus on disconnect " "syn_status=%s", GetName(), GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[status]);
tlparent.cpp             ALGO_ILOG("[%s:%s] HandlePriceError: Disconnect Ignored " "syn_status=%s", GetName(), GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[status]);
price_drift_checker.cpp                  ALGO_WLOG("[parent:%s] order_id=%s has no original time sent!", existing_child->GetParentOrderIDString(), existing_child->GetOrderIDString());
price_drift_checker.cpp                          ALGO_WLOG("[parent:%s] order_id=%s has no limit price and " "can not be used for price drift check", existing_child->GetParentOrderIDString(), existing_child->GetOrderIDString());
price_drift_checker.cpp          ALGO_ILOG("[parent:%s] No referencable order " "rule=%s ", existing_children.front()->GetParentOrderIDString(), m_name);
price_drift_checker.cpp          ALGO_ELOG("[parent:%s] Failed Price Drift check " "rule=%s " "reference_order=%s " "reference_price=%0.8f " "new_price=%0.8f " "compare_details=[%s]", reference_order->GetParentOrderIDString(), m_name, reference_order->GetOrderIDString(), reference_order->GetLimitPrice(), new_price, details.str());
price_drift_checker.cpp          ALGO_ILOG("[parent:%s] Pass Price Drift check " "rule=%s " "reference_order=%s " "reference_price=%0.8f " "new_price=%0.8f " "compare_details=[%s]", reference_order->GetParentOrderIDString(), m_name, reference_order->GetOrderIDString(), reference_order->GetLimitPrice(), new_price, details.str());
max_order_rate_checker.cpp         ALGO_ELOG("[parent:%s] UpdateCheckDetails: check pointer was unexpectedly a nullptr, skipping!", m_algo_inst_id);
max_order_rate_checker.cpp         ALGO_DLOG("[parent:%s] UpdateCheckDetails: %s is not enabled, skipping!", m_algo_inst_id, CheckTypeToString(check->m_check_type));
max_order_rate_checker.cpp     ALGO_DLOG("[parent:%s] UpdateCheckDetails: Start - dump check details: %s", m_algo_inst_id, DebugDumpCheckDetails(*check));
max_order_rate_checker.cpp     ALGO_DLOG("[parent:%s] UpdateCheckDetails: Diff between [current] - [oldest]: " "current_time_ns=%llu " "oldest_time_ns=%llu " "diff=%llu", m_algo_inst_id, current_time_ns, oldest_time_ns, current_time_ns - oldest_time_ns);
max_order_rate_checker.cpp         ALGO_DLOG("[parent:%s] UpdateCheckDetails: Passed check! Diff is greater than 1ms!", m_algo_inst_id);
max_order_rate_checker.cpp         ALGO_DLOG("[parent:%s] UpdateCheckDetails: End - dump check details: %s", m_algo_inst_id, DebugDumpCheckDetails(*check));
max_order_rate_checker.cpp     ALGO_DLOG("[parent:%s] UpdateCheckDetails: Failed check! Diff is less than 1ms!", m_algo_inst_id);
max_order_rate_checker.cpp     ALGO_DLOG("[parent:%s] UpdateCheckDetails: End - dump check details: %s", m_algo_inst_id, DebugDumpCheckDetails(*check));
max_order_rate_checker.cpp         ALGO_ELOG("[parent:%s] Failed %s because: " "m_max_request_rate_violated=%s " "m_max_unsolicited_cancel_rate_violated=%s", m_algo_inst_id, CheckTypeToString(check_type), std::string(m_max_request_check.m_max_rate_violated ? "true" : "false"), std::string(m_max_unsolicited_cancel_check.m_max_rate_violated ? "true" : "false"));
somparentorder.cpp                 ALGO_WLOG("[%s:%s] ValidateStart failed to find OTTIF. Assuming that market orders are suppored" " product_id=%llu", m_name, GetOrderIDString(), instr_data->instr_snap.product_id);
somparentorder.cpp     ALGO_ILOG("EndTimeAction=%d, startTime=%llu endTime=%llu", GetEndTimeAction(), startTime, endTime);
somparentorder.cpp         ALGO_ILOG("[%s:%s] TrailingTrigger is Set", m_name, GetOrderIDString());
somparentorder.cpp     ALGO_ILOG("[%s:%s] ValidateStart: " "currentQty=%0.8f " "currentPrice=%0.8f " "orderType=%d ", m_name, GetOrderIDString(), GetOrderQuantity(), GetLimitPrice(), orderType);
somparentorder.cpp     ALGO_ILOG("[%s:%s] CheckForValidConfiguration: Validating requested config. requested_config=%s invalid_configs=%s", m_name, GetOrderIDString(), std::to_string(config), s_invalid_configs);
somparentorder.cpp         ALGO_WLOG("[%s:%s] CleanupChildrenAndFail." " error_msg=%s. " " should_cleanup_pr_child=%d " " should_cleanup_normal_children=%d " " send_cleanup_for=\"%s\"", m_name, GetOrderIDString(), error_msg, should_cleanup_pr_child, should_cleanup_normal_children, cleanup_pr_only ? "PR Child Only": "All Children");
somparentorder.cpp         ALGO_WLOG("[%s:%s] CleanupChildrenAndFail Leaving child orders. error_msg=%s", m_name, GetOrderIDString(), error_msg);
somparentorder.cpp     ALGO_ILOG("[%s:%s] TryResumeWorking: synth_status=%s", m_name, GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[synth_status]);
somparentorder.cpp         ALGO_ILOG("[%s:%s] TryResumeWorking: " "Forfeiting recovery and stopping algo because the user " "requested stop, or there was a price subscription error. " "should_forfeit_recovery=%s", m_name, GetOrderIDString(), GetForfeitRecovery() ? std::string("true") : std::string("false"));
somparentorder.cpp         ALGO_ILOG("[%s:%s] TryResumeWorking: " "Forfeiting resuming process and stopping algo because the user " "requested stop, or there was a price subscription error. " "should_forfeit_resume=%s", m_name, GetOrderIDString(), GetForfeitResume() ? std::string("true") : std::string("false"));
somparentorder.cpp         ALGO_ILOG("[%s:%s] TryResumeWorking:" " Blocked by activity. reason=%s", m_name, GetOrderIDString(), ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]);
somparentorder.cpp         ALGO_ILOG("[%s:%s] TryResumeWorking:" " Market is open, so calling ResumeWorking.", m_name, GetOrderIDString());
somparentorder.cpp                 ALGO_ILOG("[%s:%s] TryResumeWorking: Failed to un-suspend children - failing algo", m_name, GetOrderIDString());
somparentorder.cpp     ALGO_ILOG("[%s:%s] TryResumeWorking:" " Market is NOT open, so setting flag to retry on next price update.", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ILOG("[%s:%s] UnSuspendChildren: Skipping PR order: " "child=%p " "order_id=%s", m_name, GetOrderIDString(), (void*)childOrder.get(), childOrder->GetOrderIDString());
somparentorder.cpp             ALGO_ILOG("[%s:%s] UnSuspendChildren: Skipping non-working order: " "child=%p " "order_id=%s", m_name, GetOrderIDString(), (void*)childOrder.get(), childOrder->GetOrderIDString());
somparentorder.cpp             ALGO_ILOG("[%s:%s] UnSuspendChildren: Skipping order being deleted: " "child=%p " "order_id=%s", m_name, GetOrderIDString(), (void*)childOrder.get(), childOrder->GetOrderIDString());
somparentorder.cpp             ALGO_ELOG("[%s:%s] UnSuspendChildren: Failed to un-suspend this order: " "child=%p " "order_id=%s", m_name, GetOrderIDString(), (void*)childOrder.get(), childOrder->GetOrderIDString());
somparentorder.cpp         ALGO_ILOG("[%s:%s] UnSuspendChildren: Un-suspended this order: " "child=%p " "order_id=%s", m_name, GetOrderIDString(), (void*)childOrder.get(), childOrder->GetOrderIDString());
somparentorder.cpp     ALGO_ILOG("[%s:%s] UnSuspendChildren: Iterated through %zu children", m_name, GetOrderIDString(), m_childOrders.size());
somparentorder.cpp     ALGO_ILOG("[%s:%s] RecoverChildren: " "Downloading children to attempt recovery / resume: " "synth_status=%s", m_name, GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]);
somparentorder.cpp         ALGO_ILOG("[%s:%s] RecoverChildren: will attempt to delete PR child order (if any) because: " "is_sse_pr_enabled: %s " "SupportsPR: %s", m_name, GetOrderIDString(), env::instance().is_sse_pr_enabled() ? "true" : "false", SupportsPR() ? "true" : "false");
somparentorder.cpp         ALGO_ELOG("[%s:%s] OnRecoveredChildrenDownloaded: Neither Recovering nor Resuming - unexpected!", m_name, GetOrderIDString());
somparentorder.cpp     ALGO_ILOG("[%s:%s] CompleteActionAndStop: " "Completing a Change as a Stop because there are no more child orders working.", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ILOG("[%s:%s] CheckEndTimeActionProgress: Inflights still in progress." " child=%p" " order_id=%s" " status=%s", m_name, GetOrderIDString(), (void*)child.get(), child->GetOrderIDString(), child->InflightStatus());
somparentorder.cpp         ALGO_ILOG("[%s:%s] CheckEndTimeActionProgress: ETAGoToMarketSubTask is NONE, which is unexpected", m_name, GetOrderIDString());
somparentorder.cpp         ALGO_DLOG("[%s:%s] ParentOrderTestHarness: OnActionFinished: Sleeping for 15 seconds...", m_name, GetOrderIDString());
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnActionFinished." " pending_action=%s" " last_action=%s" " was_action_successful=%s", m_name, GetOrderIDString(), PendingActionToStr(GetPendingAction()), USER_ACTION_STR[to_underlying(lastAction)], wasActionSuccessful ? "true" : "false");
somparentorder.cpp         ALGO_ILOG("[%s:%s] HandleActionFinished: Conducting latent trigger check" " (suppressed earlier while action was in progress).", GetName(), GetOrderIDString());
somparentorder.cpp         ALGO_DLOG("[%s:%s] ParentOrderTestHarness: OnUpdateAlgo: Scheduling custom event: " "event_type=%u", m_name, GetOrderIDString(), GetTestHarness()->m_eventToScheduleInOnUpdateAlgo);
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnUpdateAlgo: Update request received " "currentQty=%0.8f " "newQty=%0.8f " "currentPrice=%0.8f " "newPrice=%0.8f " "requestTriggerTicksAway=%s " "requestTriggerPrice=%s " "requestTriggerQty=%s " "requestPayup=%s " "requestLimitTicksAway=%s " "requestWithATick=%s " "orderType=%s " "originalOrderType=%d " "requestDisclosedQty=%s " "originalLeftoverAction=%d " "requestLeftoverAction=%d " "originalLeftoverTicks=%d " "requestLeftoverTicks=%d " "originalLimitPriceType=%d " "requestLimitPriceType=%d " "status=%s " "child_pr=%p", m_name, GetOrderIDString(), GetOrderQuantity(), newQty, GetLimitPrice(), newPrice, requestTriggerTicksAway == INVALID_TICKS ? "unchanged" : std::to_string(requestTriggerTicksAway), std::isnan(requestTriggerPrice) ? "unchanged" : std::to_string(requestTriggerPrice), fp_eq(requestTriggerQty, ParentOrder::INVALID_QTY) ? "unchanged" : std::to_string(requestTriggerQty), requestPayup == INVALID_TICKS ? "unchanged" : std::to_string(requestPayup), requestLimitTicksAway == INVALID_TICKS ? "unchanged" : std::to_string(requestLimitTicksAway), fp_eq(requestWithATick, ParentOrder::INVALID_QTY) ? "unchanged" : std::to_string(requestWithATick), (requestOrderType == (ttsdk_order_type)0 || requestOrderType == originalOrderType) ? "unchanged" : std::to_string((int)requestOrderType), originalOrderType, fp_eq(requestDisclosedQty, INVALID_QTY) ? "unchanged" : std::to_string(requestDisclosedQty), originalLeftoverAction, requestLeftoverAction, originalLeftoverTicks, requestLeftoverTicks, originalLimitPriceType, requestLimitPriceType, TTSDK_SYNTH_STATUS_STR[status], m_childPR.get());
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnUpdateAlgo: Activity blocked." " activity_blocked=%s ", m_name, GetOrderIDString(), ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]);
somparentorder.cpp         ALGO_ELOG("[%s:%s] OnUpdateAlgo: Validation failed. error=%s", m_name, GetOrderIDString(), error);
somparentorder.cpp             ALGO_ILOG("[%s:%s] OnUpdateAlgo: Scheduling price update because WithATickValue changed", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ILOG("[%s:%s] OnUpdateAlgo: Scheduling price update because some trigger-related param changed", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ILOG("[%s:%s] OnUpdateAlgo: Updating LimitTicksAway " "originalLimitTicksAway=%d " "requestLimitTicksAway=%d ", m_name, GetOrderIDString(), GetLimitTicksAway(), requestLimitTicksAway);
somparentorder.cpp             ALGO_WLOG("[%s:%s] OnUpdateAlgo: Failed to promote FIX params for accept response: " "error=%s " "IGNORE this warning if FIX is not involved!", m_name, GetOrderIDString(), TTSDK_ERROR_STR[ttsdk_error]);
somparentorder.cpp             ALGO_ILOG("[%s:%s] OnUpdateAlgo: Promoted FIX params for accept response", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_WLOG("[%s:%s] OnUpdateAlgo: Failed to promote cl_ord_id params for accept response: " "error=%s ", m_name, GetOrderIDString(), TTSDK_ERROR_STR[ttsdk_error]);
somparentorder.cpp             ALGO_ILOG("[%s:%s] OnUpdateAlgo: Promoted cl_ord_id params for accept response cl_ord_id=%llu orig_cl_ord_id=%llu", m_name, GetOrderIDString(), cl_ord_id, orig_cl_ord_id);
somparentorder.cpp     ALGO_ILOG("[%s:%s] market_state %s->%s.", m_name, GetOrderIDString(), TTSDK_MarketStateSTR[old_market_state], TTSDK_MarketStateSTR[new_market_state]);
somparentorder.cpp             ALGO_ILOG("[%s:%s] Checking AutoResubmit logic." " synth_status=%s" " child_order_count=%zu", m_name, GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[synth_status], m_childOrders.size());
somparentorder.cpp             ALGO_ILOG("[%s:%s] AutoResubmit skipped due to invalid synthetic state." " synth_status=%s" " child_order_count=%zu", m_name, GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[synth_status], m_childOrders.size());
somparentorder.cpp         ALGO_ILOG("[%s:%s] Stopping since parent TIF is DAY.", m_name, GetOrderIDString(), TTSDK_MarketStateSTR[old_market_state], TTSDK_MarketStateSTR[ttsdk_market_state_close]);
somparentorder.cpp             ALGO_ILOG("[%s:%s] ParentOrderTestHarness: OnPriceUpdate: Simulating market state change: %s->%s", m_name, GetOrderIDString(), TTSDK_MarketStateSTR[m_currentMarketState], TTSDK_MarketStateSTR[GetTestHarness()->m_marketStateToSimulate]);
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnScheduledEvent: StartTime fired ", m_name, GetOrderIDString());
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnScheduledEvent: EndTime fired " "ActionInProgress=%s " "ActivityBlockedReason=%s " "end_action=%s", m_name, GetOrderIDString(), USER_ACTION_STR[to_underlying(GetActionInProgress())], ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())], END_ACTION_STR[to_underlying(GetEndTimeAction())]);
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnScheduledEvent: SimulatedPriceUpdate " "ActionInProgress=%s " "ActivityBlockedReason=%s ", m_name, GetOrderIDString(), USER_ACTION_STR[to_underlying(GetActionInProgress())], ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]);
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnStopAlgo: " "ActivityBlockedReason=%s ", m_name, GetOrderIDString(), ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]);
somparentorder.cpp         ALGO_DLOG("[%s:%s] ParentOrderTestHarness: OnStopAlgo: Scheduling custom event: " "event_type=%u", m_name, GetOrderIDString(), GetTestHarness()->m_eventToScheduleInOnStopAlgo);
somparentorder.cpp         ALGO_DLOG("[%s:%s] ParentOrderTestHarness: OnStopAlgo: Sleeping for 15 seconds...", m_name, GetOrderIDString());
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnStopAlgo: stops m_startTimer", m_name, GetOrderIDString());
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnStopAlgo: stops endTimer", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_WLOG("[%s:%s] OnStopAlgo:" " Skipping PR deletion due to zero qty. The PR order must have" " been rejected. pr_inflight_pending=%d pr_working_qty=%0.8f", m_name, GetOrderIDString(), m_childPR->GetInflightPending(), m_childPR->GetWorkingQty());
somparentorder.cpp             ALGO_ILOG("[%s:%s] OnStopAlgo:" " Deleting Position Reserve Order. pr_inflight_pending=%d pr_working_qty=%0.8f", m_name, GetOrderIDString(), m_childPR->GetInflightPending(), m_childPR->GetWorkingQty());
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnStopAlgo: " "No working/inflight, but childOrders not empty. DetachChildren directly! child_count=%zu " "detach_result=%s", m_name, GetOrderIDString(), szChildren, TTSDK_ERROR_STR[result]);
somparentorder.cpp         ALGO_WLOG("[%s:%s] OnStopAlgo: Failed to promote FIX params for accept response: " "error=%s " "IGNORE this warning if FIX is not involved!", m_name, GetOrderIDString(), TTSDK_ERROR_STR[ttsdk_error]);
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnStopAlgo: Promoted FIX params for accept response", m_name, GetOrderIDString());
somparentorder.cpp         ALGO_WLOG("[%s:%s] OnStopAlgo: Failed to promote cl_ord_id params for accept response: " "error=%s ", m_name, GetOrderIDString(), TTSDK_ERROR_STR[ttsdk_error]);
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnStopAlgo: Promoted cl_ord_id params for accept response cl_ord_id=%llu orig_cl_ord_id=%llu", m_name, GetOrderIDString(), cl_ord_id, orig_cl_ord_id);
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnPauseAlgo: " "ActivityBlockedReason=%s ", m_name, GetOrderIDString(), ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]);
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnPauseAlgo: Activity blocked. " "activity_blocked=%s ", m_name, GetOrderIDString(), ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]);
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnPauseAlgo: Setting pre-pause synthetic status to: %s", m_name, GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[status]);
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnPauseAlgo: stops m_startTimer", m_name, GetOrderIDString());
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnPauseAlgo: stops endTimer", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ILOG("[%s:%s] OnPauseAlgo: Skipping suspension of this order " "because it's a PR order: " "child=%p " "order_id=%s", m_name, GetOrderIDString(), (void*)child.get(), child->GetOrderIDString());
somparentorder.cpp             ALGO_ILOG("[%s:%s] OnPauseAlgo: Skipping suspension of this order " "because it's no longer working: " "child=%p " "order_id=%s", m_name, GetOrderIDString(), (void*)child.get(), child->GetOrderIDString());
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnPauseAlgo: " "No working/inflight, but childOrders not empty. DetachChildren directly! child_count=%zu " "detach_result=%s", m_name, GetOrderIDString(), szChildren, TTSDK_ERROR_STR[result]);
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnStopStagedAlgo." " activity_blocked=%s" " message=%s", m_name, GetOrderIDString(), ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())], message);
somparentorder.cpp         ALGO_ILOG("[%s:%s] CalcStartingPrice: " "base_price=%0.8f " "offset_price=%0.8f " "offset_ticks=%d " "offset_ticks_with_direction=%d " "is_payup=%s " "GetLimitPriceType=%s", m_name, GetOrderIDString(), base_price, limit_price, offset_ticks, offset_ticks_with_direction, is_payup ? std::string("true") : std::string("false"), PRICE_TYPE_STR[static_cast<int>(GetLimitPriceType())]);
somparentorder.cpp         ALGO_ILOG("[%s:%s] ProcessWaitingOption: will wait for market_state=%s", m_name, GetOrderIDString(), WAITING_OPTION_STR[to_underlying(GetWaitingOption())]);
somparentorder.cpp                 ALGO_ILOG("[%s:%s] OnStartTimeTimer.", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ELOG("[%s:%s] ScheduleStartTime: failed to arm timer." " scheduled_time=%llu [%s]", m_name, GetOrderIDString(), start_time_ms, MiliSecondsToDateString(start_time_ms));
somparentorder.cpp             ALGO_ILOG("[%s:%s] ScheduleStartTime: scheduled_time=%llu [%s] (send_ahead_interval_ms=%lu)", m_name, GetOrderIDString(), start_time_ms, MiliSecondsToDateString(start_time_ms), send_ahead_interval_ms);
somparentorder.cpp         ALGO_ELOG("[%s:%s] ScheduleStartTime: failed to create timer." " scheduled_time=%llu [%s]" " error=%s", m_name, GetOrderIDString(), start_time_ms, MiliSecondsToDateString(start_time_ms), std::string(e.what()));
somparentorder.cpp     ALGO_ILOG( "[%s:%s] PerformEndTimeAction." " action=%s", m_name, GetOrderIDString(), END_ACTION_STR[(int)GetEndTimeAction()]);
somparentorder.cpp         ALGO_DLOG("[%s:%s] ParentOrderTestHarness: PerformETAGoToMarket: Scheduling custom event: " "event_type=%u", m_name, GetOrderIDString(), GetTestHarness()->m_eventToScheduleInPerformETAGoToMarket);
somparentorder.cpp         ALGO_DLOG("[%s:%s] ParentOrderTestHarness: PerformETAGoToMarket: Sleeping for 15 seconds...", m_name, GetOrderIDString());
somparentorder.cpp     ALGO_ILOG("[%s:%s] PerformETAGoToMarket: Starting." " childOrders_size=%zu" " deleted_children=%s" " skipped_children=%s", m_name, GetOrderIDString(), m_childOrders.size(), std::to_string(deleted_children), std::to_string(skipped_children));
somparentorder.cpp         ALGO_DLOG("[%s:%s] ParentOrderTestHarness: GoToMarket: Sleeping for 15 seconds...", m_name, GetOrderIDString());
somparentorder.cpp         ALGO_DLOG("[%s:%s] ParentOrderTestHarness: GoToMarket: Scheduling custom event: " "event_type=%u", m_name, GetOrderIDString(), GetTestHarness()->m_eventToScheduleInGoToMarket);
somparentorder.cpp         ALGO_ELOG("[%s:%s] GoToMarket called while not in that blocked state. " "cum_fill_qty=%0.8f " "order_qty=%0.8f " "non_deletable_child_working_qty=%0.8f " "market_order_qty=%0.8f " "ActivityBlockedReason=%s ", m_name, GetOrderIDString(), cumFillQty, orderQty, childWorkingQty, marketOrderQty, blockedReasonStr);
somparentorder.cpp     ALGO_ILOG("[%s:%s] GoToMarket: Executing." "cum_fill_qty=%0.8f " "order_qty=%0.8f " "non_deletable_child_working_qty=%0.8f " "market_order_qty=%0.8f ", m_name, GetOrderIDString(), cumFillQty, orderQty, childWorkingQty, marketOrderQty);
somparentorder.cpp         ALGO_DLOG("[%s:%s] ParentOrderTestHarness: GoToMarket: Overriding GoToMarket base price: " " override_base_price=%f", m_name, GetOrderIDString(), GetTestHarness()->m_overrideEndTimeActionGoToMarketBasePriceValue);
somparentorder.cpp         ALGO_ELOG("[%s:%s] GoToMarket: Failed to determine best price for gtm limit order." " error=%s", m_name, GetOrderIDString(), error_str);
somparentorder.cpp         ALGO_ELOG("[%s:%s] GoToMarket: Failed to add child gtm limit order for remaining qty." " child_OQ=%0.8f" " error=%s", m_name, GetOrderIDString(), marketOrderQty, error_str);
somparentorder.cpp     ALGO_ILOG("[%s:%s] GoToMarket: Adding child gtm limit order for remaining qty." " child_OQ=%0.8f" " market_prc=%0.8f" " market_prc_ticks=%d" " result_prc=%0.8f" " eta_gtm_ticks=%d", m_name, GetOrderIDString(), marketOrderQty, current_price, offset, adjusted_price, eta_gtm_ticks);
somparentorder.cpp         ALGO_ILOG("[%s:%s] StartPendingTrigger called. synth_status=%s trigger_price=%lf", m_name, GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[GetSynthStatus()], GetOrCalcTriggerPrice(m_first_trigger));
somparentorder.cpp         ALGO_ELOG("[%s:%s] ScheduleEndTime failed." " endTime=%llu [%s]" " now=%llu [%s]", m_name, GetOrderIDString(), endTime, MiliSecondsToDateString(endTime), now_in_mili, MiliSecondsToDateString(now_in_mili));
somparentorder.cpp                 ALGO_ILOG("[%s:%s] OnEndTimeTimer.", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ELOG("[%s:%s] ScheduleEndTime: failed to arm timer." " endTime=%llu [%s]", m_name, GetOrderIDString(), endTime, MiliSecondsToDateString(endTime));
somparentorder.cpp             ALGO_ILOG("[%s:%s] ScheduleEndTime: scheduled_time=%llu [%s]", m_name, GetOrderIDString(), endTime, MiliSecondsToDateString(endTime) );
somparentorder.cpp         ALGO_ELOG("[%s:%s] ScheduleEndTime: failed to create timer." " endTime=%llu [%s] " " now_in_mili=%llu [%s] " " error=%s", m_name, GetOrderIDString(), endTime, MiliSecondsToDateString(endTime), now_in_mili, MiliSecondsToDateString(now_in_mili), std::string(e.what()));
somparentorder.cpp         ALGO_ILOG("[%s:%s] RecoverEndTime, End time has passed." " endTime=%llu [%s] " " now=%llu [%s] " " endTimeAction=%s ", m_name, GetOrderIDString(), endTime, MiliSecondsToDateString(endTime), now_in_mili, MiliSecondsToDateString(now_in_mili), END_ACTION_STR[to_underlying(GetEndTimeAction())]);
somparentorder.cpp         ALGO_ILOG("[%s:%s]: UpdateTrailingTriggerPrice: New trigger price." " trigger_price=%0.8f" " base_price=%0.8f" " trails_up=%d", m_name, GetOrderIDString(), newTrigger, m_first_trigger.trailingTriggerBase, triggerTrailsUp);
somparentorder.cpp         ALGO_ILOG("[%s:%s] Suppressed trigger check due to an inflight PR order request.", m_name, GetOrderIDString());
somparentorder.cpp         ALGO_ILOG("[%s:%s] Triggered upon %s! No price trigger set. ", m_name, GetOrderIDString(), TriggeringType_ToString(triggering));
somparentorder.cpp         ALGO_DLOG("[%s:%s] NOT Triggered %s! T%s %f, T%s Qty %f, M%s %f M%s Qty %f", m_name, GetOrderIDString(), TriggeringType_ToString(triggering), PRICE_TYPE_STR[(int)trigger.price_type], trigger_price, PRICE_TYPE_STR[(int)trigger.price_type], COMPARATOR_TYPE_STR[to_underlying(trigger.qty_compare)], trigger_qty, PRICE_TYPE_STR[(int)trigger.price_type], current.price, PRICE_TYPE_STR[(int)trigger.price_type], current.qty);
somparentorder.cpp         ALGO_ILOG("[%s:%s] Price At Trigger hit but market state is unreliable." "error=%s", m_name, GetOrderIDString(), error);
somparentorder.cpp         ALGO_ILOG("[%s:%s] Triggered upon %s! Price worse than TriggerPrice!! Ignore Qty checking!" " side=%s" " trigger_type=%s" " trigger_price=%lf" " current_price=%lf", m_name, GetOrderIDString(), TriggeringType_ToString(triggering), GetSide() == ttsdk_side_sell? "Sell": "Buy", TRIGGER_TYPE_STR[(int)trigger.trigger_type], trigger_price, current.price);
somparentorder.cpp             ALGO_DLOG("[%s:%s] NOT Triggered(QTY) %s! T%s %f, T%s Qty %f, M%s %f M%s Qty %f", m_name, GetOrderIDString(), TriggeringType_ToString(triggering), PRICE_TYPE_STR[(int)trigger.price_type], trigger_price, PRICE_TYPE_STR[(int)trigger.price_type], COMPARATOR_TYPE_STR[to_underlying(trigger.qty_compare)], trigger_qty, PRICE_TYPE_STR[(int)trigger.price_type], current.price, PRICE_TYPE_STR[(int)trigger.price_type], current.qty);
somparentorder.cpp     ALGO_ILOG(ss.str());
somparentorder.cpp     ALGO_DLOG(audit_ss.str());
somparentorder.cpp     ALGO_ILOG("[%s:%s] PrepAndStart: Start Working." " setPriceAtStart=%d " " limitPrice=%0.8f ", m_name, GetOrderIDString(), setPriceAtStart, limitPrice);
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnChildAdd: limitPrc=%0.8f OQ=%0.8f WQ=%0.8f", m_name, GetOrderIDString(), limitPrice, orderQuantity, workingQuantity);
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnChildCancel: " "ActionInProgress=%s " "ActivityBlockedReason=%s " "external=%d ", m_name, GetOrderIDString(), USER_ACTION_STR[(int)GetActionInProgress()], ACTIVITY_BLOCK_STR[(int)GetActivityBlockedReason()], external);
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnChildFill: " "ActionInProgress=%s ", m_name, GetOrderIDString(), USER_ACTION_STR[to_underlying(GetActionInProgress())]);
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnChildReject:" " external=%i" " requestsPending=%i" " ActionInProgress=%s" " message=%s", m_name, GetOrderIDString(), external, requestsPending, USER_ACTION_STR[to_underlying(GetActionInProgress())], std::string(message));
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnChildRequestFailure." " requests_pending=%i" " ActionInProgress=%s" " timeout=%i", m_name, GetOrderIDString(), requests_pending, USER_ACTION_STR[to_underlying(GetActionInProgress())], timeout);
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnChildAttachFailure: " "requests_pending=%i " "ActionInProgress=%s " "timeout=%i " "synth_status=%s", m_name, GetOrderIDString(), requests_pending, USER_ACTION_STR[to_underlying(GetActionInProgress())], timeout, TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]);
somparentorder.cpp         ALGO_ELOG("[%s:%s] OnChildAttachFailure: Neither Recovering nor Resuming - unexpected!", m_name, GetOrderIDString());
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnChildDetach." "child_id=%s", m_name, GetOrderIDString(), child->GetOrderIDString());
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnChildAttach." " child_id=%s" " synth_status=%s", m_name, GetOrderIDString(), child->GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]);
somparentorder.cpp         ALGO_ELOG("[%s:%s] OnChildAttach: Neither Recovering nor Resuming - unexpected!", m_name, GetOrderIDString());
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnPositionReserveReplace: " "order_id=%s " "OQ=%0.8f " "ActionInProgress=%s ", GetName(), GetOrderIDString(), m_childPR->GetOrderIDString(), m_childPR->GetInflightOrderQty(), USER_ACTION_STR[to_underlying(m_action_in_progress)]);
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnPositionReserveCancel: " "order_id=%s " "OQ=%0.8f " "ActionInProgress=%s " "ActivityBlockedReason=%s ", GetName(), GetOrderIDString(), m_childPR->GetOrderIDString(), m_childPR->GetInflightOrderQty(), USER_ACTION_STR[to_underlying(GetActionInProgress())], ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]);
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnPositionReserveCancel: Happened unexpectedly during pause process! Calling CheckPauseProgress anyway!", GetName(), GetOrderIDString());
somparentorder.cpp     ALGO_ELOG("[%s:%s] OnPositionReserveReject: " "order_id=%s " "OQ=%0.8f " "reject_details=%s " "ActionInProgress=%s " "ActivityBlockedReason=%s ", GetName(), GetOrderIDString(), m_childPR->GetOrderIDString(), m_childPR->GetInflightOrderQty(), msg, USER_ACTION_STR[to_underlying(GetActionInProgress())], ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]);
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnPositionReserveReject: Happened unexpectedly during pause process! Calling CheckPauseProgress anyway!", GetName(), GetOrderIDString());
somparentorder.cpp         ALGO_ILOG("[ParentOrder:%s]: Position reserve rejected during initialization." " order_id=%s" " flags=%u", GetOrderIDString(), m_childPR->GetOrderIDString(), m_initFlags);
somparentorder.cpp             ALGO_ILOG("[%s:%s] CheckDeleteProgress: Inflights still in progress. " "Child=%p " "order_id=%s " "status=%s", m_name, GetOrderIDString(), (void*)child.get(), child->GetOrderIDString(), child->InflightStatus());
somparentorder.cpp         ALGO_ILOG("[%s:%s] CheckDeleteProgress:" " Position Reserve inflights still in progress", m_name, GetOrderIDString());
somparentorder.cpp         ALGO_ILOG("[%s:%s] CheckDeleteProgress: DeletionSubTask is NONE, which is unexpected", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ILOG("[%s:%s] CheckPauseProgress: Inflights still in progress. " "Child=%p " "order_id=%s " "status=%s", m_name, GetOrderIDString(), (void*)child.get(), child->GetOrderIDString(), child->InflightStatus());
somparentorder.cpp         ALGO_ILOG("[%s:%s] CheckPauseProgress: PauseSubTask is NONE, which is unexpected", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ILOG("[%s:%s] DetachChildren: Detach PR Order synchronously.", m_name, GetOrderIDString());
somparentorder.cpp                 ALGO_DLOG("[%s:%s] ParentOrderTestHarness: DetachChildren: Sending a change request behind detach request: " "order_id=%s", m_name, GetOrderIDString(), (*child)->GetOrderIDString());
somparentorder.cpp                     ALGO_DLOG("[%s:%s] ParentOrderTestHarness: DetachChildren: Failed to send change request: " "order_id=%s " "error=%s", m_name, GetOrderIDString(), (*child)->GetOrderIDString(), TTSDK_ORDER_ERR_STR[harness_error]);
somparentorder.cpp             ALGO_ILOG("[%s:%s] DetachChildren: order_id=%s DetachOrder synchronously.", m_name, GetOrderIDString(), (*child)->GetOrderIDString());
somparentorder.cpp         ALGO_ILOG("[%s:%s] AssessETAGoToMarketResult:" " GoToMarket was successful!" " last_order=%s", m_name, GetOrderIDString(), std::to_string(last_order));
somparentorder.cpp         ALGO_ELOG("[%s:%s] AssessETAGoToMarketResult:" " GoToMarket was not successful!" " last_order=%s" " reject_unknown_order=%d" " working_qty=%0.8f" " leave_on_cancel=%s", m_name, GetOrderIDString(), std::to_string(last_order), last_order ? last_order->GetIsRejectUnknownOrder() : false, last_order ? last_order->GetWorkingQty() : 0.0f, ((last_order ? last_order->GetLeaveOn() : 0) & ttsdk_leave_on_cancel) ? std::string("true") : std::string("false"));
somparentorder.cpp             ALGO_WLOG("[%s:%s] AssessChildrenDeleteResult:" " Failed to delete child order during algo cancellation" " childOrders_size=%zu", m_name, GetOrderIDString(), m_childOrders.size());
somparentorder.cpp         ALGO_WLOG("[%s:%s] AssessChildrenDeleteResult:" " Failed to delete position reserve order during algo cancellation", m_name, GetOrderIDString());
somparentorder.cpp     ALGO_ILOG("[%s:%s] AssessChildrenDeleteResult:" " All child orders (except leave_on=cancel) were successfully deleted during algo cancellation." " expect_pr=%d", m_name, GetOrderIDString(), expectPRDeleted);
somparentorder.cpp             ALGO_ILOG("[%s:%s] AssessChildrenSuspendResult: This order was exempted " "because it's a PR order: " "child=%p " "order_id=%s", m_name, GetOrderIDString(), (void*)child.get(), child->GetOrderIDString());
somparentorder.cpp             ALGO_ILOG("[%s:%s] AssessChildrenSuspendResult: This order was exempted " "because it's no longer working: " "child=%p " "order_id=%s", m_name, GetOrderIDString(), (void*)child.get(), child->GetOrderIDString());
somparentorder.cpp             ALGO_ILOG("[%s:%s] AssessChildrenSuspendResult: This order's suspension attempt " "was rejected because the order was most likely fully filled in flight - " "this is not a problem: " "child=%p " "order_id=%s", m_name, GetOrderIDString(), (void*)child.get(), child->GetOrderIDString());
somparentorder.cpp             ALGO_ELOG("[%s:%s] AssessChildrenSuspendResult: " "Failed to suspend child order during algo pausing procedure: " "problematicChild=%p " "problematicChildOrderId=%s " "problematicChildLastStatus=%s " "childOrders_size=%zu", m_name, GetOrderIDString(), (void*)(child.get()), child->GetOrderIDString(), TTSDK_OrderStatusToString(child->GetOrderStatus()), m_childOrders.size());
somparentorder.cpp     ALGO_ILOG("[%s:%s] AssessChildrenSuspendResult: " "All child orders (except PR order) were successfully suspended during algo pausing procedure: " "childOrders_size=%zu", m_name, GetOrderIDString(), m_childOrders.size());
somparentorder.cpp             ALGO_ELOG("[%s:%s] AssessChildrenDetachResult:" "Failed to detach PR order during algo cancellation/pausing process: " "pr_order_id=%s", m_name, GetOrderIDString(), m_childPR->GetOrderIDString());
somparentorder.cpp             ALGO_ELOG("[%s:%s] AssessChildrenDetachResult:" "Failed to detach this child order during algo cancellation process: " "order_id=%s", m_name, GetOrderIDString(), child->GetOrderIDString());
somparentorder.cpp     ALGO_ILOG("[%s:%s] AssessChildrenDetachResult: " "All child orders were successfully detached during algo cancellation/pausing: " "m_childOrders.size()=%zu " "expectPRDetach=%d", m_name, GetOrderIDString(), m_childOrders.size(), expectPRDetach);
somparentorder.cpp         ALGO_ELOG("[%s:%s] CheckRecoveryProgress:" " RecoverySubTask is NONE, which is unexpected", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ELOG("[%s:%s] CheckRecoveryProgress:" " Forfeiting recovery and stopping algo because the user" " requested stop, or, there was a price subscription error", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ELOG("[%s:%s] CheckRecoveryProgress:" " Forfeiting recovery and stopping algo because" " children could not be recovered", m_name, GetOrderIDString());
somparentorder.cpp                 ALGO_ELOG("[%s:%s] CheckRecoveryProgress: No Attaching in flight." " error=%s", m_name, GetOrderIDString(), TTSDK_ERROR_STR[error]);
somparentorder.cpp                 ALGO_ILOG("[%s:%s] CheckRecoveryProgress." " attaching_inflight=%u" " error=%s", m_name, GetOrderIDString(), m_attached_children_count, TTSDK_ERROR_STR[error]);
somparentorder.cpp                 ALGO_ILOG("[%s:%s] CheckRecoveryProgress: Inflight attach requests still in progress for order_id=%s status=%s", m_name, GetOrderIDString(), child->GetOrderIDString(), child->InflightStatus() );
somparentorder.cpp             ALGO_ELOG("[%s:%s] CheckRecoveryProgress: Forfeiting recovery and stopping algo during subtask." " subtask_type=%s", m_name, GetOrderIDString(), RECOVERY_SUBTASK_STR[to_underlying(GetRecoverySubTask())]);
somparentorder.cpp             ALGO_ELOG("[%s:%s] CheckRecoveryProgress:" " Forfeiting recovery and stopping algo because" " children could not be attached", m_name, GetOrderIDString());
somparentorder.cpp         ALGO_ELOG("[%s:%s] CheckResumeProgress: " "ResumeSubTask is NONE, which is unexpected", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ELOG("[%s:%s] CheckResumeProgress:" " Forfeiting resuming and stopping algo because the user" " requested stop, or, there was a price subscription error", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ELOG("[%s:%s] CheckResumeProgress:" " Forfeiting resume and stopping algo because" " children could not be recovered", m_name, GetOrderIDString());
somparentorder.cpp                 ALGO_ELOG("[%s:%s] CheckResumeProgress: " "Forfeiting resume and stopping algo because " "there was an error during AttachChildren (no inflight attachments): " "error=%s", m_name, GetOrderIDString(), TTSDK_ERROR_STR[error]);
somparentorder.cpp                 ALGO_ILOG("[%s:%s] CheckResumeProgress: " "Setting forfeit flag to forfeit at the next opportunity because " "there was an error during AttachChildren (but some inflight attachments): " "attaching_inflight=%u " "error=%s", m_name, GetOrderIDString(), m_attached_children_count, TTSDK_ERROR_STR[error]);
somparentorder.cpp                 ALGO_ILOG("[%s:%s] CheckResumeProgress: Inflight attach requests still in progress for order_id=%s status=%s", m_name, GetOrderIDString(), child->GetOrderIDString(), child->InflightStatus());
somparentorder.cpp             ALGO_ELOG("[%s:%s] CheckResumeProgress: Forfeiting resume and stopping algo during subtask." " subtask_type=%s", m_name, GetOrderIDString(), RESUME_SUBTASK_STR[to_underlying(GetResumeSubTask())]);
somparentorder.cpp             ALGO_ELOG("[%s:%s] CheckResumeProgress: " "Forfeiting resume and stopping algo because " "children could not be attached", m_name, GetOrderIDString());
somparentorder.cpp         ALGO_WLOG("[%s:%s] SetPrOrder: pr_instrument_id=%lld not same as instr_id=%lld", m_name, GetOrderIDString(), GetInstrID(), somChildOrder->GetInstrID());
somparentorder.cpp         ALGO_ILOG("[%s:%s] AttachChildren: No children to be attached", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ELOG("[%s:%s] AttachChildren:" " Params for a recovered child was unexpectedly a nullptr." " index=%zu" " recovered_child_size=%zu", m_name, GetOrderIDString(), i, m_recoveredChildrenSize);
somparentorder.cpp             ALGO_ELOG("[%s:%s] AttachChildren:" " Missing order_id for a child order", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ELOG("[%s:%s] AttachChildren: Missing account_id." " order_id=%s", m_name, GetOrderIDString(), order_id.to_string());
somparentorder.cpp             ALGO_ELOG("[%s:%s] AttachChildren: Missing instr_id." " order_id=%s", m_name, GetOrderIDString(), order_id.to_string());
somparentorder.cpp             ALGO_ELOG("[%s:%s] AttachChildren: Missing order_type." " order_id=%s", m_name, GetOrderIDString(), order_id.to_string());
somparentorder.cpp             ALGO_ELOG("[%s:%s] AttachChildren: Missing tif." " order_id=%s", m_name, GetOrderIDString(), order_id.to_string());
somparentorder.cpp             ALGO_ELOG("[%s:%s] AttachChildren: Missing side." " order_id=%s", m_name, GetOrderIDString(), order_id.to_string());
somparentorder.cpp             ALGO_ELOG("[%s:%s] AttachChildren: Missing working_qty." " order_id=%s", m_name, GetOrderIDString(), order_id.to_string());
somparentorder.cpp             ALGO_ELOG("[%s:%s] AttachChildren: Missing last exec type." " order_id=%s", m_name, GetOrderIDString(), order_id.to_string());
somparentorder.cpp             ALGO_ELOG("[%s:%s] AttachChildren: InitFromParams failed. order_id=%s", m_name, GetOrderIDString(), order_id.to_string());
somparentorder.cpp             ALGO_ELOG("[%s:%s] AttachChildren: AttachOrder failed: order_id=%s", m_name, GetOrderIDString(), order_id.to_string());
somparentorder.cpp         ALGO_WLOG("[%s:%s] AttachChildren: Expected PR child order but it is absent!", m_name, GetOrderIDString());
somparentorder.cpp     ALGO_ILOG("[%s:%s] ForfeitRecovery moving recovered " "to childOrders for clean up " "m_recoveredChildren_size=%zu " "childOrders_size=%zu ", GetName(), GetOrderIDString(), m_recoveredChildren.size(), m_childOrders.size());
somparentorder.cpp         ALGO_ILOG("[%s:%s] process_extraction_complete_event: This is a special resume->cancel request " "to resume first and then cancel immediately afterwards", GetName(), GetOrderIDString());
somparentorder.cpp             ALGO_WLOG("[%s:%s] CompleteResume: Failed to promote cl_ord_id params for accept response: " "error=%s ", m_name, GetOrderIDString(), TTSDK_ERROR_STR[ttsdk_error]);
somparentorder.cpp             ALGO_ILOG("[%s:%s] CompleteResume: Promoted cl_ord_id params for accept response cl_ord_id=%llu orig_cl_ord_id=%llu", m_name, GetOrderIDString(), cl_ord_id, orig_cl_ord_id);
somparentorder.cpp     ALGO_ILOG("[%s:%s] ForfeitResume moving recovered " "to childOrders for clean up " "m_recoveredChildren_size=%zu " "childOrders_size=%zu ", GetName(), GetOrderIDString(), m_recoveredChildren.size(), m_childOrders.size());
somparentorder.cpp             ALGO_ILOG("[%s:%s] SendSuspendStatus on disconnect " "syn_status=%s", GetName(), GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[status]);
somparentorder.cpp                 ALGO_ILOG("[%s:%s] SendSuspendStatus on disconnect " "WAT=true and WAT trigger=false", GetName(), GetOrderIDString());
somparentorder.cpp                 ALGO_ILOG("[%s:%s] HandlePriceError: Disconnect Ignored " "HasWAT=%d; childOrderWithATick=%s; WithATickApplied=%s", GetName(), GetOrderIDString(), hasWat, childOrderWithATick ? "Exist": "Not exist", childOrderWithATick ? std::to_string(childOrderWithATick->WithATickApplied()): "N/A");
somparentorder.cpp             ALGO_ILOG("[%s:%s] HandlePriceError: Disconnect Ignored " "syn_status=%s", GetName(), GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[status]);
somparentorder.cpp         ALGO_ILOG("[%s:%s] OnChildCancel: Child expired and will resubmit", m_name, GetOrderIDString());
somparentorder.cpp     ALGO_ILOG("[%s:%s] OnChildCancel: Child expired and will schedule stop.", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_WLOG("[%s:%s] RequestStopWithLeaveChildren:" " This child order will be marked as Leave-On-Cancel:" " childOrderID=%s" " m_workingQty=%0.8f" " isLeaveOnCancel=%s" " childOrders_size=%zu", m_name, GetOrderIDString(), child->GetOrderIDString(), child->GetWorkingQty(), (child->GetLeaveOn() & ttsdk_leave_on_cancel) ? std::string("true") : std::string("false"), m_childOrders.size());
somparentorder.cpp     ALGO_ILOG("[%s:%s] Concluding change action as a success." " completeActionAndStop=%d" " requested_qty=%0.8f" " requested_prc=%0.8f", GetName(), GetOrderIDString(), m_completeActionAndStop, requestedQty, requested_price);
somparentorder.cpp     ALGO_ELOG("[%s:%s] Concluding change action as a failure," " the algo instance will be put into a Failed state.", GetName(), GetOrderIDString());
somparentorder.cpp         ALGO_ILOG("[%s:%s] CheckUserChangeProgress:" " current_task=%s inflights still in progress", GetName(), GetOrderIDString(), CHANGE_SUBTASK_STR[to_underlying(current_task)]);
somparentorder.cpp         ALGO_ELOG("[%s:%s] CheckUserChangeProgress: current_task=%s failed" " the algo instance will be put into a Failed state.", GetName(), GetOrderIDString(), CHANGE_SUBTASK_STR[to_underlying(current_task)]);
somparentorder.cpp         ALGO_ILOG("[%s:%s] CheckUserChangeProgress: Next current_task=%s pending", GetName(), GetOrderIDString(), CHANGE_SUBTASK_STR[to_underlying(current_task)]);
somparentorder.cpp         ALGO_ELOG("[%s:%s] CheckUserChangeProgress: Next current_task=%s failed", GetName(), GetOrderIDString(), CHANGE_SUBTASK_STR[to_underlying(current_task)]);
somparentorder.cpp         ALGO_WLOG("[%s:%s] ResumeWorking: " " Qty changed while offline." " change parent qty from %0.8f to %0.8f ", m_name, GetOrderIDString(), GetOrderQuantity(), qty_from_recovered_children);
somparentorder.cpp         ALGO_WLOG("[%s:%s] ResumeWorking: " "Fill missed: recovered_child.FillQty=%0.8f parent.FillQty=%0.8f ", m_name, GetOrderIDString(), filled_qty, cum_fill);
somparentorder.cpp     ALGO_ILOG("[%s:%s] FollowExternalChildPrice: " "child_price=%0.8f " "parent_price=%0.8f " "in_progress_price=%0.8f " "is_absolute=%d", m_name, GetOrderIDString(), child_price, GetLimitPrice(), GetLimitPrice(GetInProgressRequest()), is_absolute);
somparentorder.cpp         ALGO_DLOG("[%s:%s] CheckPriceDrift: Exempt!", m_name, GetOrderIDString());
somparentorder.cpp         ALGO_ILOG("[%s:%s] No remaining qty to generate slice schedule", m_name, GetOrderIDString());
somparentorder.cpp         ALGO_ILOG("[%s:%s] Adding preview slices to slice schedule", m_name, GetOrderIDString());
somparentorder.cpp         ALGO_WLOG("[%s:%s] Unable to generate slice schedule." " remaining_qty=%0.0f" " disc_qty=%0.0f", m_name, GetOrderIDString(), remaining_qty, disc_qty);
somparentorder.cpp         ALGO_ILOG("[%s:%s] Generated new slice schedule. %s", m_name, GetOrderIDString(), GetSliceSummary());
somparentorder.cpp     ALGO_ILOG("[%s:%s] Will check for any preview slices required_qty=%0.0f placed_qty=%0.0f", m_name, GetOrderIDString(), required_qty, placed_qty);
somparentorder.cpp         ALGO_ILOG("[%s:%s] No preview slices to use", m_name, GetOrderIDString());
somparentorder.cpp     ALGO_ILOG("[%s:%s] %s", m_name, GetOrderIDString(), ss.str());
somparentorder.cpp         ALGO_ILOG("[%s:%s] incorrect preview qty as it is greater than required + placed so preview slices won't be used.", m_name, GetOrderIDString());
somparentorder.cpp         ALGO_ILOG("[%s:%s] No volume placed so far will use preview slices", m_name, GetOrderIDString());
somparentorder.cpp                 ALGO_ILOG("[%s:%s] Some volume has already been placed and can be reconciled so will use preview slices", m_name, GetOrderIDString());
somparentorder.cpp             ALGO_ILOG("[%s:%s] Some volume has already been placed and can't be reconciled so will not use preview slices", m_name, GetOrderIDString());
somparentorder.cpp     ALGO_ILOG("[%s:%s] Custom Slice Schedule:%s", m_name, GetOrderIDString(), sliceStr);
oco.cpp     ALGO_ILOG("[%s:%s] OnChildAdd: order_id=%s limitPrc=%0.8f OQ=%0.8f WQ=%0.8f ", m_name, GetOrderIDString(), childOrder->GetOrderIDString(), limitPrice, orderQuantity, workingQuantity);
oco.cpp         ALGO_ELOG("[%s:%s] OnChildAdd: Dropping callback: " "m_primaryOrder or m_secondaryOrder was unexpectedly a nullptr.", m_name, GetOrderIDString());
oco.cpp     ALGO_DLOG("[%s:%s] HandleTTStopRestatement: Received child TT Stop restatement: " "synth_status=%s", m_name, GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[ttStopOrder->GetSynthStatus()]);
oco.cpp             ALGO_ILOG("[%s:%s] HandleTTStopRestatement: Child TT Stop paused - setting last exec_type to EXEC_TYPE_SUSPENDED", m_name, GetOrderIDString());
oco.cpp         ALGO_ELOG("[%s:%s] HandleTTStopRestatement:" " Child TT Stop failed, stopping TT OCO instance!", m_name, GetOrderIDString());
oco.cpp     ALGO_ILOG("[%s:%s] OnChildReplace: " "order_id=%s " "limitPrc=%0.8f " "OQ=%0.8f " "WQ=%0.8f " "external=%d " "requestsPending=%d", m_name, GetOrderIDString(), childOrder->GetOrderIDString(), limitPrice, orderQuantity, workingQuantity, external, requestsPending);
oco.cpp         ALGO_ELOG("[%s:%s] OnChildReplace: Dropping callback: " "m_primaryOrder or m_secondaryOrder was unexpectedly a nullptr.", m_name, GetOrderIDString());
oco.cpp             ALGO_ILOG("[%s:%s] 2nd child order_id=%s triggered," " Delete primary child order_id=%s", m_name, GetOrderIDString(), childOrder->GetOrderIDString(), m_primaryOrder->GetOrderIDString());
oco.cpp     ALGO_ILOG("[%s:%s] OnChildCancel: " "order_id=%s " "external=%i " "ActionInProgress=%s", GetName(), GetOrderIDString(), childOrder->GetOrderIDString(), external, USER_ACTION_STR[to_underlying(GetActionInProgress())]);
oco.cpp         ALGO_ELOG("[%s:%s] OnChildCancel: Dropping callback: " "m_primaryOrder or m_secondaryOrder was unexpectedly a nullptr.", m_name, GetOrderIDString());
oco.cpp         ALGO_ILOG("[%s:%s] OnChildCancel: ShouldStopParent returned TRUE, therefore, stopping algo.", m_name, GetOrderIDString());
oco.cpp     ALGO_ILOG("[%s:%s] OnChildCancel: ShouldStopParent: " "otherOrder->isPrimary=%s " "otherOrder->workingQty=%0.8f " "otherOrder->inflightPending=%s " "otherOrder->orderType=%s", m_name, GetOrderIDString(), otherOrder.get() == m_primaryOrder.get() ? "true" : "false", otherOrder->GetWorkingQty(), otherOrder->GetInflightPending() ? "true" : "false", TTSDK_OrderTypeToString(otherOrder->GetType()));
oco.cpp         ALGO_ILOG("[%s:%s] OnChildCancel: ShouldStopParent: Other child order is no longer working, so cancel OCO algo instance.", m_name, GetOrderIDString());
oco.cpp         ALGO_ILOG("[%s:%s] OnChildCancel: ShouldStopParent: " "Other child order (Primary) is working/pending, so cancel OCO " "algo instance (redundant stop requests are swallowed).", m_name, GetOrderIDString());
oco.cpp         ALGO_ILOG("[%s:%s] OnChildCancel: ShouldStopParent: " "Other child order (Secondary) is triggered and working/pending, " "so continue OCO algo instance.", m_name, GetOrderIDString());
oco.cpp     ALGO_ILOG("[%s:%s] OnChildCancel: ShouldStopParent: " "Other child order (Secondary) is un-triggered/pending, so cancel OCO " "algo instance (redundant stop requests are swallowed).", m_name, GetOrderIDString());
oco.cpp     ALGO_ILOG("[%s:%s] OnChildFill: " "order_id=%s " "limitPrc=%0.8f " "OQ=%0.8f " "WQ=%0.8f " "FQ=%0.8f " "FlPrc=%0.8f " "fill_type=%s", m_name, GetOrderIDString(), child_order->GetOrderIDString(), limit_price, order_quantity, working_quantity, fill_quantity, fill_price, FILL_TYPE_STR[to_underlying(fill_type)]);
oco.cpp         ALGO_ELOG("[%s:%s] OnChildFill: Dropping callback: " "m_primaryOrder or m_secondaryOrder was unexpectedly a nullptr.", m_name, GetOrderIDString());
oco.cpp     ALGO_ELOG("[%s:%s] OnChildRequestFailure: " "order_id=%s " "requests_pending=%d " "status_flags=[%s] " "timeout=%d " "ActionInProgress=%s", m_name, GetOrderIDString(), childOrder->GetOrderIDString(), requests_pending, OrderStatusFlagsString(status_flags), timeout, USER_ACTION_STR[to_underlying(GetActionInProgress())]);
oco.cpp     ALGO_ELOG("[%s:%s] OnChildReject: " "order_id=%s " "external=%d " "requests_pending=%d " "message=%s " "ActionInProgress=%s", m_name, GetOrderIDString(), childOrder->GetOrderIDString(), external, requestsPending, std::string(message), USER_ACTION_STR[to_underlying(GetActionInProgress())]);
oco.cpp         ALGO_ILOG("[%s:%s] StartWorking: Failed to calculate child price:%s", m_name, GetOrderIDString(), error);
oco.cpp         ALGO_ILOG("[%s:%s] Requesting Secondary TT STOP Order with " "quantity=%0.8f price=%0.8f trigger_price=%0.8f", m_name, GetOrderIDString(), GetOrderQuantity(), price, trigger);
oco.cpp     ALGO_ILOG("[%s:%s] HandleUpdate: " " synth_status=%s" " m_primaryOrderExists=%s" " m_secondaryOrderExists=%s" " m_childPRExists=%s", m_name, GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[GetSynthStatus()], m_primaryOrder ? std::string("true") : std::string("false"), m_secondaryOrder ? std::string("true") : std::string("false"), m_childPR ? std::string("true") : std::string("false"));
oco.cpp     ALGO_ILOG("[%s:%s] HandleUpdate: Sending requests with the following" " (note: some fields may be invalid depending on the sequence):" " pending_change_subtasks=%s" " target_primary_qty=%0.8f" " target_secondary_qty=%0.8f" " target_pr_qty=%0.8f", m_name, GetOrderIDString(), std::to_string(m_pending_change_subtasks), m_targetPrimaryQty, m_targetSecondaryQty, m_targetPRQty);
oco.cpp     ALGO_ILOG("[%s:%s] HandleUpdate: ProcessPendingChangeTasks returned error=%s", m_name, GetOrderIDString(), TTSDK_ERROR_STR[error]);
oco.cpp     ALGO_ILOG("[%s:%s] ResumeWorking: Printing algo params: " "order_qty=%0.8f " "limit_prc=%0.8f " "trg_prc=%0.8f " "synth_status=%s " "ladder_display=%d " "order_type=%s ", m_name, GetOrderIDString(), GetOrderQuantity(), GetLimitPrice(), GetTriggerPrice(), TTSDK_SYNTH_STATUS_STR[GetSynthStatus()], GetLadderDisplay(), TTSDK_OrderTypeToString(GetType()));
oco.cpp         ALGO_ILOG("[%s:%s] ResumeWorking: Primary order was deleted by the algo" " instance (prior to recovery) due to Stop order being triggered.", m_name, GetOrderIDString());
oco.cpp         ALGO_ILOG("[%s:%s] ResumeWorking: Order Info: " "order_ptr=%p " "order_id=%s " "order_type=%s " "order_side=%d " "order_qty=%0.8f " "order_working_qty=%0.8f " "order_prc=%0.8f " "order_trg_prc=%0.8f ", m_name, GetOrderIDString(), static_cast<void *>(childOrder.get()), childOrder->GetOrderIDString(), TTSDK_OrderTypeToString(childOrder->GetType()), childOrder->GetSide(), childOrder->GetOrderQty(), childOrder->GetWorkingQty(), childOrder->GetLimitPrice(), childOrder->GetTriggerPrice());
oco.cpp                     ALGO_ELOG("[%s:%s] ResumeWorking: Duplicate m_secondaryOrder detected - the recovery process will fail.", m_name, GetOrderIDString());
oco.cpp                     ALGO_ILOG("[%s:%s] ResumeWorking: This is the m_secondaryOrder.", m_name, GetOrderIDString());
oco.cpp                         ALGO_ELOG("[%s:%s] ResumeWorking: Duplicate m_primaryOrder detected - the recovery process will fail.", m_name, GetOrderIDString());
oco.cpp                         ALGO_ILOG("[%s:%s] ResumeWorking: Encountered two primary (limit) orders, assuming one is the triggered stop: " "m_primaryOrder=%p " "m_primaryOrder->price=%0.8f " "m_primaryOrderID=%s" "m_secondaryOrder=%p " "m_secondaryOrderID=%s" "m_secondaryOrder->price=%0.8f ", m_name, GetOrderIDString(), (void*)(m_primaryOrder.get()), m_primaryOrder->GetLimitPrice(), m_primaryOrder->GetOrderIDString(), (void*)(m_secondaryOrder.get()), m_secondaryOrder->GetOrderIDString(), m_secondaryOrder->GetLimitPrice() );
oco.cpp                         ALGO_ILOG("[%s:%s] ResumeWorking: This is the m_secondaryOrder, " "there should be no m_primaryOrder detected.", m_name, GetOrderIDString());
oco.cpp                         ALGO_ILOG("[%s:%s] ResumeWorking: This is the m_primaryOrder.", m_name, GetOrderIDString());
oco.cpp         ALGO_ELOG("[%s:%s] ResumeWorking: Unexpected scenario where the parent order is aware of more fills than the child orders' fills. " "cumFillQty=%0.8f " "m_cum_fill_qty=%0.8f", m_name, GetOrderIDString(), cumFilledQty, GetCumFillQuantity());
oco.cpp         ALGO_ELOG("[%s:%s] ResumeWorking: OCO order recovery failed due to an unexpected scenario: " "failureOccurred=%s " "primaryOrderDeleted=%s " "m_primaryOrder=%s " "m_secondaryOrder=%s ", m_name, GetOrderIDString(), failureOccurred ? "true" : "false", primaryOrderDeleted ? "true" : "false", m_primaryOrder == nullptr ? "nullptr" : "valid", m_secondaryOrder == nullptr ? "nullptr" : "valid");
oco.cpp         ALGO_ILOG("[%s:%s] ResumeWorking: " "m_primaryOrder was un-set, so setting it to a dummy order to be safe.", m_name, GetOrderIDString());
oco.cpp         ALGO_ILOG("[%s:%s] ResumeWorking: " "m_secondaryOrder was un-set, so setting it to a dummy order to be safe.", m_name, GetOrderIDString());
oco.cpp         ALGO_ILOG("[%s:%s] ResumeWorking: Secondary (Stop) Order was triggered while offline - deleting Primary Order and " "matching Secondary Order's working qty to match parent order working qty.", m_name, GetOrderIDString());
oco.cpp         ALGO_ELOG("[%s:%s] TryStopAlgo: Stop action could not be scheduled due to: " "error=%s", m_name, GetOrderIDString(), TTSDK_ERROR_STR[error]);
volumeduration.cpp         ALGO_ILOG("[%s:%s] OnWorkingPriceUpdate User action is progress, marking price update pending", m_name, GetOrderIDString());
volumeduration.cpp     ALGO_ILOG( "[%s:%s] StartWorking: Restarted tracking" " current_ttq=%0.8f" " calc_interval=%d", m_name, GetOrderIDString(), snapshot->volume, calc_interval );
volumeduration.cpp             ALGO_ILOG("[%s:%s] HandleUpdate: " "Qty reduced below placed quantity, halted slicing" " order_qty=%0.0f", m_name, GetOrderIDString(), new_qty);
volumeduration.cpp         ALGO_ILOG("[%s:%s] HandleActionFinished User action is complete, processing pending price update", m_name, GetOrderIDString());
volumeduration.cpp         ALGO_ILOG( "[%s:%s] RegenerateSchedule: Updated volume tracking" " calc_interval=%d", m_name, GetOrderIDString(), calc_interval);
volumeduration.cpp         ALGO_ILOG("[%s:%s] GenerateSliceSchedule: No remaining quantity to generate slice schedule.", m_name, GetOrderIDString());
volumeduration.cpp         ALGO_ILOG("[%s:%s] GenerateSliceSchedule: No remaining duration to generate slice schedule.", m_name, GetOrderIDString());
volumeduration.cpp             ALGO_ELOG("[%s:%s] GenerateSliceSchedule FAILED : " "Remaining number of slices are greater than Remaining Durations. " "remaining_number_of_slices=%d " "remaining_duration=%d ", m_name, GetOrderIDString(), remaining_number_of_slices, remaining_duration);
volumeduration.cpp     ALGO_ILOG("[%s:%s] GenerateSliceSchedule: Generating new schedule." " usePreviewSlices=%s" " remaining_qty=%0.0f" " remaining_duration=%d" " interval=%d" " disclosed_qty=%0.0f" " revision=%lu", m_name, GetOrderIDString(), std::string(usePreviewSlices ? "true" : "false"), remaining_qty, remaining_duration, interval, disc_qty, newRevision);
volumeduration.cpp             ALGO_ILOG("[%s:%s] GenerateSliceSchedule: No remaining quantity to generate slice schedule " "after applying preview slices.", m_name, GetOrderIDString());
volumeduration.cpp     ALGO_ILOG("[%s:%s] GenerateSliceSchedule: Calling GenerateIntervalBasedSlices with: " "remaining_qty=%0.0f " "num_non_preview_slices=%d " "variance=%d " "min_qty=%0.0f", m_name, GetOrderIDString(), remaining_qty, num_non_preview_slices, GetVariance(), GetMinimumQuantity());
volumeduration.cpp         ALGO_WLOG("[%s:%s] GenerateSliceSchedule: Unable to generate slice schedule." " disc_value=%0.0f" " disc_value_type=%s" " interval=%d" " schedule_revision=%lu", m_name, GetOrderIDString(), GetDisclosedValue(), VALUE_TYPE_STR[to_underlying(GetDisclosedValueType())], interval, newRevision);
volumeduration.cpp         ALGO_ILOG("[%s:%s] GenerateSliceSchedule: Generated new slice schedule." " schedule_revision=%lu %s", m_name, GetOrderIDString(), newRevision, GetSliceSummary());
volume_tracker.cpp         ALGO_ELOG("Interval must be greater than 0, interval=%d", m_interval);
somchildorder.cpp     ALGO_WLOG("[SomChildOrder] Destructor: parent_order_id=%s order_id=%s", m_parentOrderIdString, m_orderIdString );
somchildorder.cpp         ALGO_ILOG("AccountOverride=%s", account_override);
somchildorder.cpp     ALGO_ILOG("[SomChildOrder] AddOrder: " "order=%p " "order_id=%s " "parent_order_id=%s " "account_id=%llu " "broker_id=%llu " "algo_compliance_id=%llu " "type=%s " "tif=%d " "price=%0.8f " "quantity=%0.8f " "cancel_pending_on_full_fill=%d " "error=%s " "request_id=%d " "original_time_sent=%llu ", (void*)m_order, m_orderIdString, m_parentOrder->GetOrderIDString(), m_accountId, broker_id, m_parentOrder->GetAlgoComplianceID(), TTSDK_OrderTypeToString(m_type), m_tif, price, quantity, cancel_pending_on_full_fill, TTSDK_ORDER_ERR_STR[error], request_id, m_original_time_sent);
somchildorder.cpp         ALGO_WLOG("[SomChildOrder] ChangeOrder IGNORED: order=nullptr");
somchildorder.cpp         ALGO_WLOG("[SomChildOrder] ChangeOrder triggered Average Trade Size Check violation," " but cancel requests are exempt from the check: " " order=%p" " parent_order_id=%s" " order_id=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), m_orderIdString);
somchildorder.cpp         ALGO_WLOG("[SomChildOrder] ChangeOrder triggered Max Order Rate violation," " but cancel requests are exempt from the check: " " order=%p" " parent_order_id=%s" " order_id=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), m_orderIdString);
somchildorder.cpp         ALGO_ELOG("[SomChildOrder] ChangeOrder FAILED:" " order=%p" " parent_order_id=%s" " order_id=%s" " price=%0.8f" " quantity=%0.8f" " m_order_status=%s " " override_flags=%llu" " error=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), m_orderIdString, price, quantity, TTSDK_OrderStatusToString(m_order_status), (unsigned long long)override_flags, std::string(TTSDK_ORDER_ERR_STR[error]));
somchildorder.cpp     ALGO_ILOG("[SomChildOrder] ChangeOrder:" " order=%p" " parent_order_id=%s" " order_id=%s" " price=%0.8f" " quantity=%0.8f" " request_id=%d", (void*)m_order, m_parentOrder->GetOrderIDString(), m_orderIdString, price, quantity, request_id);
somchildorder.cpp         ALGO_ELOG("[SomChildOrder] AttachOrder FAILED:" " order=%p" " parent_order_id=%s" " order_id=%s" " error=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), std::string(order_id_str), std::string(TTSDK_ERROR_STR[error]));
somchildorder.cpp     ALGO_ILOG("[SomChildOrder] AttachOrder:" " order=%p" " parent_order_id=%s" " order_id=%s" " request_id=%d", (void*)m_order, m_parentOrder->GetOrderIDString(), std::string(order_id_str), request_id);
somchildorder.cpp         ALGO_ILOG("SomChildOrder] GoToMarket using market order " "order=%p " "parent_order_id=%s " "quantity=%0.8f", (void*)m_order, m_parentOrder->GetOrderIDString(), m_goToMarketQuantity);
somchildorder.cpp             ALGO_ELOG("[SomChildOrder] GoToMarket: Failed to delete the order for gtm leftover action " "order=%p " "parent_order_id=%s " "error=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), std::string(TTSDK_ERROR_STR[delete_error_code]));
somchildorder.cpp             ALGO_ELOG("[SomChildOrder] GoToMarket: Failed to determine best price for synthetic market order " "order=%p " "parent_order_id=%s " "error=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), error_str);
somchildorder.cpp         ALGO_ILOG("SomChildOrder] GoToMarket using synthetic market order " "order=%p " "parent_order_id=%s " "price=%0.8f " "quantity=%0.8f", (void*)m_order, m_parentOrder->GetOrderIDString(), adjusted_price, m_goToMarketQuantity);
somchildorder.cpp             ALGO_ELOG("[SomChildOrder] GoToMarket: Failed to change the order for the synthetic market " "order=%p " "parent_order_id=%s " "error=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), std::string(TTSDK_ERROR_STR[change_error_code]));
somchildorder.cpp         ALGO_WLOG("[SomChildOrder] DeleteOrder IGNORED: order=nullptr");
somchildorder.cpp         ALGO_ELOG("[SomChildOrder] DeleteOrder FAILED:" " order=%p" " parent_order_id=%s" " order_id=%s " " order_type=%s" " m_order_status=%s" " error=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), m_orderIdString, TTSDK_OrderTypeToString(GetType()), TTSDK_OrderStatusToString(m_order_status), std::string(TTSDK_ORDER_ERR_STR[error]));
somchildorder.cpp     ALGO_ILOG("[SomChildOrder] DeleteOrder:" " order=%p" " parent_order_id=%s" " order_id=%s" " request_id=%d " " order_type=%s " " m_order_status=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), m_orderIdString, request_id, TTSDK_OrderTypeToString(GetType()), TTSDK_OrderStatusToString(m_order_status));
somchildorder.cpp         ALGO_WLOG("[SomChildOrder] SuspendOrder IGNORED: order=nullptr");
somchildorder.cpp         ALGO_ELOG("[SomChildOrder] SuspendOrder FAILED:" " order=%p" " parent_order_id=%s" " order_id=%s " " order_type=%s" " m_order_status=%s" " error=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), m_orderIdString, TTSDK_OrderTypeToString(GetType()), TTSDK_OrderStatusToString(m_order_status), std::string(TTSDK_ORDER_ERR_STR[error]));
somchildorder.cpp     ALGO_ILOG("[SomChildOrder] SuspendOrder:" " order=%p" " parent_order_id=%s" " order_id=%s" " request_id=%d " " order_type=%s " " m_order_status=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), m_orderIdString, request_id, TTSDK_OrderTypeToString(GetType()), TTSDK_OrderStatusToString(m_order_status));
somchildorder.cpp         ALGO_WLOG("[SomChildOrder] UnSuspendOrder IGNORED: order=nullptr");
somchildorder.cpp         ALGO_ELOG("[SomChildOrder] UnSuspendOrder FAILED:" " order=%p" " parent_order_id=%s" " order_id=%s " " order_type=%s" " m_order_status=%s" " error=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), m_orderIdString, TTSDK_OrderTypeToString(GetType()), TTSDK_OrderStatusToString(m_order_status), std::string(TTSDK_ORDER_ERR_STR[error]));
somchildorder.cpp     ALGO_ILOG("[SomChildOrder] UnSuspendOrder:" " order=%p" " parent_order_id=%s" " order_id=%s" " request_id=%d " " order_type=%s " " m_order_status=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), m_orderIdString, request_id, TTSDK_OrderTypeToString(GetType()), TTSDK_OrderStatusToString(m_order_status));
somchildorder.cpp         ALGO_ILOG( "[SomChildOrder] ApplyLeftoverAction: " "order=%p " "parent_order_id=%s " "order_id=%s " "action=%s " "ticks=%d ", (void*)m_order, m_parentOrder->GetOrderIDString(), m_orderIdString, LEFT_OVER_ACTION_STR[to_underlying(action)], ticks );
somchildorder.cpp         ALGO_ILOG("[SomChildOrder] ApplyLeftoverAction: NO ORDER");
somchildorder.cpp         ALGO_ILOG("[%s:%s] ApplyWithATick: No market on opposite side. opposite_inside_price is NAN ", m_parentOrder->GetName(), m_parentOrder->GetOrderIDString());
somchildorder.cpp         ALGO_ILOG("[%s:%s] ApplyWithATick: Our price is not directly next to the opposite side inside market." "m_orderPrice=%0.8f opposite_next_tick=%0.8f opposite_inside_price=%0.8f", m_parentOrder->GetName(), m_parentOrder->GetOrderIDString(), m_orderPrice, opposite_next_tick, opposite_inside_price);
somchildorder.cpp             ALGO_ILOG("[%s:%s] ApplyWithATick: opposite_qty < threshold_qty" "opposite_qty=%0.8f threshold_qty=%0.8f", m_parentOrder->GetName(), m_parentOrder->GetOrderIDString(), opposite_qty, (double)value);
somchildorder.cpp             ALGO_ILOG("[%s:%s] ApplyWithATick: opposite_qty < threshold_percent" "opposite_qty=%0.8f threshold_percent=%0.8f", m_parentOrder->GetName(), m_parentOrder->GetOrderIDString(), opposite_qty, (double)value);
somchildorder.cpp         ALGO_WLOG("[SomChildOrder] DetachOrder IGNORED: order=nullptr");
somchildorder.cpp         ALGO_WLOG("[SomChildOrder] order=%p Already detaching or detached", (void*)m_order);
somchildorder.cpp         ALGO_ELOG("[SomChildOrder] DetachOrder FAILED:" " order=%p" " parent_order_id=%s" " order_id=%s" " m_order_status=%s" " error=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), m_orderIdString, TTSDK_OrderStatusToString(m_order_status), std::string(TTSDK_ERROR_STR[error]));
somchildorder.cpp     ALGO_ILOG("[SomChildOrder] DetachOrder:" " order=%p" " parent_order_id=%s" " order_id=%s" " request_id=%d", (void*)m_order, m_parentOrder->GetOrderIDString(), m_orderIdString, request_id);
somchildorder.cpp         ALGO_ILOG("[SomChildOrder] OnOrderEvent on deleted parent=" + m_parentOrderIdString + " order_id=" + m_orderIdString );
somchildorder.cpp         ALGO_DLOG("[%s:%s] SomChildOrder::OnOrderEvent: Dropping grand child order response!", m_parentOrder->GetName(), m_parentOrder->GetOrderIDString());
somchildorder.cpp         ALGO_ILOG("[SomChildOrder] ParentOrderTestHarness: OnOrderEvent: Simulating expiration: " "order=%p " "parent_order_id=%s " "order_id=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), std::string(order_id_str));
somchildorder.cpp     ALGO_ILOG("[SomChildOrder] OnOrderEvent: " "order=%p " "parent_order_id=%s " "order_id=%s " "last_status=%s " "external=%d " "last_status_flags=0x%X " "user_request_id=%d " "last_request_id=%d " "message=%s " "is_reject_unknown_order=%d " "%s" , (void*)m_order, m_parentOrder->GetOrderIDString(), std::string(order_id_str), TTSDK_OrderStatusToString(order_snap->last_status), (order_snap->last_status_flags&ttsdk_external_order_event), order_snap->last_status_flags, user_request_id, m_lastRequestId, std::string(message), m_is_reject_unknown_order, log_info.str());
somchildorder.cpp         ALGO_ILOG("[SomChildOrder] ParentOrderTestHarness: OnOrderEvent: Simulating reject: " "order=%p " "parent_order_id=%s " "order_id=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), std::string(order_id_str));
somchildorder.cpp                 ALGO_ILOG("[SomChildOrder] OnOrderEvent (NO-OP response for PR): No pending actions remain, " "converting this NO-OP response into %s " "order=%p " "parent_order_id=%s " "order_id=%s ", fp_zero(m_workingQty) ? "OnChildCancel" : "OnChildReplace", (void*)m_order, m_parentOrder->GetOrderIDString(), std::string(order_id_str));
somchildorder.cpp             ALGO_DLOG("[SomChildOrder] OnOrderEvent: Dropping unhandled PR order status type: " "order=%p " "parent_order_id=%s " "order_id=%s ", (void*)m_order, m_parentOrder->GetOrderIDString(), std::string(order_id_str));
somchildorder.cpp                 ALGO_ILOG("[SomChildOrder] OnOrderEvent: Partial fill reducing go to market quantity: " "order=%p " "parent_order_id=%s " "order_id=%s " "go to market qty=%d", (void*)m_order, m_parentOrder->GetOrderIDString(), std::string(order_id_str), m_goToMarketQuantity);
somchildorder.cpp                 ALGO_ILOG("[SomChildOrder] OnOrderEvent: Full fill interrupted go to market action: " "order=%p " "parent_order_id=%s " "order_id=%s", (void*)m_order, m_parentOrder->GetOrderIDString(), std::string(order_id_str));
somchildorder.cpp         ALGO_ILOG("[SomChildOrder] OnOrderEvent: " "last_status=%s " "last_status_flags=%08x " "order=%p " "parent_order_id=%s " "order_id=%s", TTSDK_OrderStatusToString(order_snap->last_status), order_snap->last_status_flags, (void*)m_order, m_parentOrder->GetOrderIDString(), std::string(order_id_str));
somchildorder.cpp                 ALGO_ILOG("[SomChildOrder] OnOrderEvent (unsolicited cancel): " "Violated max unsolicited cancel rate! " "Algo instance will continue running but its next child order add / change request " "will get rejected, (most likely) causing the instance to fail: " "last_status=%s " "order=%p " "parent_order_id=%s " "order_id=%s", TTSDK_OrderStatusToString(order_snap->last_status), (void*)m_order, m_parentOrder->GetOrderIDString(), std::string(order_id_str));
somchildorder.cpp             ALGO_ILOG( "[SomChildOrder] OnOrderEvent (noop): No pending actions remain, deliver %s " "order=%p " "parent_order_id=%s " "order_id=%s ", fp_zero(m_workingQty) ? "OnChildCancel" : "OnChildReplace", (void*)m_order, m_parentOrder->GetOrderIDString(), std::string(order_id_str) );
somchildorder.cpp     ALGO_ILOG("[SomChildOrder] OnDetach: " "order=%p " "parent_order_id=%s " "order_id=%s " "incoming_request_id=%d " "last_sent_request_id=%d " "last_confirmed_request_id=%d", (void*)m_order, m_parentOrder->GetOrderIDString(), m_orderIdString, user_request_id, m_lastRequestId, m_confirmedRequestId);
somchildorder.cpp         ALGO_ELOG("[SomChildOrder] InitFromParams: Incoming params was a nullptr");
somchildorder.cpp         ALGO_ELOG( "[SomChildOrder] InitFromParams: SSE algo instance unexpectedly attached to a " "child order that it did not create: " "order_id=%s " "algo_inst_id=%s ", std::string(order_id_str), m_parentOrder->GetOrderIDString() );
somchildorder.cpp     ALGO_ILOG( "[SomChildOrder] InitFromParams: Successfully initialized using params: " "order_ptr=%p " "ttsdk_order=%p " "parent_order_id=%s " "order_id=%s " "order_type=%s " "price=%0.8f " "trg_price=%0.8f " "order_qty=%0.8f " "working_qty=%0.8f " "cum_qty=%0.8f " "last_fill_prc=%0.8f " "last_fill_qty=%0.8f " "last_request_id=%d " "last_exec_type=%d " "last_message=%s " "synth_status=%s " "algo_instr_id=%llu " "m_original_time_sent=%llu(%s)", (void*)this, (void*)m_order, m_parentOrder->GetOrderIDString(), std::string(order_id_str), TTSDK_OrderTypeToString(ord_type), price, trg_price, quantity, working_quantity, cum_quantity, last_fill_price, last_fill_quantity, m_lastRequestId, ord_exec_type, std::string(message), TTSDK_SYNTH_STATUS_STR[m_synth_status], algo_instr_id, m_original_time_sent, original_date_sent_string);
somchildorder.cpp     ALGO_ILOG("[SomChildOrder] OnAttach: Successfully downloaded latest order snapshot" " from ledger - initializing SomChildOrder using the order snapshot:" " order=%p" " order_snapshot=%p" " parent_order_id=%s" " user_request_id=%d" " order_status=%s", (void*)m_order, order_snap.get(), m_parentOrder->GetOrderIDString(), user_request_id, TTSDK_OrderStatusToString(order_snap->last_status));
somchildorder.cpp         ALGO_ELOG("[SomChildOrder] OnAttach: Initialization failed:" " order=%p" " order_snapshot=%p" " parent_order_id=%s" " user_request_id=%d", (void*)m_order, order_snap.get(), m_parentOrder->GetOrderIDString(), user_request_id);
somchildorder.cpp     ALGO_ILOG("[SomChildOrder] OnOrderRequestFailed:" " event=%s" " order=%p" " parent_order_id=%s" " order_id=%s" " request_id=%d" " last_request_id=%d" " failure_status_flagss=0x%X" " m_order_status=%s", TTSDK_OrderEventToString(event), (void*)m_order, m_parentOrder->GetOrderIDString(), m_orderIdString, user_request_id, m_lastRequestId, failure_status_flags, TTSDK_OrderStatusToString(m_order_status));
somchildorder.cpp         ALGO_ILOG( "[SomChildOrder] " "order_id=%s " "parent_order_id=%s " "PayUp!! ticks=%d, new_price=%0.8f" , m_orderIdString, m_parentOrder->GetOrderIDString(), ticks, new_price );
somchildorder.cpp         ALGO_ILOG("Order suspended: " "order_id=%s " "parent_order_id=%s " "m_workingQty=%0.8f " "m_orderQty=%0.8f " "m_orderPrice=%0.8f", m_orderIdString, m_parentOrder->GetOrderIDString(), m_workingQty, m_orderQty, m_orderPrice);
somchildorder.cpp             ALGO_ILOG("Order Expired and will be resubmit " "order_id=%s " "parent_order_id=%s " "m_workingQty=%0.8f " "m_orderQty=%0.8f " "m_orderPrice=%0.8f " , m_orderIdString, m_parentOrder->GetOrderIDString(), m_workingQty, m_orderQty, m_orderPrice);
somchildorder.cpp     ALGO_ILOG("[SomChildOrder] RemoveInflightPending " "parent_order_id=%s " "m_confirmedRequestId=%d " "m_lastRequestId=%d " , m_parentOrder->GetOrderIDString(), m_confirmedRequestId, m_lastRequestId);
somchildorder.cpp         ALGO_ILOG("No need to resubmit " "order_id=%s " "parent_order_id=%s " "m_order_status=%s ", m_orderIdString, m_parentOrder->GetOrderIDString(), TTSDK_OrderStatusToString(m_order_status));
somchildorder.cpp     ALGO_ILOG("Resubmit " "[order_id=%s " "parent_order_id=%s " "m_order_status=%s] " "ChangeOrder to " "m_orderQty=%0.8f " "m_orderPrice=%0.8f " "m_triggerPrice=%0.8f ", m_orderIdString, m_parentOrder->GetOrderIDString(), TTSDK_OrderStatusToString(m_order_status), m_orderQty, m_orderPrice, m_triggerPrice);
somchildorder.cpp         ALGO_ILOG("[SomChildOrder] GTM delete ok received; sending market order " "order_id=%s " "parent_order_id=%s " "quantity=%0.8f", m_orderIdString, m_parentOrder->GetOrderIDString(), m_goToMarketQuantity);
somchildorder.cpp         ALGO_ILOG("[SomChildOrder] GTM add ok received; gtm complete " "order_id=%s " "parent_order_id=%s " "quantity=%0.8f", m_orderIdString, m_parentOrder->GetOrderIDString(), m_goToMarketQuantity);
somchildorder.cpp         ALGO_ILOG("[SomChildOrder] GTM change ok received; gtm complete " "order_id=%s " "parent_order_id=%s " "quantity=%0.8f", m_orderIdString, m_parentOrder->GetOrderIDString(), m_goToMarketQuantity);
somchildorder.cpp         ALGO_ELOG("[SomChildOrder] GTM reject received; gtm failed " "order_id=%s " "parent_order_id=%s " "quantity=%0.8f", m_orderIdString, m_parentOrder->GetOrderIDString(), m_goToMarketQuantity);
somchildorder.cpp         ALGO_WLOG("[SomChildOrder] Unknown GTM event received " "order_id=%s " "parent_order_id=%s " "event=%d", m_orderIdString, m_parentOrder->GetOrderIDString(), event);
withatick.cpp              ALGO_ILOG("[%s:%s] HandlePriceError: Disconnect Ignored " "No Child order.", GetName(), GetOrderIDString());
withatick.cpp                 ALGO_ILOG("[%s:%s] HandlePriceError: Disconnect Ignored " "WithATickApplied.", GetName(), GetOrderIDString());
withatick.cpp                 ALGO_ILOG("[%s:%s] SendSuspendStatus on disconnect " "WAT=true and WAT trigger=false", GetName(), GetOrderIDString());
bracket.cpp     ALGO_ILOG("[%s:%s] OnChildAdd: limitPrc=%0.8f OQ=%0.8f WQ=%0.8f", m_name, GetOrderIDString(), limitPrice, orderQuantity, workingQuantity);
bracket.cpp     ALGO_ILOG("[%s:%s] OnChildReplace: " "order_id=%s " "limitPrc=%0.8f " "OQ=%0.8f " "WQ=%0.8f " "external=%d " "requestsPending=%d", m_name, GetOrderIDString(), childOrder->GetOrderIDString(), limitPrice, orderQuantity, workingQuantity, external, requestsPending);
bracket.cpp     ALGO_ILOG("[%s:%s] OnChildCancel: " "order_id=%s " "external=%i " "ActionInProgress=%s", m_name, GetOrderIDString(), childOrder->GetOrderIDString(), external, USER_ACTION_STR[to_underlying(GetActionInProgress())]);
bracket.cpp         ALGO_ELOG("[%s:%s] OnChildCancel: Dropping. m_primaryOrder=nullptr.", m_name, GetOrderIDString());
bracket.cpp         ALGO_DLOG("[%s:%s] OnChildCancel: Dropping OCO callback.", m_name, GetOrderIDString());
bracket.cpp     ALGO_ILOG("[%s:%s] OnChildFill: limitPrc=%0.8f OQ=%0.8f WQ=%0.8f FQ=%0.8f FlPrc=%0.8f fill_type=%s", m_name, GetOrderIDString(), limit_price, order_quantity, working_quantity, fill_quantity, fill_price, FILL_TYPE_STR[to_underlying(fill_type)]);
bracket.cpp         ALGO_ELOG("[%s:%s] OnChildFill: Dropping callback - m_primaryOrder was unexpectedly a nullptr.", m_name, GetOrderIDString());
bracket.cpp         ALGO_DLOG("[%s:%s] OnChildFill: Dropping OCO callback.", m_name, GetOrderIDString());
bracket.cpp     ALGO_ELOG("[%s:%s] OnChildRequestFailure: " "requests_pending=%d " "status_flags=[%s] " "timeout=%d " "ActionInProgress=%s", m_name, GetOrderIDString(), requests_pending, OrderStatusFlagsString(status_flags), timeout, USER_ACTION_STR[to_underlying(GetActionInProgress())]);
bracket.cpp     ALGO_ELOG("[%s:%s] OnChildReject: " "order_id=%s " "external=%d " "requests_pending=%d " "message=%s " "ActionInProgress=%s", m_name, GetOrderIDString(), childOrder->GetOrderIDString(), external, requestsPending, std::string(message), USER_ACTION_STR[to_underlying(GetActionInProgress())]);
bracket.cpp         ALGO_ILOG("[%s:%s] StartWorking: Failed to calculate child price:%s", m_name, GetOrderIDString(), error);
bracket.cpp     ALGO_ILOG("[%s:%s] Add m_primaryOrder=%p", m_name, GetOrderIDString(), (void*)m_primaryOrder.get());
bracket.cpp     ALGO_ELOG("[%s:%s] HandleUpdate should not be called", m_name, GetOrderIDString());
bracket.cpp     ALGO_ILOG("[%s:%s] ResumeWorking: Printing algo params: " "order_qty=%0.8f " "filled_qty=%0.8f " "working_qty=%0.8f " "limit_prc=%0.8f " "trg_prc=%0.8f " "synth_status=%s " "ladder_display=%d " "order_type=%s", m_name, GetOrderIDString(), GetOrderQuantity(), GetCumFillQuantity(), GetWorkingQuantity(), GetLimitPrice(), GetTriggerPrice(), TTSDK_SYNTH_STATUS_STR[GetSynthStatus()], GetLadderDisplay(), TTSDK_OrderTypeToString(GetType()));
bracket.cpp     ALGO_ILOG("[%s:%s] ResumeWorking: Iterating through attached SomChildOrders, " "hedging each fill in a piece-meal fashion.", m_name, GetOrderIDString());
bracket.cpp         ALGO_ILOG("[%s:%s] ResumeWorking: Order Info: " "order_ptr=%p " "order_id=%s " "order_type=%s " "order_side=%d " "order_qty=%0.8f " "order_working_qty=%0.8f " "order_prc=%0.8f " "order_trg_prc=%0.8f ", m_name, GetOrderIDString(), static_cast<void *>(childOrder.get()), childOrder->GetOrderIDString(), TTSDK_OrderTypeToString(childOrder->GetType()), childOrder->GetSide(), childOrder->GetOrderQty(), childOrder->GetWorkingQty(), childOrder->GetLimitPrice(), childOrder->GetTriggerPrice());
bracket.cpp             ALGO_ILOG("[%s:%s] ResumeWorking: OCO order_id=%s", m_name, GetOrderIDString(), childOrder->GetOrderIDString());
bracket.cpp             ALGO_ILOG("[%s:%s] ResumeWorking: Collected filled qty from the child order (%p): " "child_filled_qty=%0.8f " "filled_qty_collected_from_children=%0.8f", m_name, GetOrderIDString(), (void*)m_primaryOrder.get(), childOrder->GetFilledQty(), cumFillQty);
bracket.cpp                     ALGO_ELOG("[%s:%s] ResumeWorking: Duplicate m_primaryOrder detected - " "the recovery process will fail.", m_name, GetOrderIDString());
bracket.cpp                     ALGO_ILOG("[%s:%s] ResumeWorking: This is the m_primaryOrder.", m_name, GetOrderIDString());
bracket.cpp                 ALGO_ILOG("[%s:%s] ResumeWorking: Recover m_primaryOrder=%p", m_name, GetOrderIDString(), (void*)m_primaryOrder.get());
bracket.cpp                 ALGO_ILOG("[%s:%s] ResumeWorking: Primary is fully filled or cancelled. " "order_id=%s", m_name, GetOrderIDString(), childOrder->GetOrderIDString());
bracket.cpp             ALGO_ILOG("[%s:%s] ResumeWorking: Hedging offline filled qty: " "parent_filled_qty=%0.8f " "filled_qty_collected_from_children=%0.8f " "offline_filled_qty=%0.8f", m_name, GetOrderIDString(), currCumFillQty, cumFillQty, offlineFilledQty);
bracket.cpp             ALGO_ELOG("[%s:%s] ResumeWorking: Bracket order recovery failed due to an unexpected scenario: " "failureOccurred=%s m_primaryOrder=%s", m_name, GetOrderIDString(), failureOccurred ? "true" : "false", m_primaryOrder == nullptr ? "nullptr" : "valid");
bracket.cpp         ALGO_ILOG("[%s:%s]: m_profitTargetTicks=%d, profitPrice=%f, m_stopTargetTicks=%d, triggerPrice=%f, fill_price=%f", m_name, GetOrderIDString(), m_profitTargetTicks, profitPrice, m_stopTargetTicks, triggerPrice, fill_price);
bracket.cpp         ALGO_ILOG("[%s:%s] Add ocoOrder=%p", m_name, GetOrderIDString(), (void*)ocoOrder.get());
bracket.cpp             ALGO_ILOG("[%s:%s] SendSuspendStatus on disconnect " "syn_status=%s", GetName(), GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[status]);
bracket.cpp                 ALGO_ILOG("[%s:%s] SendSuspendStatus on disconnect " "m_bracketOrderType=%d; NativeStopTriggered=false", GetName(), GetOrderIDString(), m_bracketOrderType);
bracket.cpp                 ALGO_ILOG("[%s:%s] HandlePriceError: Disconnect Ignored " "m_bracketOrderType=%d; m_primaryOrder=%s; NativeStopTriggered=%s", GetName(), GetOrderIDString(), m_bracketOrderType, m_primaryOrder ? "Exist": "Not exist", m_primaryOrder ? std::to_string(m_primaryOrder->NativeStopTriggered()): "N/A");
bracket.cpp             ALGO_ILOG("[%s:%s] HandlePriceError: Disconnect Ignored " "syn_status=%s", GetName(), GetOrderIDString(), TTSDK_SYNTH_STATUS_STR[status]);
volumeslicer.cpp         ALGO_ILOG("[%s:%s] OnWorkingPriceUpdate User action is progress, marking price update pending", m_name, GetOrderIDString());
volumeslicer.cpp     ALGO_ILOG( "[%s:%s] StartWorking: " "current_ttq=%0.8f ", m_name, GetOrderIDString(), snapshot->volume );
volumeslicer.cpp             ALGO_ILOG("[%s:%s] HandleUpdate: " "Qty reduced, halted slicing" " order_qty=%0.0f", m_name, GetOrderIDString(), new_qty);
volumeslicer.cpp         ALGO_ILOG( "[%s:%s] Restarting slicing: " "current_ttq=%0.8f ", m_name, GetOrderIDString(), snapshot->volume);
volumeslicer.cpp         ALGO_ILOG("[%s:%s] No remaining qty to generate slice schedule", m_name, GetOrderIDString());
volumeslicer.cpp         ALGO_WLOG("[%s:%s] Unable to generate slice schedule." " remaining_qty=%0.0f" " disc_qty=%0.0f", m_name, GetOrderIDString(), remaining_qty, disc_qty);
volumeslicer.cpp         ALGO_ILOG("[%s:%s] Generated new slice schedule. %s", m_name, GetOrderIDString(), GetSliceSummary());
retry.cpp         ALGO_ELOG("[Retry=%s] missing RetryCount parameter", GetOrderIDString());
retry.cpp         ALGO_ELOG("[Retry=%s] missing RetryInterval parameter", GetOrderIDString());
retry.cpp     ALGO_ILOG("[Retry=%s] OnChildAdd: " "limitPrc=%0.8f " "OQ=%0.8f " "WQ=%0.8f ", GetOrderIDString(), limitPrice, orderQuantity, workingQuantity);
retry.cpp         ALGO_ELOG("[%s:%s] HandleUpdate: %s", m_name, GetOrderIDString(), reject_msg);
retry.cpp     ALGO_ILOG("[%s:%s] HandleUpdate: " "result=%s " "synth_status=%s " "childOrdersSize=%zu " "childPRExists=%s " "retry_returned=%d ", GetName(), GetOrderIDString(), TTSDK_ERROR_STR[result], TTSDK_SYNTH_STATUS_STR[GetSynthStatus()], m_childOrders.size(), m_childPR ? "true" : "false", m_retry_returned);
retry.cpp     ALGO_ILOG("[%s:%s] OnChildReplace: " "limitPrc=%0.8f " "OQ=%0.8f " "WQ=%0.8f " "Extern=%d " "requestsPending=%d ", m_name, GetOrderIDString(), limitPrice, orderQuantity, workingQuantity, external, requestsPending);
retry.cpp         ALGO_ILOG("[%s:%s] OnScheduledEvent: StartTime fired ", m_name, GetOrderIDString());
retry.cpp         ALGO_ILOG("[%s:%s]: OnScheduledEvent: CheckInitializationProgress", m_name, GetOrderIDString());
retry.cpp         ALGO_WLOG("[%s:%s] OnScheduledEvent: Unexpected ScheduledEvent=%d", m_name, GetOrderIDString(), id);
retry.cpp             ALGO_ILOG("[%s:%s] OnChildOrderEvent" " status=%s" " attempts=%zu", m_name, GetOrderIDString(), TTSDK_OrderStatusToString(order_snap->last_status), instructions.attempts);
retry.cpp             ALGO_ILOG("[%s:%s] OnChildOrderEvent No retry attempted. OC returns on first shot" " status=%s", m_name, GetOrderIDString(), TTSDK_OrderStatusToString(order_snap->last_status));
retry.cpp     ALGO_ILOG("[%s:%s] count=%d interval=%d ", m_name, GetOrderIDString(), m_count, m_interval);
retry.cpp     ALGO_ILOG("[%s:%s] Retry is immune to Price error", GetName(), GetOrderIDString());
retry.cpp     ALGO_ILOG("[%s:%s] ResumeWorking:" "order_qty=%0.8f " "limit_prc=%0.8f " "synth_status=%s " "cum_filled_qty=%0.8f " "order_type=%s " "children_size=%zu ", m_name, GetOrderIDString(), GetOrderQuantity(), GetLimitPrice(), TTSDK_SYNTH_STATUS_STR[GetSynthStatus()], GetCumFillQuantity(), TTSDK_OrderTypeToString(GetType()), children_size);
retry.cpp         ALGO_ILOG("[%s:%s] ResumeWorking: Child Info: " "order_ptr=%p " "order_id=%s " "order_type=%s " "order_side=%d " "order_qty=%0.8f " "filled_qty=%0.8f " "order_working_qty=%0.8f " "order_prc=%0.8f " "order_trg_prc=%0.8f " "time_sent=%llu ", m_name, GetOrderIDString(), static_cast<void*>(childOrder.get()), childOrder->GetOrderIDString(), TTSDK_OrderTypeToString(childOrder->GetType()), childOrder->GetSide(), childOrder->GetOrderQty(), childOrder->GetFilledQty(), childOrder->GetWorkingQty(), childOrder->GetLimitPrice(), childOrder->GetTriggerPrice(), childOrder->GetTimeSent());
retry.cpp         ALGO_ELOG("[%s:%s] ResumeWorking: no working_child found.", m_name, GetOrderIDString());
retry.cpp         ALGO_ELOG("[%s:%s] ResumeWorking: child not working", m_name, GetOrderIDString());
position_mgr.cpp     ALGO_ILOG("PositionMgr::GetOrCreateRiskBucket: order_id=%s, required=%d", ttuuid(order_params->ord_id).to_string(), required);
position_mgr.cpp         ALGO_ELOG("Invalid params to create risk bucket");
position_mgr.cpp         ALGO_ILOG("PositionMgr: New risk bucket created." " bucket=%p" " parent_id=%s" " instr_id=%llu" " account_id=%llu" " side=%d", (void*)(bucket.get()), bucket->parent_id.to_string(), bucket->instr_id, bucket->account_id, bucket->side);
position_mgr.cpp             ALGO_ELOG("PositionMgr: AddOrderHandleToRiskBucket failed - PR order is already attached to this risk bucket." " bucket=%p" " current order_handle=%p" " request order_handle=%p", (void*)(bucket.get()), (void*)(sp.get()), (void*)(order_handle.get()));
position_mgr.cpp             ALGO_ELOG("PositionMgr: AddOrderHandleToRiskBucket failed - Risk bucket already tracking position limit." " bucket=%p" " order_handle=%p", (void*)(bucket.get()), (void*)(order_handle.get()));
position_mgr.cpp             ALGO_ELOG("PositionMgr: AddOrderHandleToRiskBucket failed - could not emplace into set." " bucket=%p" " order_handle_count=%zu" " order_handle=%p", (void*)(bucket.get()), bucket->order_handles.size(), (void*)(order_handle.get()));
position_mgr.cpp         ALGO_ILOG("PositionMgr: Attached PR order to risk bucket." " bucket=%p" " order_handle_count=%zu" " order_handle=%p", (void*)(bucket.get()), bucket->order_handles.size(), (void*)(order_handle.get()));
position_mgr.cpp         ALGO_ELOG("PositionMgr: AddOrderHandleToRiskBucket failed - could not emplace into set." " bucket=%p" " order_handle_count=%zu" " order_handle=%p", (void*)(bucket.get()), bucket->order_handles.size(), (void*)(order_handle.get()));
position_mgr.cpp     ALGO_ILOG("PositionMgr: Order handle added to risk bucket." " bucket=%p" " order_handle_count=%zu" " order_handle=%p", (void*)(bucket.get()), bucket->order_handles.size(), (void*)(order_handle.get()));
position_mgr.cpp         ALGO_ILOG("PositionMgr: Order handle removed from risk bucket." " bucket=%p" " order_handle_count=%zu" " order_handle=%p", (void*)(bucket.get()), bucket->order_handles.size(), (void*)(order_handle.get()));
position_mgr.cpp         ALGO_WLOG("PositionMgr: Removing untracked order handle." " bucket=%p" " order_handle_count=%zu" " order_handle=%p", (void*)(bucket.get()), bucket->order_handles.size(), (void*)(order_handle.get()));
position_mgr.cpp             ALGO_ILOG("PositionMgr: Risk bucket removed." " bucket=%p" " parent_id=%s" " instr_id=%llu" " account_id=%llu" " side=%d", (void*)(bucket.get()), bucket->parent_id.to_string(), bucket->instr_id, bucket->account_id, bucket->side);
position_mgr.cpp             ALGO_WLOG("PositionMgr: Removing untracked risk bucket." " bucket=%p" " parent_id=%s" " instr_id=%llu" " account_id=%llu" " side=%d", (void*)(bucket.get()), bucket->parent_id.to_string(), bucket->instr_id, bucket->account_id, bucket->side);
position_mgr.cpp     ALGO_ILOG("PositionMgr: Starting batch removal for parent_id=%s", parent_id.to_string());
position_mgr.cpp             ALGO_ILOG("PositionMgr: Risk bucket removed." " bucket=%p" " parent_id=%s" " instr_id=%llu" " account_id=%llu" " side=%d", (void*)((*it).get()), (*it)->parent_id.to_string(), (*it)->instr_id, (*it)->account_id, (*it)->side);
position_mgr.cpp         ALGO_ILOG("PositionMgr: Order not subject to check");
position_mgr.cpp             ALGO_ILOG("PositionMgr: Skipping check - PR qty is unchanged or increasing");
position_mgr.cpp             ALGO_ILOG("PositionMgr: Skipping check - Accrued technical debt");
position_mgr.cpp             ALGO_ILOG("PositionMgr: Skipping check since qty is unchanged or decreasing");
position_mgr.cpp     ALGO_ILOG("PositionMgr: Before send." " limit_breached=%d" " order_handle=%p" " bucket=%p" " parent_id=%s" " instr_id=%llu" " account_id=%llu" " side=%d" " current_logical_ord_qty=%0.8f" " desired_logical_ord_qty=%0.8f" " most_strict_limit=%0.8f" " position_limit=%0.8f" " worst_case_position=%0.8f" " is_delete=%d", limit_breached, (void*)(order_handle.get()), (void*)(bucket.get()), bucket->parent_id.to_string(), bucket->instr_id, bucket->account_id, bucket->side, current_logical_order_qty, desired_logical_order_qty, bucket->most_strict_limit, bucket->position_limit, bucket->worst_case_position, is_delete);
position_mgr.cpp     ALGO_ILOG("PositionMgr: Updating on receive." " limit_breached=%d" " order_handle=%p" " bucket=%p" " parent_id=%s" " instr_id=%llu" " account_id=%llu" " side=%d" " previous_logical_order_qty=%0.8f" " current_logical_ord_qty=%0.8f" " inflight_request_exists=%d" " inflight_logical_order_qty=%0.8f" " most_strict_limit=%0.8f" " position_limit=%0.8f" " worst_case_position=%0.8f" " is_pr=%d", limit_breached, (void*)(order_handle.get()), (void*)(bucket.get()), bucket->parent_id.to_string(), bucket->instr_id, bucket->account_id, bucket->side, previous_logical_order_qty, current_logical_order_qty, inflight_request_exists, inflight_logical_order_qty, bucket->most_strict_limit, bucket->position_limit, bucket->worst_case_position, is_pr);
position_mgr.cpp         ALGO_ILOG("PositionMgr: DiscountWorstCasePositionByFill: Order not subject to check");
position_mgr.cpp             ALGO_ILOG("PositionMgr: New risk bucket created (as sibling)." " bucket=%p" " parent_id=%s" " instr_id=%llu" " account_id=%llu" " side=%d", (void*)(sibling.get()), sibling->parent_id.to_string(), sibling->instr_id, sibling->account_id, sibling->side);
position_mgr.cpp     ALGO_ILOG("PositionMgr: Discounting sibling worst position." " bucket=%p" " parent_id=%s" " instr_id=%llu" " account_id=%llu" " side=%d" " fill_qty=%0.8f" " sibling.bucket=%p" " sibling.position_limit=%0.8f" " sibling.worst_case_position=%0.8f", (void*)(bucket.get()), bucket->parent_id.to_string(), bucket->instr_id, bucket->account_id, bucket->side, fill_qty, (void*)(sibling.get()), sibling->position_limit, sibling->worst_case_position);
position_mgr.cpp         ALGO_ILOG("PositionMgr: TryUpdateSenders failed - arguments invalid.");
position_mgr.cpp         ALGO_ILOG("PositionMgr: TryUpdateSenders failed - no order handles in the bucket." " bucket=%p", (void*)(bucket.get()));
position_mgr.cpp         ALGO_ILOG("PositionMgr: Switched to OC sender for:" " order_id=%s" " bucket=%p" " order_handle=%p", std::string(order_uuid_string), (void*)(bucket.get()), (void*)(order_handle.get()));
orderd.cpp         ALGO_WLOG("~client_order_data order_handle.use_count=%lu ---Check for Leak", order_handle.use_count());
orderd.cpp     ALGO_DLOG("~client_order_data");
orderd.cpp     ALGO_DLOG("~orderd__order_handle");
orderd.cpp     ALGO_ILOG("OrderD::OrderD Constructor, inst_id: %s, m_instanceIdHash=%llu (0X%08X)", m_instanceId.to_string(), m_instanceIdHash, m_instanceIdHash);
orderd.cpp     ALGO_ILOG("HOW BAD IS sizeof(orderd__order_handle)=%zu", sizeof(orderd__order_handle));
orderd.cpp     ALGO_ILOG("HOW BAD IS sizeof(NewOrderSingle)=%zu", sizeof(NewOrderSingle));
orderd.cpp     ALGO_ILOG("HOW BAD IS sizeof(OrderCancelReplaceRequest)=%zu", sizeof(OrderCancelReplaceRequest));
orderd.cpp     ALGO_ILOG("HOW BAD IS sizeof(OrderSmallPriceQtyRequest)=%zu", sizeof(OrderSmallPriceQtyRequest));
orderd.cpp     ALGO_ILOG("HOW BAD IS sizeof(OrderCancelRequest)=%zu", sizeof(OrderCancelRequest));
orderd.cpp     ALGO_ILOG("OrderD::Shutdown...");
orderd.cpp     ALGO_ILOG("OrderD_DestroyClientData");
orderd.cpp         ALGO_ILOG("OrderD::Shutdown orderd__init_state_process_common");
orderd.cpp     ALGO_ILOG("OrderD::Shutdown returning");
orderd.cpp         ALGO_ILOG( "Initializing OrderD:\n" " sender_location_id : %s\n" " lbm onload : %u\n" " lbm affinity : %d\n" " orderd affinity : %d\n" " unsolicited_enabled : %d\n" " rate_control : %s\n" " risk_senders : %s\n" " send_child_algo_to_local : %d\n" " bookie_dl_batch_size : %d\n" , m_sender_location_id, m_lbmOnload, m_lbmAffinity, m_orderdAffinity, m_unsolicited_enabled, (m_rate_control == orderd__rate_control_limited) ? "limited" : "none", risk_senders, m_send_child_algo_to_local, m_bookieDownloadBatchSize );
orderd.cpp         ALGO_ILOG( "ledger topic=%s", ossLedger.str());
orderd.cpp             ALGO_ILOG("Created Risk sender and OU.M receiver market=%u account=%llu", risk_sender.market_id, risk_sender.account_id);
orderd.cpp         ALGO_ELOG(error);
orderd.cpp                 ALGO_DLOG( "Failure decoding received error=%s, message=\"%s\"", ORDERD_ERROR_STR[orderd_error], std::string(error) );
orderd.cpp                 ALGO_WLOG( "Failure decoding received error=%s, message=%s", ORDERD_ERROR_STR[orderd_error], std::string(error) );
orderd.cpp         ALGO_DLOG("Beginning of transport session. Topic=%s lbm_source=%s", std::string(message.TopicName()), std::string(message.Source()));
orderd.cpp         ALGO_DLOG("End of transport session. Topic=%s lbm_source=%s", std::string(message.TopicName()), std::string(message.Source()));
orderd.cpp     ALGO_ILOG("OrderD::BookieDataReceived, length=%u, topicName=%s, source=%s", message.Length(), std::string(message.TopicName()), std::string(message.Source()));
orderd.cpp         ALGO_ELOG("Fail to get order_status from ledger data. error=%s", ORDERD_ERROR_STR[orderd_error]);
orderd.cpp             ALGO_ELOG("Failed to find order handle after Ledger download," " download requestor will not get any callback:" " request_id=%s" " order_id=%s", request_id_str, order_id.to_string());
orderd.cpp             ALGO_ELOG("CompleteBookieResponse failed: Delivering failure response to listeners:" " request_id=%s" " order_id=%s" " error=%s" " error_msg=%s", request_id_str, order_id.to_string(), ORDERD_ERROR_STR[error], error_msg);
orderd.cpp             ALGO_ILOG("CompleteBookieResponse success: Delivering success response to listeners:" " request_id=%s" " order_id=%s", request_id_str, order_id.to_string());
orderd.cpp         ALGO_ELOG("CleanupChildOrderReceived: Decoding failed, dropping message." " request_id=%s", response.req_id);
orderd.cpp     ALGO_ILOG("CleanupChildOrderReceived: Received Ledger Response:" " request_id=%s" " num_children=%zu", response.req_id, response.num_children);
orderd.cpp             ALGO_WLOG("CleanupChildOrderReceived: Cannot find matching request." " request_id=%s", response.req_id);
orderd.cpp             ALGO_ILOG("CleanupChildOrderReceived: %s child." " order_id=%s" " parent_id=%s" " user_id=%llu" " order_status=%s" " leave_on_cancel=%d" " is_pr_order=%d " " pr_only=%d", ((skip) ? "Skipping" : "Canceling"), order_id.to_string(), child_cleanup_iter->parent_id.to_string(), child_status.params.user_id, TTSDK_OrderStatusToString(child_status.status_type), leave_on_cancel, is_pr_order, pr_only);
orderd.cpp             ALGO_ILOG("CleanupChildOrderReceived: No action required, untracking." " parent_id=%s", child_cleanup_iter->parent_id.to_string());
orderd.cpp         ALGO_ILOG("InitPositionReserveOrderHandleFromSnapshot: Initializing PR order from Ledger download:" " request_id=%s" " order_id=%s", response->req_id, download_order_id.to_string());
orderd.cpp         ALGO_ELOG("InitOrderHandlesFromSnapshot: couldn't find class_1_2_fields for parent_order_id=%s", algo_inst_id.to_string());
orderd.cpp             ALGO_ELOG("InitOrderHandlesFromSnapshot: Failure - group adoption by Parent Order ID is not supported yet:" " request_id=%s", response->req_id);
orderd.cpp         ALGO_ILOG("InitOrderHandlesFromSnapshot: Initializing order from Ledger download:" " request_id=%s" " order_id=%s" " parent_order_id=%s" " m_classOneTwoForRecoveryByAlgoId_size=%zu", response->req_id, download_order_id.to_string(), algo_inst_id.to_string(), m_classOneTwoForRecoveryByAlgoId.size());
orderd.cpp             ALGO_ELOG("CompleteBookieResponse failed: Delivering failure response to requestor:" " request_id=%s" " order_id=%s" " error=%s" " error_msg=%s", response->req_id, download_order_id.to_string(), ORDERD_ERROR_STR[error], error_msg);
orderd.cpp     ALGO_ILOG("DiscardRecoveredPROrders: Iterating through recovered child orders to discard PR orders (if any): " "parent_id=%s " "num_children=%zu", parent_order_id.to_string(), response->num_children);
orderd.cpp         ALGO_ILOG("DiscardRecoveredPROrders: No child orders found: " "parent_id=%s ", parent_order_id.to_string());
orderd.cpp         ALGO_ELOG("DiscardRecoveredPROrders: Memory allocation failed for new_children_array: " "parent_id=%s ", parent_order_id.to_string());
orderd.cpp         ALGO_ILOG("DiscardRecoveredPROrders: Discarding PR child order: " "pr_order_id=%s " "parent_id=%s " "user_id=%llu " "order_status=%s " "should_cancel=%s", pr_order_id.to_string(), parent_order_id.to_string(), child_status.params.user_id, TTSDK_OrderStatusToString(child_status.status_type), should_cancel ? "true" : "false");
orderd.cpp         ALGO_ILOG("DiscardRecoveredPROrders: Sent cancels for PR child orders, tracking pending cleanup for possible retry: " "parent_id=%s", parent_order_id.to_string());
orderd.cpp     ALGO_ILOG("DiscardRecoveredPROrders: Finished iteration: " "parent_id=%s " "new_num_children=%zu", parent_order_id.to_string(), response->num_children);
orderd.cpp     ALGO_ILOG("RecoverChildOrderReceived: Received Ledger Response:" " request_id=%s" " num_children=%zu" " result=%d", response.req_id, response.num_children, response.result);
orderd.cpp             ALGO_ELOG("RecoverChildOrderReceived: Request not found:" " request_id=%s", response.req_id);
orderd.cpp                 ALGO_ELOG("InitPositionReserveOrderHandleFromSnapshot failed:" " request_id=%s" " error=%s", response.req_id, ORDERD_ERROR_STR[error]);
orderd.cpp                 ALGO_ELOG("InitOrderHandlesFromSnapshot failed:" " request_id=%s" " error=%s", response.req_id, ORDERD_ERROR_STR[error]);
orderd.cpp     ALGO_ILOG("Added SyntheticSender for topic=%s", topic);
orderd.cpp             ALGO_ILOG("Found SyntheticSender for topic=%s key=%s", topic, found->first);
orderd.cpp         ALGO_ELOG("Failed to find SyntheticSender for topic=%s", topic);
orderd.cpp             ALGO_ILOG("Found SyntheticSender for exch_order_assoc=%s key=%s", std::string(exch_order_assoc), found->first);
orderd.cpp         ALGO_ELOG("Failed to find SyntheticSender for exch_order_assoc=%s", std::string(exch_order_assoc));
orderd.cpp     ALGO_ELOG("Can not find Synthetic sender for params_internal or exch_order_assoc");
orderd_client.cpp             ALGO_ELOG( "---------------------------------------------\n" "ScheduleOrderDThreadEvent NullPtrException for OrderRequestInfo!\n" "--------------------------------------------- \n" );
orderd_client.cpp         ALGO_DLOG("DeleteClientOrder Success key=%lu user_order_id=%p", key, user_order_id);
orderd_client.cpp         ALGO_ELOG("DeleteClientOrder NOT_FOUND key=%lu user_order_id=%p", key, user_order_id);
orderd_client.cpp         ALGO_ILOG("DeleteClientOrderDataFromAccountIdMap, account_id=%llu user_order_id=%p", iter.first, user_order_id);
orderd_client.cpp                 ALGO_ILOG("DeleteClientOrderDataFromAccountIdMap, account_id=%llu user_order_id=%p erased!!", iter.first, user_order_id);
orderd_client.cpp         ALGO_DLOG("OrderD_DeliverResponse USER_REQ = 0");
orderd_client.cpp         ALGO_ELOG("ProcessNewOrder failed error=%s ", ORDERD_ERROR_STR[error]);
orderd_client.cpp         ALGO_ELOG("ProcessNewOrder failed error=%s ", ORDERD_ERROR_STR[error]);
orderd_client.cpp             ALGO_ELOG( "ProcessNewOrder failed client_ord_data->order_handle will be set to null. error=%s ", ORDERD_ERROR_STR[error] );
orderd_client.cpp         ALGO_ILOG( "INSERT client_ord_data " " cli_ord_data=%p " " cli_ord_data.use_count=%lu " " user_order_id=%p (hash=%lu)" " order_handle=%p ok=%d " "inflight_state=[order_qty=%0.8f leaves_qty=%0.8f cum_qty=%0.8f disp_qty=%0.8f]", (void *)client_ord_data.get(), client_ord_data.use_count(), (void*)client_ord_data->user_order_id, UserOrderIDHashValue( client_ord_data->user_order_id), client_ord_data->order_handle.get(), ok, inflight.order_state.params.order_qty, inflight.order_state.params.wrk_qty, inflight.order_state.params.cum_qty, inflight.order_state.params.disp_qty );
orderd_client.cpp         ALGO_ELOG( "ProcessDownloadOrder[order_id=%s] failed due to" "[user_order_id=%p][%016X %lu] already has a client_ord_data=%p", std::string(order_uuid_string), user_order_id, UserOrderIDHashValue(user_order_id), UserOrderIDHashValue(user_order_id), client_ord_data.get() );
orderd_client.cpp         ALGO_ELOG( "OrderD_DownloadOrder failed client_ord_data->order_handle will be set to null. error=%s ", ORDERD_ERROR_STR[error] );
orderd_client.cpp     ALGO_ILOG( "ProcessDownloadOrder: " "INSERT client_ord_data " "ok=%d " "client_ord_data=%p " "user_order_id(hash)=%p(%lu) " "order_handle=%p " , ok, reinterpret_cast<void*>(client_ord_data.get()), client_ord_data->user_order_id, UserOrderIDHashValue(client_ord_data->user_order_id), reinterpret_cast<void*>(client_ord_data->order_handle.get()) );
orderd_client.cpp         ALGO_ELOG("ProcessDetachOrphan: failed to find client_ord_data for user_order_id=%p", user_order_id);
orderd_client.cpp         ALGO_ELOG("ProcessDetachOrphan: No order_handle for user_order_id=%p", user_order_id);
orderd_client.cpp         ALGO_WLOG("ProcessDetachOrphan: Skip: " "vector_listening_clients.size=%zu >1 " "order_handle=%p " "order_id=%s", order_handle->vector_listening_clients.size(), (void*)(order_handle.get()), order_id);
orderd_client.cpp         ALGO_WLOG("ProcessDetachOrphan: Skip: " "order_handle=%p " "order_id=%s " "state_flags=[%s] " "wrk_qty=%0.8f", (void*)(order_handle.get()), order_id, OrderStateFlagAsStr(order_handle->state_flags), order_handle->current_state_data.params.wrk_qty);
orderd_client.cpp     ALGO_ILOG("ProcessDetachOrphan: order_id=%s cleanup order_handle=%p AND client_ord_data=%p", order_id, (void*)(order_handle.get()), user_order_id);
orderd_client.cpp         ALGO_ELOG("ProcessDetachOrder[%p] failed to find order", user_order_id);
orderd_client.cpp         ALGO_ELOG("ProcessDetachOrder[%p] order_handle is null", user_order_id);
orderd_client.cpp         ALGO_WLOG("PerformDetachOrder: " "client_ord_data not in vector_listening_clients for " "order_handle=%p " "order_id=%s", order_handle.get(), order_handle->current_order_id());
orderd_client.cpp         ALGO_WLOG("ProcessDetachOrder: " "Detaching %s " "algo_id=%s from " "order_handle=%p " "order_id=%s " "vector_listening_clients.size=%zu " "keep order_handle alive", what, ttuuid(algo_inst_id).to_string(), order_handle.get(), order_handle->current_order_id(), vector_size);
orderd_client.cpp         ALGO_ELOG( "ProcessChangeOrder user_order_id=%p failed due to: can not find client_ord_data", change_order->user_order_id );
orderd_client.cpp             ALGO_ILOG( "Request to delete an unknown in-flight order (Add/Download/Attach request is still pending) - " "the order request probably failed before creation of client_ord_data. " "Response no-op. [user_order_id=%p] ", change_order->user_order_id );
orderd_client.cpp         ALGO_ELOG( "ProcessChangeOrder user_order_id=%p failed due to: order_handle is NULL ", change_order->user_order_id );
orderd_client.cpp              ALGO_ELOG( "delete_inflight_order failed. " "order_handle=%p " "user_order_id=%p " "state_flags=[%s] ", (void*)client_ord_data->order_handle.get(), client_ord_data->user_order_id, OrderStateFlagAsStr(client_ord_data->order_handle->state_flags) );
orderd_client.cpp         ALGO_ELOG( "ProcessChangeOrder user_order_id=%p failed due to: " "%s " "%s " "%s", change_order->user_order_id, fail_on_external_event_seen?"external_event_seen":"", fail_on_external_delete_seen?"external_delete_seen":"", fail_on_full_fill_seen?"full_fill_seen":"" );
orderd_client.cpp         ALGO_ELOG("ProcessChangeOrder user_order_id=%p failed due to risk reject seen", change_order->user_order_id);
orderd_client.cpp         ALGO_WLOG( "ProcessChangeOrder user_order_id=%p failed due to: " "error=%s ", change_order->user_order_id, ORDERD_ERROR_STR[error] );
orderd_client.cpp     ALGO_ILOG("---------------------------------------------\n" "OrderDRegisterThreadSwitch\n" "--------------------------------------------- \n" );
orderd_client.cpp             ALGO_ILOG("DestroyOrderData client_ord_data=%p ", (void*)client_ord_data.get());
orderd_client.cpp                     ALGO_ILOG("DestroyOrderData: Removing OMA Parent");
orderd_client.cpp             ALGO_ILOG("Removing references to parent algo." " parent_id=%s", parent_id.to_string());
orderd_client.cpp             ALGO_ILOG("ProcessClientRequest failed due to max_order_rate limit ");
orderd_client.cpp             ALGO_ELOG( "ProcessClientRequest failed: " "request=%s " "user_request_id=%llu " "user_order_id=%p " "error=%s " "msg=[%s] " "status_flags=%d ", ORDERD_REQUEST_ID_STR[request->id], request->user_request_id, user_order_id, ORDERD_ERROR_STR[error], std::string(response.data.request_failure.msg), response.data.request_failure.status_flags );
orderd_client.cpp             ALGO_ELOG("ProcessRequestUnsolicitedOrder failed error=%s ", ORDERD_ERROR_STR[error]);
orderd_client.cpp         ALGO_ILOG("ProcessRequestUnsolicitedOrder account_id=%llu", request->data.unsolicited_order.account_id);
orderd_client.cpp     ALGO_ILOG("ProcessRequestCopyField [%s] %s m_classOneTwoForRecoveryByAlgoId_size=%zu", algo_inst_ttuuid.to_string(), class_1_2->ShortDebugString().to_std(), m_classOneTwoForRecoveryByAlgoId.size());
orderd_client.cpp         ALGO_ILOG("DownloadAndCleanupChildOrder: Tracking child cleanup." " parent_id=%s " " pr_only=%d", cleanup_data.parent_id.to_string(), cleanup_data.pr_only);
orderd_client.cpp         ALGO_ELOG("OrderD::EncodeAndSendChildrenDownloadRequest: Failed to encode LBM request: " "request_buffer_size=%zu " "encoded_size=%zu ", std::strlen(request_buffer), buf_size);
orderd_client.cpp         ALGO_ELOG("OrderD::EncodeAndSendChildrenDownloadRequest: Failed to send LBM request, algo_inst_id=%s, ledger_request_tid=%llu ", ttalgo.to_string(), request->data.recover_order.ledger_request_tid);
orderd_client.cpp         ALGO_ELOG("OrderD::DownloadAndRecoverChildOrder: Failed to allocate request copy.");
orderd_client.cpp         ALGO_ELOG("OrderD::DownloadAndRecoverChildOrder: Failed to encode and send LBM request!");
orderd_client.cpp         ALGO_ELOG("OrderD::DownloadAndRecoverChildOrder: Request is unexpectedly missing TID!");
orderd_client.cpp             ALGO_WLOG("OrderD::DownloadAndRecoverChildOrder: Download already in pending list:" " request_id=%s" " old_request_time=%llu", std::string(request_copy->data.recover_order.ledger_request_tid), (*iter)->data.recover_order.ledger_request_time);
orderd_client.cpp         ALGO_ILOG("OrderD::DownloadAndRecoverChildOrder: Download added to pending list:" " request_id=%s" " request_time=%llu" " vector_size=%zu", std::string(request_copy->data.recover_order.ledger_request_tid), request_copy->data.recover_order.ledger_request_time, m_pendingDownloadRequests.size() + 1);
orderd_client.cpp         ALGO_ELOG("UpdateCurrentUserId[%p] failed to find order", user_order_id);
orderd_client.cpp         ALGO_ELOG("UpdateCurrentUserId[%p] order_handle is null", user_order_id);
orderd_client.cpp     ALGO_ILOG("UpdateCurrentUserId[%p]: %llu->%llu", user_order_id, client_ord_data->order_handle->current_user_id, new_user_id);
orderd_client.cpp         ALGO_ELOG("UpdateGroupIds[%p] failed to find order", user_order_id);
orderd_client.cpp         ALGO_ELOG("UpdateGroupIds[%p] order_handle is null", user_order_id);
orderd_client.cpp         ALGO_ELOG("UpdateGroupIds[%p] order_handle has no new_order_single", user_order_id);
orderd_client.cpp     ALGO_ILOG("UpdateGroupIds[%p]: order_id=%s order_handle->current_state_data.params.type=%d %s", user_order_id, order_id_ours.to_string(), order_handle->current_state_data.params.type, GroupIDsToString(group_ids));
orderd_client.cpp         ALGO_ELOG("SendChildOrderPass: Failed to send UpdateOrder for order_id=%s (error=%s)", order_id.to_string(), ORDERD_ERROR_STR[error]);
orderd_client.cpp     ALGO_ILOG("SendChildOrderPass: Sent UpdateOrder for order_id=%s current_user_id=%llu %s", order_id.to_string(), order_handle->current_user_id, GroupIDsToString(order_handle->group_ids));
orderd_client.cpp         ALGO_ELOG("UpdateClass2Fields: failed to find ttsdk_order=%p", ttsdk_order);
orderd_client.cpp         ALGO_ELOG("UpdateClass2Fields: ttsdk_order=%p has null order_handle", ttsdk_order);
orderd_orders.cpp     ALGO_ILOG("AddOrderHandle result=%s ----- order_id=%s size=%zu", (emplaced) ? "SUCCESS" : "FAILURE", order_id.to_string(), m_mapOrderHandle.size());
orderd_orders.cpp     ALGO_ILOG("DeleteOrderHandle result=%s order_id=%s size=%zu", (erased == 0) ? "NOT_FOUND" : "SUCCESS", order_id.to_string(), m_mapOrderHandle.size());
orderd_orders.cpp         ALGO_ELOG("MoveOrderHandle old_order_id=%s not exist", old_order_id.to_string());
orderd_orders.cpp             ALGO_ELOG("orderd: Display quantity greater than order quantity " "disp_qty=%.8f > real_quantity=%.8f", disp_qty, real_quantity);
orderd_orders.cpp                 ALGO_ILOG("Place ASE Order: not added to m_setWireHeaderParent");
orderd_orders.cpp                 ALGO_ILOG("PlaceOrder: m_setWireHeaderParent.size=%u", m_setWireHeaderParent.size());
orderd_orders.cpp     ALGO_ILOG( "PlaceOrder: " "user_request_id=%u " "[parent_id=%s order_id=%s] " "user_id=%llu " "originating_user_id=%llu " "price=%0.8f " "order_qty=%0.8f " "side=%d " "base_quantity=%0.8f " "real_quantity(order_qty-base_quantity)=%0.8f " "trg_price=%lf " "disp_qty=%0.8f " "user_order_id=%p " "price_deviation_data=%s " "exch_order_assoc=%s " "account_id=%llu " "broker_id=%llu " "best_market_price=%lf " "non_matching=%d " "instr_id=%llu " "topic=%s " , user_request_id, order_handle->current_parent_order_id(), uuid.to_string(), user_id, request_params->originating_user_id, request_params->price, request_params->order_qty, request_params->side, base_quantity, real_quantity, isnan(request_params->trg_prc) ? NAN : request_params->trg_prc, disp_qty, user_order_id, ToString(price_deviation_data), std::string(order_handle->exch_assoc), request_params->account, request_params->broker, request_params->best_market_price, request_params->non_matching, request_params->instr_id, order_handle_to_topic(order_handle) );
orderd_orders.cpp             ALGO_ILOG("CancelOrder: " "user_request_id=%u " "[parent_id=%s order_id=%s] " "current_state=[%s] " "base_quantity=%0.8f " "exch_order_assoc=%s ", user_request_id, order_handle->current_parent_order_id(), order_handle->current_order_id(), order_handle->current_state_data.to_string(), order_handle->base_quantity, std::string(order_handle->exch_assoc));
orderd_orders.cpp                 ALGO_ILOG("ChangeOrder Ignored: " "user_request_id=%u " "[parent_id=%s order_id=%s] " "Because leaves_qty==0 and " "logical order is pinned to " "original exchange order, so no new order will be placed" "request_price=%0.8f request_qty=%0.8f " "state_flags=[%s] " "exch_assoc=%s", user_request_id, order_handle->current_parent_order_id(), order_handle->current_order_id(), request_price, request_quantity, OrderStateFlagAsStr(order_handle->state_flags), std::string(order_handle->exch_assoc));
orderd_orders.cpp         ALGO_ILOG("CompleteQueuedChange: " "order_id=%s " "queued_request=[%s]", order_handle->current_order_id(), order_handle->queued_state.order_state.to_string());
orderd_orders.cpp         ALGO_ELOG("CompleteInflightAction: Position limit violated!");
orderd_orders.cpp         ALGO_WLOG("Received xfer_held_change. dropping it!!!!!!!!!!!!!!!!! " "Expect xfer_replace_cancel and xfer_replace_new soon " "order_id=%s", order_handle->current_order_id());
orderd_orders.cpp         ALGO_ILOG("OrderD::CompleteOrderChange: order_id=%s synth_type=%d", order_handle->current_order_id(), synth_type);
orderd_orders.cpp         ALGO_ELOG("OrderD::CompleteOrderChange: order_id=%s synth_type not available", order_handle->current_order_id());
orderd_orders.cpp                     ALGO_WLOG("OrderD::CompleteOrderChange: Unable to obtain order_handler for order_id=%s", order_id_string);
orderd_orders.cpp                             ALGO_ILOG("OrderD::CompleteOrderChange: skipping order_id=%s parent_order_id=%s status_flags=%08x", order_id_string, parent_id.to_string(), order_status->status_flags);
orderd_orders.cpp                             ALGO_ILOG("OrderD::CompleteOrderChange: passing down order_id=%s parent_order_id=%s status_flags=%08x", order_id_string, parent_id.to_string(), order_status->status_flags);
orderd_orders.cpp             ALGO_WLOG("OrderD::CompleteOrderChange: Unable to obtain synth_status for order_id=%s", order_id_string);
orderd_orders.cpp             ALGO_WLOG("Received PR order without a valid connection_id," " future orders placed in the risk bucket will route to Bouncer." " connection_id=%llu" " pr_order_id=%s" " risk_bucket=%p", cid, order_id.to_string(), (void*)(order_handle->risk_bucket.get()));
orderd_orders.cpp             ALGO_ILOG("Received PR order with a valid connection_id," " future orders placed in the risk bucket will route to OC," " attempting to switch to OC sender for existing orders." " connection_id=%llu" " pr_order_id=%s" " risk_bucket=%p", cid, order_id.to_string(), (void*)(order_handle->risk_bucket.get()));
orderd_orders.cpp                 ALGO_WLOG("Failed to get sender from lbmResourceMgr," " LBM senders for existing orders will not be updated.");
orderd_orders.cpp                     ALGO_WLOG("Failed to update senders in the risk bucket.");
orderd_orders.cpp         ALGO_ILOG("Received replace_full_filled, " "order_id=%s " "will ignore any mismatch of price/qty/trigger_price. " "will only check is_response_to_submit=%d ", order_handle->current_order_id(), is_response_to_submit);
orderd_orders.cpp         ALGO_ILOG("Can Not CompleteInflightAction: " "order_id=%s " "is_response_to_submit=%d " "is_qty_match=%d " "is_price_match=%d " "is_trigger_price_match=%d " "msg=%s", order_handle->current_order_id(), is_response_to_submit, is_qty_match, is_price_match, is_trigger_price_match, ss.str());
orderd_orders.cpp             ALGO_ELOG("CompleteOrderChange(unsolicited): Position limit violated!");
orderd_orders.cpp             ALGO_ILOG("CompleteOrderCancel:[parent_id=%s ord_id=%s] " "synth_status=failed " "change response->status_type=%s " "order_handle->state_flags=%s", order_handle->current_parent_order_id(), order_handle->current_order_id(), TTSDK_OrderStatusToString(response->data.order_status.status_type), OrderStateFlagAsStr(order_handle->state_flags));
orderd_orders.cpp             ALGO_ILOG("CompleteOrderCancel:[parent_id=%s ord_id=%s] " "synth_status=expired", order_handle->current_parent_order_id(), order_handle->current_order_id());
orderd_orders.cpp         ALGO_WLOG("CompleteOrderCancel:[parent_id=%s ord_id=%s] xfer_replace_cancel. dropping it!!!!!!!!!!!!!!!!!", order_handle->current_parent_order_id(), order_handle->current_order_id());
orderd_orders.cpp             ALGO_ELOG("CompleteOrderCancel(unsolicited): Position limit violated!");
orderd_orders.cpp         ALGO_WLOG("HandleOrderReplaced Fail: same order_id=%s ", ttuuid(order_status->replaced_order_id).to_string());
orderd_orders.cpp     ALGO_ILOG("HandleOrderPendingNew:[parent_id=%s ord_id=%s] response->status_type=%s Will Drop this ER", order_handle->current_parent_order_id(), order_handle->current_order_id(), TTSDK_OrderStatusToString(response->data.order_status.status_type));
orderd_orders.cpp             ALGO_WLOG("HandleOrderPendingNew:[parent_id=%s ord_id=%s]. Now order_id=%s", order_handle->current_parent_order_id(), order_handle->current_order_id(), ttuuid(order_status->replaced_order_id).to_string());
orderd_orders.cpp             ALGO_ELOG("HandleOrderPendingNew:[parent_id=%s ord_id=%s] Sth Wrong! Received pending_new " "without ttsdk_order_xfer_replace_new flag, but order has gone through orderd__xfer_replace_cancel", order_handle->current_parent_order_id(), order_handle->current_order_id());
orderd_orders.cpp             ALGO_ILOG("HandleOrderRestate:[parent_id=%s ord_id=%s] " "synth_status=failed " "change response->status_type=%s", order_handle->current_parent_order_id(), order_handle->current_order_id(), TTSDK_OrderStatusToString(response->data.order_status.status_type));
orderd_orders.cpp             ALGO_ILOG("HandleOrderRestate:[parent_id=%s ord_id=%s] " "change response->status_type=%s", order_handle->current_parent_order_id(), order_handle->current_order_id(), TTSDK_OrderStatusToString(response->data.order_status.status_type));
orderd_orders.cpp         ALGO_WLOG("HandleOrderRestate:[parent_id=%s ord_id=%s]: Child order resurrected unexpectedly!", order_handle->current_parent_order_id(), order_handle->current_order_id());
orderd_orders.cpp             ALGO_ILOG("HandleOrderRestate:[parent_id=%s ord_id=%s] " "%s! " "change response->status_type=%s", order_handle->current_parent_order_id(), order_handle->current_order_id(), to_log, TTSDK_OrderStatusToString(order_status->status_type));
orderd_orders.cpp             ALGO_ELOG("HandleOrderRestate:[parent_id=%s ord_id=%s] " "%s! " "but order is NOT in pending_new", order_handle->current_parent_order_id(), order_handle->current_order_id(), to_log);
orderd_orders.cpp             ALGO_ILOG("Changing unsolicited reject to restatement with synth_status set to 'Failed' " "order_id=%s", order_handle->current_order_id());
orderd_orders.cpp         ALGO_ILOG("Ignore external reject. order_id=%s", order_handle->current_order_id());
orderd_orders.cpp         ALGO_ILOG("Received reject for " "parent_id=%s " "order_id=%s " "reject_detail=[%s] " "message=[%s] " "inflight_request=[%s] " "reject_reason=%s " "state_flag=[%s] " "order_pass_state=%s " "order_update_reason=%d - ignoring", parent_id, order_id, std::string(reject_detail), std::string(message), order_handle->inflight_state.order_state.to_string(), REJECT_REASON_STR[reason], OrderStateFlagAsStr(order_handle->state_flags), std::string(OrderPassToString(order_pass_state)), order_update_reason);
orderd_orders.cpp     ALGO_ELOG("Received reject for " "parent_id=%s " "order_id=%s " "reject_detail=[%s] " "message=[%s] " "inflight_request=[%s] " "reject_reason=%s " "state_flag=[%s] " "order_pass_state=%s " "order_update_reason=%d ", parent_id, order_id, std::string(reject_detail), std::string(message), order_handle->inflight_state.order_state.to_string(), REJECT_REASON_STR[reason], OrderStateFlagAsStr(order_handle->state_flags), std::string(OrderPassToString(order_pass_state)), order_update_reason);
orderd_orders.cpp                 ALGO_ILOG("CompleteOrderReject: " "parent_id=%s " "order_id=%s " "RetryInflightRequest OK", parent_id, order_id);
orderd_orders.cpp                 ALGO_ELOG("CompleteOrderReject: RetryInflightRequest Failed" "parent_id=%s " "order_id=%s " "error=%s ", parent_id, order_id, ORDERD_ERROR_STR[error]);
orderd_orders.cpp             ALGO_ELOG("CompleteOrderReject: No retry." "parent_id=%s " "order_id=%s " "inflight retry_count=%u ", parent_id, order_id, order_handle->inflight_state.retry_count);
orderd_orders.cpp         ALGO_ELOG("CompleteOrderReject: Position limit violated!");
orderd_orders.cpp             ALGO_ILOG("Risk reject received - queued change rejected as well." " parent_id=%s" " order_id=%s" " queued_request=[%s]", parent_id, order_id, order_handle->queued_state.order_state.to_string());
orderd_orders.cpp     ALGO_ILOG("RetryInflightRequest." "order_id=%s " "retry_count=%u " "inflight_request=[%s]", order_handle->current_order_id(), retry_count, order_handle->inflight_state.order_state.to_string());
orderd_orders.cpp                 ALGO_ILOG("CompleteFill:[parent_id=%s ord_id=%s] full_fill w xfer_fill last_fill_qty=%.8f current_wrk_qty=%.8f", order_handle->current_parent_order_id(), order_handle->current_order_id(), last_fill_qty, current_wrk_qty);
orderd_orders.cpp                 ALGO_ILOG("CompleteFill:[parent_id=%s ord_id=%s] partial_fill w xfer_fill while order in pending_new " "last_fill_qty=%.8f current_wrk_qty=%.8f", order_handle->current_parent_order_id(), order_handle->current_order_id(), last_fill_qty, current_wrk_qty);
orderd_orders.cpp             ALGO_ELOG("CompleteFill:[parent_id=%s ord_id=%s] xfer_fill But order NOT in pending_new", order_handle->current_parent_order_id(), order_handle->current_order_id());
orderd_orders.cpp         ALGO_ILOG("CompleteFill: %s " "order_id=%s " "last_fill_qty=%.8f " "current_wrk_qty=%.8f " "qty_diff=%.8f " "new_current_qty=%.8f", fp_gt(last_fill_qty, current_wrk_qty)?"Possible overfill detected" : "Order fully filled", std::string(order_uuid_string), last_fill_qty, current_wrk_qty, qty_diff, current_qty);
orderd_orders.cpp         ALGO_ILOG("CompleteFill: with orderd__pending_external " "fill=%s " "order_id=%s ", response->data.order_status.status_type == ttsdk_order_status_full_fill ? "Full": "Partial", order_handle->current_order_id());
orderd_orders.cpp         ALGO_ELOG("CompleteOrderTimeout: Position limit violated!");
orderd_orders.cpp                 ALGO_WLOG("CompleteOrderTimeout: Reject queued change: " " user_request_id=%llu" " order_handle=%p", user_request_id, (void*)(order_handle.get()));
orderd_orders.cpp                 ALGO_ELOG("CompleteOrderTimeout: Reject queued change but can NOT deliever: " " user_request_id=%llu" " order_handle=%p", user_request_id, (void*)(order_handle.get()));
orderd_orders.cpp             ALGO_DLOG("No parent algo type, skipping." " order_id=%s", order_id.to_string());
orderd_orders.cpp             ALGO_DLOG("SSE or ADL child, skipping." " order_id=%s", order_id.to_string());
orderd_orders.cpp             ALGO_DLOG("Child order is in middle of download, skipping." " order_id=%s", order_id.to_string());
orderd_orders.cpp             ALGO_DLOG("leave_on_cancel=true, skipping." " order_id=%s", order_id.to_string());
orderd_orders.cpp             ALGO_DLOG("Order not working, skipping." " order_id=%s", order_id.to_string());
orderd_orders.cpp             ALGO_DLOG("CancelAllChildren: Sending fire-and-forget PR cancel." " order_id=%s", order_id.to_string());
orderd_orders.cpp         ALGO_DLOG("CancelAllChildren: Sending fire-and-forget cancel." " order_id=%s", order_id.to_string());
orderd_orders.cpp             ALGO_WLOG("CancelFireAndForget: Failed to encode cancel for order_id=%s parent_id=%s error=%s", order_id.to_string(), parent_id.to_string(), ORDERD_ERROR_STR[error]);
orderd_orders.cpp         ALGO_WLOG("CancelFireAndForget: Failed to send cancel for " "order_id=%s " "parent_id=%s " "order_type=%s" "error=%s", order_id.to_string(), parent_id.to_string(), TTSDK_OrderTypeToString(order_type), ORDERD_ERROR_STR[error]);
orderd_orders.cpp         ALGO_ILOG("CancelFireAndForget: Successfuly send cancel for " "order_id=%s " "parent_id=%s " "order_type=%s", order_id.to_string(), parent_id.to_string(), TTSDK_OrderTypeToString(order_type));
orderd_orders.cpp         ALGO_ELOG("DeliverRecoveryResponse: Request is NULL, dropping response");
orderd_orders.cpp         ALGO_ELOG(error_msg.str());
orderd_orders.cpp         ALGO_ELOG(error_msg.str());
orderd_orders.cpp         ALGO_ILOG(error_msg.str());
orderd_orders.cpp             ALGO_ELOG(error_msg.str());
orderd_orders.cpp             ALGO_ELOG(error_msg.str());
orderd_orders.cpp             ALGO_ILOG("CompleteBookieResponse: " "Inserting downloaded orders Parent ID into Wire Header filter: " "has_parent=%d " "parent_algo_id=%llu " "parent_id=%s " "order_id=%s " "m_setWireHeaderParent.size=%u", has_parent, parent_algo_id, tt_parent_id.to_string(), tt_order_id.to_string(), m_setWireHeaderParent.size());
orderd_orders.cpp             ALGO_ELOG("CompleteBookieResponse: " "has_parent=%d " "parent_id=%s " "order_id=%s " "but no algo_id", has_parent, tt_parent_id.to_string(), tt_order_id.to_string());
orderd_orders.cpp         ALGO_ILOG("CompleteBookieResponse: " "Downloaded order does not have a Parent ID to insert into Wire Header filter: " "has_parent=%d " "parent_id=%s (invalid) " "order_id=%s " "m_setWireHeaderParent.size=%u", has_parent, tt_parent_id.to_string(), tt_order_id.to_string(), m_setWireHeaderParent.size());
orderd_orders.cpp         ALGO_ILOG("CompleteBookieResponse: " "Downloaded order is an Algo Order, inserting its Order ID into Wire Header Filter: " "order_id=%s " "m_setWireHeaderParent.size=%u", tt_order_id.to_string(), m_setWireHeaderParent.size());
orderd_orders.cpp             ALGO_ELOG("CompleteLedgerResponse: GetOrCreateRiskBucket failed!");
orderd_orders.cpp             ALGO_ELOG("CompleteLedgerResponse: AddOrderHandleToRiskBucket failed!");
orderd_orders.cpp             ALGO_ELOG("CompleteLedgerResponse: CheckPositionLimitOnReceive detected violation unexpectedly!");
orderd_orders.cpp         ALGO_ELOG("CompleteLedgerResponse: Failed to create LBM Synthetic Sender for ASE or AGG order - not supported yet");
orderd_orders.cpp             ALGO_ILOG("CompleteBookieResponse: Using Local Sender. " "algo order_id=%s will go to " "myself=%s", tt_order_id.to_string(), env::instance().get_instance_identifier());
orderd_orders.cpp             ALGO_ILOG("CompleteBookieResponse: Using Synthetic Sender." "algo order_id=%s will go to " "syntheticSenderPtr=%s", tt_order_id.to_string(), std::string(order_status->exch_assoc));
orderd_orders.cpp                 ALGO_ILOG("CompleteLedgerResponse: Using Channel Sender since PR has invalid connection ID." " order_id=%s" " bucket=%p" " order_handle=%p", tt_order_id.to_string(), (void*)(risk_bucket.get()), (void*)(order_handle.get()));
orderd_orders.cpp                 ALGO_ILOG("CompleteLedgerResponse: Using Direct Sender since PR has valid connection ID." " order_id=%s" " bucket=%p" " order_handle=%p" " connection_id=%llu", tt_order_id.to_string(), (void*)(risk_bucket.get()), (void*)(order_handle.get()), cid);
orderd_orders.cpp             ALGO_ILOG("CompleteLedgerResponse: Using Channel Sender." " order_id=%s" " order_handle=%p", tt_order_id.to_string(), (void*)(order_handle.get()));
orderd_orders.cpp         ALGO_ELOG("CompleteLedgerResponse: Failed to create LBM Sender or local sender!");
orderd_orders.cpp             ALGO_ELOG("CompleteLedgerResponse: Missing oma parent id when trying to download native order!");
orderd_orders.cpp             ALGO_ELOG("CompleteLedgerResponse: EncodeUpdateOrder failed:" " order_id=%s" " oma_parent_order_id=%s", tt_order_id.to_string(), std::string(oma_parent_uuid_string));
orderd_orders.cpp             ALGO_ILOG("CompleteLedgerResponse: Successfully EncodeUpdateOrder: " "order_id=%s now should have " "oma_parent_order_id=%s ", tt_order_id.to_string(), std::string(oma_parent_uuid_string));
orderd_orders.cpp             ALGO_WLOG("CompleteBookieResponse: Failed to send UpdateOrder:" " order_id=%s" " oma_parent_order_id=%s", tt_order_id.to_string(), std::string(oma_parent_uuid_string));
orderd_orders.cpp         ALGO_ILOG("CompleteBookieResponse: Sent UpdateOrder: " "order_id=%s " "set oma_parent_id=%s " "send to market_id=%d", tt_order_id.to_string(), std::string(oma_parent_uuid_string), order_handle->current_state_data.params.mkt_id);
orderd_orders.cpp         ALGO_DLOG("class_1_2 %s", class_1_2->ShortDebugString().to_std());
orderd_orders.cpp         ALGO_ILOG("Drop Unsolicited order_id=%s status=%s status_flags=%d " "xfer_held_change=%s " "xfer_replace_cancel=%s " "xfer_replace_new=%s ", order_id.to_string(), TTSDK_OrderStatusToString(order_status->status_type), (int)(order_status->status_flags), order_status->status_flags & ttsdk_order_xfer_held_change ? "True": "False", order_status->status_flags & ttsdk_order_xfer_replace_cancel ? "True": "False", order_status->status_flags & ttsdk_order_xfer_replace_new ? "True": "False");
orderd_orders.cpp             ALGO_ILOG("Delivered Unsolicited order_id=%s status=%s status_flags=%d to user_order_id=%p", order_id.to_string(), TTSDK_OrderStatusToString(ostatus->status_type), (int)(ostatus->status_flags), codter->user_order_id);
orderd_orders.cpp     ALGO_ILOG( "CompOrdRsp() <--------grand_parent_id=%s, parent_id=%s, order_id=%s " "%s%s stauts_type=%s order_status=[price=%0.8f order_qty=%0.8f wrk_qty=%0.8f trg_prc=%0.8f disclosed_q=%0.8f last_fill_qty=%0.8f last_fill_prc=%0.8f] trade_date=%llu type=%s ", is_grand_child_order ? tt::algoutil::ttuuid(parent_order_handle->current_state_data.params.parent_id).to_string(): "N/A", parent_id.to_string(), order_id.to_string(), (order_status->status_flags&ttsdk_external_order_event)?"(External)":"", (order_status->status_flags&ttsdk_suspended_order_event)?"(Suspended)":"", TTSDK_OrderStatusToString(order_status->status_type), order_status->params.price, order_status->params.order_qty, order_status->params.wrk_qty, trigger_price, disclosed_qty, is_fill ? order_status->params.last_fill_qty : -1, is_fill ? order_status->params.last_fill_prc : -1, trade_date, TTSDK_OrderTypeToString(type) );
orderd_orders.cpp             ALGO_ILOG("Received expected external order event." " cancel_submitted=%d" " inflight_qty=%0.8f" " inflight_price=%0.8f", cancel_submitted, inflight_qty, inflight_price);
orderd_orders.cpp         ALGO_ILOG("Retry order returned. set retry_time_span(ms) %llu to 0", order_handle->retry_time_span);
orderd_orders.cpp     ALGO_DLOG("user_id=%llu effective_user_id=%llu %s", user_id, effective_user_id, class_1_2->ShortDebugString().to_std());
orderd_orders.cpp         ALGO_DLOG("Setting broker_id=%llu, not found in params!", m_accountToBrokerMap[account_id]);
orderd_orders.cpp             ALGO_ELOG("Unable to add order handle to risk bucket." " error=%s", ORDERD_ERROR_STR[error]);
orderd_orders.cpp                 ALGO_ILOG("PositionMgr: PR order has no connection id, routing to Bouncer" " bucket=%p" " order_handle=%p", (void*)(risk_bucket.get()), (void*)(order_handle.get()));
orderd_orders.cpp     ALGO_ILOG("downloading order: " "order_id=%s " "request_id=%d " "algo_type=%d(%s) " "download_reason=%s", download_order_id.to_string(), request_id, downloading_algo_type, TTSDK_ALGO_TYPE_STR[downloading_algo_type], std::string(TTSDK_OrderDownloadReasonToString(download_reason)));
orderd_orders.cpp         ALGO_ILOG("OrderD_DownloadOrder: download_parent_id=%s trying to adopt order_id=%s " "and order_handle already exist - the existing order_handle has following info: " "parent_id=%s " "oma_parent_id=%s ", download_parent_id.to_string(), download_order_id.to_string(), has_parent? tt::algoutil::ttuuid(parent_id).to_string():"N/A", has_oma? tt::algoutil::ttuuid(oma_parent_id).to_string():"N/A");
orderd_orders.cpp             ALGO_WLOG("OrderD_DownloadOrder: Child order_id=%s already has oma_parent_id", download_order_id.to_string());
orderd_orders.cpp                 ALGO_ELOG("OrderD_DownloadOrder: Trying to recover a child order but " "the child order has no parent_id");
orderd_orders.cpp                 ALGO_ELOG("OrderD_DownloadOrder: Trying to recover a child order but " "the child order belongs to another algo");
orderd_orders.cpp                 ALGO_ELOG("OrderD_DownloadOrder: Trying to recover a child order but " "the child order is already being downloaded");
orderd_orders.cpp                 ALGO_ELOG("Failed to Send UpdateOrder: " "error=%s " "order_id=%s " "oma_parent_id=%s ", ORDERD_ERROR_STR[error], download_order_id.to_string(), download_parent_id.to_string());
orderd_orders.cpp             ALGO_ILOG("Adopting algo from different user. order_handle.current_user_id=%llu->%llu", order_handle->current_user_id, user_id);
orderd_orders.cpp         ALGO_ELOG("OrderD_DownloadOrder: failed to alloc order_handle");
orderd_orders.cpp         ALGO_ELOG("m_lbmLedgerSender->SendRequest() !! Error !! download_order_id=%s request_id=%u, req_buffer_size=%u, reqPtr=nullptr.", download_order_id.to_string(), request_id, buf_size);
orderd_orders.cpp     ALGO_ILOG("attaching order: " "order_id=%s " "parent_order_id=%s", order_id.to_string(), parent_order_id.to_string());
orderd_orders.cpp                         ALGO_ILOG("failed to create lbm channel sender for order[order_id=%s] market_id=%u", order_id.to_string(), current_params->mkt_id);
orderd_orders.cpp                     ALGO_ILOG( "Populating newly created order_handle with cached order_status. " "while attaching order[%s] " "order_handle->order_id=%s " "order_handle->parent_id=%s " "order_handle->base_quantity=%0.8f " "order_handle->current_state_data.params.working_qty=%0.8f " "order_handle->current_state_data.params.price=%0.8f " "order_handle->current_state_data.params.order_qty=%0.8f ", order_id.to_string(), std::string(child_id), std::string(daddy_id), order_handle->base_quantity, order_handle->current_state_data.params.wrk_qty, order_handle->current_state_data.params.price, order_handle->current_state_data.params.order_qty );
orderd_orders.cpp                 ALGO_ILOG("attaching order for: " "order_id=%s " "order_status=%s " "Now deliver response to the attaching request", order_id.to_string(), TTSDK_OrderStatusToString(cached->order_status.status_type));
orderd_orders.cpp                 ALGO_ILOG("attaching order for order_id=%s succeeded", order_id.to_string());
orderd_orders.cpp                 ALGO_ELOG("attaching order failed for: " "order_id=%s " "can not find cached child order status from parent order_handle:" "parent_order_id=%s ", order_id.to_string(), parent_order_id.to_string());
orderd_orders.cpp             ALGO_ILOG("attaching order failed for: " "order_id=%s " "can not find parent order_handle for:" "parent_order_id=%s ", order_id.to_string(), parent_order_id.to_string());
orderd_orders.cpp         ALGO_ILOG("attaching order[order_id=%s] has no parent id !", order_id.to_string());
orderd_orders.cpp         ALGO_ILOG("OrderD_DetachOrder: order_handle is null. Skip.");
orderd_orders.cpp     ALGO_ILOG( "Detaching Order " "order_id=%s " "parent_order_id=%s " "oma_parent_id=%s " "state_flags=[%s]", std::string(order_uuid_string), std::string(parent_uuid_string), std::string(oma_parent_uuid_string), OrderStateFlagAsStr(order_handle->state_flags) );
orderd_orders.cpp             ALGO_ELOG("Side cannot be changed " "change_params->side =%d " "order_handle->current_state_data.params.side=%d ", change_params->side, order_handle->current_state_data.params.side );
orderd_orders.cpp             ALGO_ELOG("Account cannot be changed " "change_params->account =%llu " "order_handle->current_state_data.params.account=%llu ", change_params->account, order_handle->current_state_data.params.account );
orderd_orders.cpp             ALGO_ELOG("Type cannot be changed from %s to %s", TTSDK_OrderTypeToString((enum ttsdk_order_type)order_handle->current_state_data.params.type), TTSDK_OrderTypeToString((enum ttsdk_order_type)change_params->type) );
orderd_orders.cpp             ALGO_ELOG("TIF cannot be changed " "change_params->tif =%d " "order_handle->current_state_data.params.tif=%d ", change_params->tif, order_handle->current_state_data.params.tif );
orderd_orders.cpp         ALGO_ILOG("Cancelling TT_Retry order_id=%s " "Expecting 2 rejects: " "1 for rejecting the original add, " "1 (external reject) for rejecting this cancel request", tt::algoutil::ttuuid(order_handle->current_state_data.params.ord_id).to_string());
orderd_orders.cpp         ALGO_ILOG("Change request queued with following params: " "queued_req_type=%s " "user_request_id=%u " "[parent_id=%s order_id=%s] " "user_id=%llu " "price=%0.8f " "order_qty=%0.8f " "side=%d " "trg_price=%lf " "disp_qty=%0.8f " "user_order_id=%p " "exch_order_assoc=%s " "account_id=%llu " "broker_id=%llu " "best_market_price=%lf " "non_matching=%d " , std::string(OrderD_ChangeReqTypeToString(order_handle->queued_state.change_req_type)), user_request_id, tt::algoutil::ttuuid(order_handle->queued_state.order_state.params.parent_id).to_string(), tt::algoutil::ttuuid(order_handle->queued_state.order_state.params.ord_id).to_string(), user_id, order_handle->queued_state.order_state.params.price, order_handle->queued_state.order_state.params.order_qty, order_handle->queued_state.order_state.params.side, order_handle->queued_state.order_state.params.trg_prc, order_handle->queued_state.order_state.params.disp_qty, client_ord_data->user_order_id, std::string(order_handle->exch_assoc), order_handle->queued_state.order_state.params.account, order_handle->queued_state.order_state.params.broker, order_handle->queued_state.order_state.params.best_market_price, order_handle->queued_state.order_state.params.non_matching);
orderd_orders.cpp         ALGO_ELOG("OrderD::RetryDownloadChildrenRequest: Failed to encode LBM request: " "request_buffer_size=%zu " "encoded_size=%zu ", std::strlen(lbm_send_data.request_buffer), lbm_send_data.request_buffer_size);
orderd_orders.cpp     ALGO_ILOG("OrderD::RetryDownloadChildrenRequest: Queued lbm_send_data: " "algo_inst_id=%s " "req_id=%s " "req_buffer_size=%u", ttalgo.to_string(), std::string(lbm_send_data.request_id), lbm_send_data.request_buffer_size);
orderd_orders.cpp     ALGO_ILOG("OrderD::ProcessLbmSendQueueForChildrenDownload: Starting... " "queueSize=%zu " "batchSize=%d", m_pendingLbmSendsForChildrenDownload.size(), batchSize);
orderd_orders.cpp             ALGO_ELOG("OrderD::ProcessLbmSendQueueForChildrenDownload: Request object is invalid, request_id=%s", std::string(current->request_id));
orderd_orders.cpp             ALGO_ELOG("OrderD::ProcessLbmSendQueueForChildrenDownload: Failed to send LBM request, request_id=%s", std::string(current->request_id));
orderd_orders.cpp         ALGO_DLOG("OrderD::ProcessLbmSendQueueForChildrenDownload: Sent LBM request: " "request_id=%s " "count=%d ", std::string(current->request_id), count);
orderd_orders.cpp     ALGO_ILOG("OrderD::ProcessLbmSendQueueForChildrenDownload: Finished... " "queue_size=%zu", m_pendingLbmSendsForChildrenDownload.size());
orderd_orders.cpp         ALGO_ELOG("OrderD::RetryDownloadOrderRequest: Failed to get Order ID: " "previous_tid=%s (TID that timed out)", order_handle->request_tid);
orderd_orders.cpp         ALGO_ELOG("OrderD::RetryDownloadOrderRequest: Failed to encode LBM request: " "request_buffer_size=%zu " "encoded_size=%zu ", std::strlen(lbm_send_data.request_buffer), lbm_send_data.request_buffer_size);
orderd_orders.cpp     ALGO_ILOG("OrderD::RetryDownloadOrderRequest: Queued lbm_send_data: " "order_id=%s " "previous_tid=%s (TID that timed out) " "current_tid=%s (TID queued for later send) " "req_buffer_size=%u ", tt_order_id.to_string(), order_handle->request_tid, std::string(lbm_send_data.request_id), lbm_send_data.request_buffer_size);
orderd_orders.cpp     ALGO_ILOG("OrderD::ProcessLbmSendQueueForOrderDownload: Starting... " "queueSize=%zu " "batchSize=%d", m_pendingLbmSendsForOrderDownload.size(), batchSize);
orderd_orders.cpp             ALGO_ELOG("OrderD::ProcessLbmSendQueueForOrderDownload: Order handle disposed, request_id=%s", std::string(current->request_id));
orderd_orders.cpp             ALGO_ELOG("OrderD::ProcessLbmSendQueueForOrderDownload: Failed to send LBM request, request_id=%s", std::string(current->request_id));
orderd_orders.cpp         ALGO_DLOG("OrderD::ProcessLbmSendQueueForOrderDownload: Sent LBM request: " "request_id=%s " "count=%d ", std::string(current->request_id), count);
orderd_orders.cpp     ALGO_ILOG("OrderD::ProcessLbmSendQueueForOrderDownload: Finished... " "queue_size=%zu", m_pendingLbmSendsForOrderDownload.size());
orderd_orders.cpp         ALGO_WLOG("OrderD::CheckForInflightTimeouts: Order handle timed out on a request: " "order_handle=%p, " "request_time=%llu, " "timeout_threshold=%llu " "retry_time_span=%llu(ms) " "order_id=%s " "user_request_id=%llu " "state_flags=[%s] %d", timedOutOrderHandle.get(), timedOutOrderHandle->request_time, timeout_threshold, timedOutOrderHandle->retry_time_span, orderId, pending_order_state->user_request_id, OrderStateFlagAsStr(timedOutOrderHandle->state_flags), timedOutOrderHandle->state_flags);
orderd_orders.cpp             ALGO_WLOG("OrderD::CheckForInflightTimeouts: Retrying download request for order_id=%s", orderId);
orderd_orders.cpp             ALGO_WLOG("OrderD::CheckForInflightTimeoutsOrderD: Retry download failed for order_id=%s - will CompleteOrderTimeout", orderId);
orderd_orders.cpp         ALGO_WLOG("OrderD::CheckForInflightTimeouts: CompleteOrderTimeout for order_id=%s", orderId);
orderd_orders.cpp                                                        ALGO_ELOG("OrderD::CheckForInflightTimeouts: Download request timed out, retrying: " "request_id=%s", std::string(req->data.recover_order.ledger_request_tid));
orderd_orders.cpp         ALGO_ILOG("SendChildOrderCleanupRequest: Request sent." " request_id=%s" " algo_inst_id=%s", data.req_id, data.parent_id.to_string());
orderd_orders.cpp         ALGO_ELOG("SendChildOrderCleanupRequest: Request failed" " algo_inst_id=%s", data.parent_id.to_string());
orderd_orders.cpp         ALGO_ELOG("OrderD_RemoveOMAParent; Failed to Send UpdateOrder:error=%s ", ORDERD_ERROR_STR[error]);
orderd_orders.cpp     ALGO_ILOG( "OrderD::HandleUserUpdate: user_id=%llu user->account_count=%llu", user->user_id, user->account_count );
orderd_orders.cpp     ALGO_ILOG( "OrderD::HandleUserUpdate: user_id=%llu Finished", user->user_id );
orderd_orders.cpp         ALGO_ELOG("LbmResourceMgr::SenderPtr->Send() !! Error !!");
orderd_orders.cpp         ALGO_ELOG("LbmResourceMgr::ChannelSenderPtr->Send() !! Error !!");
orderd_orders.cpp         ALGO_ELOG("Unable to send. Both channelSender and syntheticSenderPtr are null");
orderd_orders.cpp     ALGO_ILOG( "UpdatePositionLimit: Attempting to update limit for risk bucket: " "market_id=%zu " "parent_id=%s " "instr_id=%llu " "account_id=%llu " "requested_limit_side=%s " "requested_limit=%f", inner_request->market_id, std::string(parent_id_str), inner_request->instr_id, inner_request->account_id, inner_request->is_long_limit ? std::string("long") : std::string("short"), inner_request->limit );
orderd_orders.cpp         ALGO_ELOG("UpdatePositionLimit: Failed to update limit - " "risk bucket could not be located: " "error=%s", ORDERD_ERROR_STR[error]);
orderd_orders.cpp         ALGO_ELOG("UpdatePositionLimit: Irrelevant for synthetic orders " "(ASE, AGG, ALGO) - returning success.");
orderd_orders.cpp             ALGO_ILOG("UpdatePositionLimit: Failed to update limit - " "requested limit is lower than worst case: " " side=%d" " requested_limit=%f" " risk_bucket_worst_case=%d", side, inner_request->limit, risk_bucket->worst_case_position);
orderd_orders.cpp     ALGO_ILOG("UpdatePositionLimit: Successfully updated limit!");
orderd_orders.cpp         ALGO_ELOG("OrderD_DeliverPositionLimitUpdate: original_request ptr was unexpectedly " "a nullptr. the requestor will NOT get a response of any sort.");
orderd_orders.cpp     ALGO_ILOG( "SendNewOrderToEpiqService order_id=%s, instr_id=%llu, account_id=%llu", epiq_order_data.order_id.to_string(), epiq_order_data.instr_id, epiq_order_data.account_id);
orderd_orders.cpp     ALGO_ILOG( "SendDeleteOrderToEpiqService order_id=%s", del_order.order_id.to_string());
protocol.cpp         ALGO_ILOG("Encode for LOOPBACK msg=%s", request.ShortDebugString().to_std());
protocol.cpp         ALGO_ELOG("lbm::Source Send failed");
protocol.cpp         ALGO_ELOG("lbm::ChannelSource Send failed");
protocol.cpp         ALGO_ELOG("Unable to send. Both sender and channel_sender are null");
protocol.cpp         ALGO_ILOG("PositionReserveUpdate=%s", msg.ShortDebugString().to_std());
protocol.cpp         ALGO_ILOG("Invalid PR Message. exec_type=%s", ExecType_Name(msg.exec_type()).c_str());
protocol.cpp         ALGO_DLOG("ExecutionReport: %s %s", std::string(order_id_str), execution_report->ShortDebugString().to_std());
protocol.cpp             ALGO_WLOG( "DecodeOrderUpdate: Unknown order_type=%d " "order_id=%s " "Order will default to limit", execution_report->ord_type(), std::string(order_uuid_string) );
protocol.cpp             ALGO_WLOG( "DecodeOrderUpdate: Unknown time_in_force=%d " "order_id=%s ", execution_report->time_in_force(), std::string(order_uuid_string) );
protocol.cpp             ALGO_DLOG("ExecutionReport %s fills_grp_size=%zu serialized_size=%zu", std::string(order_id_str), fills_grp.fills_grp_size, fills_grp.struct_size);
protocol.cpp             ALGO_ELOG("ExecutionReport %s fills_grp_size=%zu serialized_size=%zu serialization failed", std::string(order_id_str), execution_report->fills_grp_size(), fills_grp.struct_size);
protocol.cpp         ALGO_DLOG("Setting trade_date=%llu", trade_date);
protocol.cpp                 ALGO_ILOG("STAGED: orderd: From OC::ExecReport SET_StagedAccountId=%d", (int)party.party_tt_id());
protocol.cpp             ALGO_ILOG("%s", ss.str());
protocol.cpp                 ALGO_ILOG("ER=Restate: found xfer_released_order");
protocol.cpp                 ALGO_ILOG("ER=Restate: found xfer_reduced_order");
protocol.cpp                 ALGO_WLOG("ER=Restate: unhandled AOTC action_type= %s. ", std::string(CrossingOrderPreventionActionType_Name( execution_report->crossing_order_prevention_action_type()).c_str()));
protocol.cpp                 ALGO_ILOG("ER=Replace: found xfer_held_change");
protocol.cpp                 ALGO_ILOG("ER=Replace: Unhandled AOTC action_type= %s. ", std::string(CrossingOrderPreventionActionType_Name( execution_report->crossing_order_prevention_action_type()).c_str()));
protocol.cpp                 ALGO_ILOG("ER=Cancel: found xfer_replace_cancel");
protocol.cpp                 ALGO_ILOG("ER=Cancel: Unhandled AOTC action_type= %s. ", std::string(CrossingOrderPreventionActionType_Name( execution_report->crossing_order_prevention_action_type()).c_str()));
protocol.cpp                     ALGO_ILOG("ER=Trade: found xfer_fill");
protocol.cpp                     ALGO_ILOG("ER=Trade: unhandled AOTC action_type= %s. ", std::string(CrossingOrderPreventionActionType_Name( execution_report->crossing_order_prevention_action_type()).c_str()));
protocol.cpp         ALGO_ELOG("STAGED protocol: SET_staged_order_id=%s", std::string(staged_order_uuid_string));
protocol.cpp         ALGO_ELOG("UpdateOrderHandleClassTwo: incoming fields is null. order_handle=%p", order_handle.get());
protocol.cpp     ALGO_ILOG("UpdateOrderHandleClassTwo to New/Change/Cancel: order_handle=%p class_2=[%s]", order_handle.get(), class_2->ShortDebugString().to_std());
protocol.cpp         ALGO_ELOG("SetClassTwoFields: incoming fields is null. order_handle=%p", order_handle.get());
protocol.cpp     ALGO_ILOG("SetClassTwoFields to Change/Cancel: order_handle=%p class_2=[%s]", order_handle.get(), class_1_2->class_2().ShortDebugString().to_std());
protocol.cpp         ALGO_ELOG("SetASEOrderInfo: incoming fields is null. order_handle=%p", order_handle.get());
protocol.cpp         ALGO_ELOG("SetASEOrderInfo instrument_block_guid=%s, no autotool_order_infos available", instrument_block_guid);
protocol.cpp         ALGO_ILOG("SetASEOrderInfo instrument_block_guid=%s size=%d use first=%s", instrument_block_guid, size, autotool_order_info.ShortDebugString().to_std());
protocol.cpp                 ALGO_ILOG("SetASEOrderInfo instrument_block_guid=%s size=%d found match index=%d, a=%s", instrument_block_guid, size, index, autotool_order_info.ShortDebugString().to_std());
protocol.cpp             ALGO_ELOG("SetASEOrderInfo instrument_block_guid=%s found no match. class_1=%s", instrument_block_guid, class_1_2->class_1().ShortDebugString().to_std());
protocol.cpp         ALGO_ELOG("SetClassOneTwoFields: incoming fields is null. order_handle=%p", order_handle.get());
protocol.cpp     ALGO_ILOG("SetClassOneTwoFields to NOS: order_handle=%p class_1_2=[%s]", order_handle.get(), class_1_2->ShortDebugString().to_std());
protocol.cpp         ALGO_DLOG("PrePopulateProtoBufObjects; Organization=%s", std::string(organization));
protocol.cpp         ALGO_ELOG("STAGED protocol: SET_staged_account_type=%d", stagedAccountType);
protocol.cpp             ALGO_ELOG("PrePopulateProtoBufObjects: algo_type is UNKNOWN, so algo_type will NOT be set!");
protocol.cpp         ALGO_DLOG("PrePopulateProtoBufObjects: Setting current_group_id=%llu on order_handle=%p", current_group_id, static_cast<void*>(order_handle.get()));
protocol.cpp         ALGO_DLOG("PrePopulateProtoBufObjects: Setting original_group_id=%llu on order_handle=%p", original_group_id, static_cast<void*>(order_handle.get()));
protocol.cpp         ALGO_ILOG("PrePopulate (1): [%s] state_flags=%d new_order_single=%s", parent_order_id_str, order_handle->state_flags, order_handle->new_order_single->ShortDebugString().to_std());
protocol.cpp         ALGO_ILOG("PrePopulate (1): [%s] change_request=%s", parent_order_id_str, order_handle->change_request->ShortDebugString().to_std());
protocol.cpp         ALGO_ILOG("PrePopulate (1): [%s] cancel_request=%s", parent_order_id_str, order_handle->cancel_request->ShortDebugString().to_std());
protocol.cpp         ALGO_ILOG("PrePopulate (2): [%s] new_order_single=%s", parent_order_id_str, order_handle->new_order_single->ShortDebugString().to_std());
protocol.cpp         ALGO_ILOG("PrePopulate (2): [%s] change_request=%s", parent_order_id_str, order_handle->change_request->ShortDebugString().to_std());
protocol.cpp         ALGO_ILOG("PrePopulate (2): [%s] cancel_request=%s", parent_order_id_str, order_handle->cancel_request->ShortDebugString().to_std());
protocol.cpp         ALGO_ELOG("CheckSenderLocationId: order_id=%s message=%s is missing sender_location_id. set default=%s", order_handle->current_order_id(), std::string(typeid(T).name()), locationId);
protocol.cpp                 ALGO_ILOG("OrderCancelReject=[%s] %s", tt_order_id.to_string(), cancel_reject.ShortDebugString().to_std());
protocol.cpp         ALGO_ELOG("Received BookieResponse without request_id");
protocol.cpp         ALGO_ELOG("BookieResponse has an error: what=%s", msg.parent_order().error().to_std());
protocol.cpp     ALGO_ILOG("BookieResponse: %s", msg.ShortDebugString().to_std());
protocol.cpp         ALGO_ILOG("No child orders found while decoding BookieResponse");
protocol.cpp         ALGO_ELOG("Memory allocation failed decoding BookieResponse");
protocol.cpp             ALGO_ILOG("ParentOrderDownloadResponse drop leg fill for %s", std::string(error));
protocol.cpp             ALGO_WLOG("ParentOrderDownloadResponse ER parsing failed." " error=%s" " message=%s", ORDERD_ERROR_STR[error_code], error);
protocol.cpp         ALGO_ILOG("ParentOrderDownloadResponse decoded child." " order_id=%s" " ord_status=%s" " exec_type=%s", std::string(order_id), TTSDK_OrderStatusToString(status.status_type), ExecType_Name(er.exec_type()).c_str());
protocol.cpp             ALGO_ELOG("ParentOrderDownloadResponse PR parsing failed.");
protocol.cpp         ALGO_ILOG("ParentOrderDownloadResponse decoded PR." " order_id=%s" " ord_status=%s" " exec_type=%s", std::string(order_id), TTSDK_OrderStatusToString(status.status_type), ExecType_Name(pr.exec_type()).c_str());
protocol.cpp         ALGO_ELOG("receive response from Ledger without request_id");
protocol.cpp         ALGO_ELOG( "Ledger does not return a valid OrderDownloadResponse for order download request[request_id=%s]", response.request_id().to_std() );
protocol.cpp         ALGO_ELOG("receive response from Ledger with error=%s", response.orders().error().to_std());
protocol.cpp         ALGO_ELOG( "Ledger return %d order(s) for order download request[request_id=%s]", response.orders().orders_size(), response.request_id().to_std() );
protocol.cpp     ALGO_ILOG("BookieResponse: %s", response.ShortDebugString().to_std());
protocol.cpp         ALGO_ELOG("OrderD_DecodeBookieMessage has error=%s, message=%s", ORDERD_ERROR_STR[error_code], error);
protocol.cpp         ALGO_ELOG("EncodeAndSendNewOrder cannot submit PR orders");
protocol.cpp             ALGO_ELOG("Trying to encode non-null terminated string. value=%s", std::string(account_override, TTSDK_PARAM_MAX_STRING_SIZE));
protocol.cpp             ALGO_ILOG("accountoverride=%s", new_request->account_override().c_str());
protocol.cpp         ALGO_DLOG("EncodeAndSendNewOrder: Setting exec_inst to: %s", std::string(TTSDK_ExecInstToString(exec_inst)));
protocol.cpp         ALGO_DLOG("EncodeAndSendNewOrder: Clearing exec_inst");
protocol.cpp     ALGO_ILOG("EncodeAndSendNewOrder: %s", new_request->ShortDebugString().to_std());
protocol.cpp         ALGO_WLOG("OrderD_EncodeUpdateOrder could not get connection_id - " "given order_handle is likely an algo order");
protocol.cpp             ALGO_ELOG("OrderD_EncodeUpdateOrder set_oma_parent_id failed. No oma_parent_id");
protocol.cpp     ALGO_ILOG("[%s] OrderUpdate: %s", std::string(order_id_str), message.ShortDebugString().to_std());
protocol.cpp             ALGO_ELOG("AccountOverrider:Trying to encode non-null terminated string. value=%s", std::string(account_override, TTSDK_PARAM_MAX_STRING_SIZE));
protocol.cpp             ALGO_DLOG("AccountOverride=%s", change_request->account_override().c_str());
protocol.cpp         ALGO_DLOG("AccountOverride not SET");
protocol.cpp         ALGO_DLOG("EncodeAndSendChangeOrder: Setting exec_inst to: %s", std::string(TTSDK_ExecInstToString(exec_inst)));
protocol.cpp         ALGO_DLOG("EncodeAndSendChangeOrder: Clearing exec_inst");
protocol.cpp         ALGO_ILOG("EncodeAndSendChangeOrder: [%s] %s", order_id.to_string(), change_request->ShortDebugString().to_std());
protocol.cpp         ALGO_ILOG("%s params->user_id=%llu params->originating_user_id=%llu", msg.ShortDebugString().to_std(), params->user_id, params->originating_user_id);
protocol.cpp         ALGO_ILOG("%s params->user_id=%llu params->originating_user_id=%llu", msg.ShortDebugString().to_std(), params->user_id, params->originating_user_id);
protocol.cpp         ALGO_ILOG("PositionReserveCancelOrder=%s params->user_id=%llu params->originating_user_id=%llu", msg.ShortDebugString().to_std(), params->user_id, params->originating_user_id);
protocol.cpp         ALGO_ILOG("EncodeAndSendCancelOrder: %s", toPrint.to_std());
protocol.cpp         ALGO_ILOG("EncodeAndSendChangeOrder: [%s] %s", order_id.to_string(), message.ShortDebugString().to_std());
protocol.cpp     ALGO_ILOG("OrderD_EncodeTTUSAccountDownloadRequest request_id=%s", std::string(request_id_string));
protocol.cpp     ALGO_ILOG("OrderD_EncodeTTUSUserDownloadRequest request_id=%s user_id=%d", std::string(request_id_string), user_id);
protocol.cpp     ALGO_ILOG("OrderD_EncodeTTUSConnectionDownloadRequest request_id=%s", std::string(request_id_string));
protocol.cpp     ALGO_ILOG( "OrderD_EncodeOrderDownloadRequest ledger_request_id=%s for order_id=%s", std::string(request_id), std::string(order_uuid_string) );
protocol.cpp         ALGO_ILOG("BookieRequest: %s", toPrint.to_std());
protocol.cpp     ALGO_ILOG( "OrderD_ReportStatistics \n" "m_wasted_decoded_order=%llu, \n" "s_wire_head_no_filter_id=%llu, \n" "s_wire_head_match_orderd_hash=%llu, \n" "s_wire_head_match_parent_order_id=%llu, \n" "s_dropped_wire_msg=%llu, \n" "new_count =%llu, \n" "new_proto =%llu, \n" "new_wire_lbm =%llu, \n" "new_lbm =%llu, \n" "change_count =%llu, \n" "change_proto =%llu, \n" "change_wire_lbm=%llu, \n" "change_lbm =%llu, \n" "spq_count =%llu, \n" "spq_proto =%llu, \n" "spq_wire_lbm =%llu, \n" "spq_lbm =%llu, \n" , m_wasted_decoded_order, s_wire_head_no_filter_id, s_wire_head_match_orderd_hash, s_wire_head_match_parent_order_id, s_dropped_wire_msg, s_new_count, s_new_count==0? 0L: s_new_proto/s_new_count, s_new_count==0? 0L: s_new_encode_wire_send/s_new_count, s_new_count==0? 0L: s_new_lbm_send/s_new_count, s_change_count, s_change_count==0? 0L: s_change_proto/s_change_count, s_change_count==0? 0L: s_change_encode_wire_send/s_change_count, s_change_count==0? 0L: s_change_lbm_send/s_change_count, s_spq_count, s_spq_count==0? 0L: s_spq_proto/s_spq_count, s_spq_count==0? 0L: s_spq_encode_wire_send/s_spq_count, s_spq_count==0? 0L: s_spq_lbm_send/s_spq_count );
instrument_cache.cpp         ALGO_ELOG("PDS JSON msg is invalid: size=%d " "%s ", size, std::string(pay_load));
instrument_cache.cpp             ALGO_ILOG("ParsePDSUpdate() datap=%s", datap);
instrument_cache.cpp     ALGO_ILOG("PDS JSON msg: size=%d " "et=%s, " "dt=%s, " "market=%s " "id=%s " "compliance=%s ", size, et, dt, market, id, compliance);
instrument_cache.cpp         ALGO_ELOG("PDS JSON msg missing eventType or dataType or instrument_id");
instrument_cache.cpp     ALGO_ILOG("InstrumentCache pds_notification_lbm_affinity=%d", pds_notification_lbm_affinity);
instrument_cache.cpp         ALGO_ELOG("SubscribePDSNotification: InstrumentCache has not been started yet. Subscribe to instrument_id=%llu ignored", instrument_id);
instrument_cache.cpp             ALGO_ILOG("SubscribePDSNotification: Subscribe to ASE/AGG instrument notification: " "topic=%s for " "instrument_id=%llu market_id=%u user_id=%llu", std::string(pds_topic_name), instrument_id, market_id, user_id);
instrument_cache.cpp             ALGO_WLOG("SubscribePDSNotification: PDS Sub already exists for ASE/AGG instrument notification: " "instrument_id=%llu market_id=%u user_id=%llu", instrument_id, market_id, user_id);
instrument_cache.cpp         ALGO_ILOG("SubscribePDSNotification: Subscribe to " "topic=%s for " "instrument_id=%llu market_id=%u product_id=%llu user_id=%llu", std::string(pds_topic_name), instrument_id, market_id, product_id, user_id);
instrument_cache.cpp         ALGO_WLOG("SubscribePDSNotification: PDS Sub already exists for " "instrument_id=%llu market_id=%u product_id=%llu user_id=%llu", instrument_id, market_id, product_id, user_id);
instrument_cache.cpp         ALGO_ELOG("PDSNotificationRecvd: failed to parse [%s]", std::string(data));
instrument_cache.cpp     ALGO_ILOG("PDSNotificationRecvd: market_id=%lu instrument_id=%llu compliance_id=%llu is_delete=%d is_update=%d tick_size=%0.6f", market_id, instrument_id, compliance_id, is_delete, is_update, tick_size);
instrument_cache.cpp         ALGO_DLOG("Beginning of transport session. Topic=%s lbm_source=%s", std::string(message.TopicName()), std::string(message.Source()));
instrument_cache.cpp         ALGO_DLOG("End of transport session. Topic=%s lbm_source=%s", std::string(message.TopicName()), std::string(message.Source()));
instrument_cache.cpp     ALGO_ILOG("InstrumentCache Stopping");
instrument_cache.cpp         ALGO_ILOG("FindNative %s[%s] in cache that equal to %s", found->second->name, found->second->alias, name);
instrument_cache.cpp         ALGO_WLOG("FindNative %s[%s] in cache like %s. Ignore...", found->second->name, found->second->alias, name);
instrument_cache.cpp     ALGO_ILOG("AddProduct: prod_id=%llu, symbol=%s", product_id, product->symbol);
instrument_cache.cpp         ALGO_ILOG("Added Native: instr_id=%llu, alias=%s name=%s. " "Subscribing TTNotify with market_id=%u product_id=%llu", downloaded->instr_snap.instr_id, downloaded->alias, downloaded->name, downloaded->instr_snap.market_id, downloaded->instr_snap.product_id);
instrument_cache.cpp         ALGO_ILOG("Added Synthetic: instr_id=%llu, alias=%s name=%s. " "Subscribing TTNotify with market_id=%u product_id=%llu", downloaded->instr_snap.instr_id, downloaded->alias, downloaded->name, downloaded->instr_snap.market_id, downloaded->instr_snap.product_id);
instrument_cache.cpp         ALGO_WLOG("InstrumentCache Clear whole native instruments and products!!!!!!!!!!!!!!!!!!!!!!!!");
instrument_cache.cpp                 ALGO_WLOG("InstrumentCache Remove instrument_id=%llu", id);
instrument_cache.cpp                 ALGO_WLOG("InstrumentCache Remove product_id=%llu", id);
instrument_cache.cpp         ALGO_ELOG("RemoveSyntheticInstrument: instrument=%llu not found in cache", instrument_id);
instrument_cache.cpp         ALGO_ILOG("RemoveSyntheticInstrument: instrument=%llu removed from cache", instrument_id);
instrument_cache.cpp         ALGO_ELOG("RemoveIfTickSizeChanged: invalid instrument_id=%llu, tickSize=%f", instrument_id, tickSize);
instrument_cache.cpp             ALGO_ILOG("RemoveIfTickSizeChanged: No change. instrument=%llu, tickSize=%f", instrument_id, tickSize);
instrument_cache.cpp             ALGO_ILOG("RemoveIfTickSizeChanged: Revmoed. instrument=%llu, tickSize=%f, old_tickSize=%f", instrument_id, tickSize, instrDataPtr->instr_snap.tick_size);
analytics_sub_mgr.cpp     ALGO_ILOG("OpenPriceSub instr=%p instr_id=%llu interests=%s, subscribe_to_implies=%d", instr, instr_id, filter.to_string(), subscribe_to_implies);
analytics_sub_mgr.cpp         ALGO_ILOG("OpenPriceSub succeeded " "instr=%p " "instr_id=%llu " "user_id=%llu " "price_sub=%llu " "interests=%s", instr, instr_id, user_id, *price_sub_id, filter.to_string());
analytics_sub_mgr.cpp         ALGO_ELOG("OpenPriceSub failed " "instr=%p " "instr_id=%llu " "user_id=%llu " "price_sub=%llu " "interests=%s", instr, instr_id, user_id, *price_sub_id, filter.to_string());
pdsman.cpp         ALGO_ILOG("BuildInstrData" " instr_id=%llu" " underlying_instr_id=%llu" " product_id=%llu" " market_id=%u" " name=%s" " alias=%s" " symbol=%s" " security_exchange_id=%u" " round_lot_quantity=%u" " decimal_shift_quantity=%u" " price_display_decimals=%d" " decimal_shift_price=%d" " calculated_min_qty=%0.8f", snap.instr_id, snap.underlying_instr_id, snap.product_id, snap.market_id, instr_data->name, instr_data->alias, instr_data->symbol, instr_data->security_exchange_id, snap.round_lot_quantity, snap.decimal_shift_quantity, snap.price_display_decimals, snap.decimal_shift_price, snap.calculated_min_qty);
pdsman.cpp             ALGO_ILOG("OpqueueData: %s", opaque_data);
pdsman.cpp                 ALGO_ELOG("BuildInstrumentData: Parsing JSON failed error=%s", ALGOUTIL_ERROR_STR[error]);
pdsman.cpp                 ALGO_ELOG("BuildInstrumentData: Invalid JSON data found_flags=%d", found_flags);
pdsman.cpp                 ALGO_ELOG("GetInstrument failed instr_id=%llu error=invalid_token user_id=%llu", m_instr_id, m_user_id);
pdsman.cpp             ALGO_ELOG("GetInstrument failed instr_id=%llu error=%s", m_instr_id, tt::sdk::internal::to_string(rt));
pdsman.cpp                 ALGO_ILOG("OnInstrumentDataReady. instr_id=%llu found prod_id=%llu in cache", m_instr_id, prod_id);
pdsman.cpp                             ALGO_ILOG("Ottif downloaded for prod_id=%llu", prod_id);
pdsman.cpp                             ALGO_ELOG("Product downloaded, but failed to get ottif info! prod_id=%llu", prod_id);
pdsman.cpp                 ALGO_ILOG("OnInstrumentDataReady. instr_id=%llu about to download prod_id=%llu", m_instr_id, prod_id);
pdsman.cpp                     ALGO_ELOG("GetProduct failed product_id=%llu error=%s", prod_id, tt::sdk::internal::to_string(rt));
pdsman.cpp                     ALGO_ELOG("Product cached in PDS consumer, but not ttsdk: prod_id=%llu. Racing condiction???", prod_id);
pdsman.cpp             ALGO_ILOG("OnInstrumentDataReady. instr_id=%llu prod_id=0 ", m_instr_id);
pdsman.cpp             ALGO_ELOG("GetProduct failed product_id=%llu error=%s", instr->GetProductId(), tt::sdk::internal::to_string(result));
pdsman.cpp         ALGO_ILOG("OnInstrumentDataReady and OnProductDataReady instr_id=%llu prod_id=%llu ", m_instr_id, prod_id);
pdsman.cpp                     ALGO_ELOG("GetTickTable failed product_id=%llu tick_table_id=%lu error=%s", prod_id, tick_table_id, tt::sdk::internal::to_string(static_cast<PDSDownloadResult>(rt.GetValue())));
pdsman.cpp             ALGO_ELOG("ProcessLegs: Invalid Leg Count" " leg_count=%zu" " instr_id=%llu", count, pds_instr_data->GetId());
pdsman.cpp             ALGO_ELOG("ProcessLegs:" " leg_count=%zu" " instr_id=%llu" " the Leg Count exceeds the max (% zu)", count, pds_instr_data->GetId(), TTSDK_MAX_LEG_COUNT);
pdsman.cpp              ALGO_ILOG("OnInstrumentDataReady and ProcessLegs instr_id=%llu leg_count=%d ", m_instr_id, count);
pdsman.cpp             ALGO_ILOG("OnInstrumentDataReady and ProcessLegs instr_id=%llu leg_instrument_Id=%llu ", m_instr_id, out_right_id);
pdsman.cpp                 ALGO_ELOG("The number of instrument legs exceeds the max (%zu). instr_id=%llu leg_instrument_Id=%llu ", TTSDK_MAX_LEG_COUNT, m_instr_id, out_right_id);
pdsman.cpp         ALGO_ELOG("InitializePDS failed url=%s error=%s", url, std::string(ex.what()));
pdsman.cpp         ALGO_ILOG("Initialize PDS succeeded");
pdsman.cpp     ALGO_ELOG("Initialize PDS failed url=%s error=%s", url, std::string(error.What()));
pdsman.cpp         ALGO_ILOG("Hit %s %d times. All good", url, count);
pdsman.cpp     ALGO_ELOG("Hit %s %d times. At least one failed", url, count);
pdsman.cpp         ALGO_ELOG("DownloadInstrument Failed: instr_id=0");
pdsman.cpp             ALGO_ILOG("DownloadInstrument: instr_id=%llu found in InstrumentCache", instr_id);
pdsman.cpp             ALGO_ILOG("DownloadInstrument starting instr_id=%llu, use_token=%d", instr_id, use_token);
pdsman.cpp             ALGO_ELOG("Instrument download timeout instr_id=%llu user_id=%llu. Try one more time., use_token=%d, retry=%u, retry_delay=%u", instr_id, user_id, use_token, retry, retry_delay);
pdsman.cpp         ALGO_ELOG("DownloadInstrument failed instr_id=%llu, use_token=%d, retry=%u, retry_delay=%u", instr_id, use_token, retry, retry_delay);
pdsman.cpp         ALGO_ELOG("DownloadInstrument succeeded. But instr_id=%llu invalid", instr_id);
pdsman.cpp         ALGO_ILOG("DownloadInstrument succeeded instr_id=%llu, use_token=%d, retry=%u, retry_delay=%u", instr_id, use_token, retry, retry_delay);
pdsman.cpp             ALGO_WLOG("DownloadInstrumentByName FAILED - invalid token. name=%s user_id=%llu, retry=%u, retry_delay=%u", name, user_id, retry, retry_delay);
pdsman.cpp                 ALGO_ILOG("SearchInstruments found %s and its id=%llu. Downloading...", name, item->GetId());
pdsman.cpp         ALGO_ELOG("SearchInstruments failed" " name=%s" " error=%s", std::string(name), std::string(error.What()));
pdsman.cpp     ALGO_WLOG("DownloadInstrumentByName FAILED - Unknown Instrument name=%s, retry=%u, retry_delay=%u", name, retry, retry_delay);
pdsman.cpp         ALGO_ELOG("SearchInstruments FAILED - PDSConsumer is not initialized");
pdsman.cpp             ALGO_WLOG("SearchInstruments FAILED - invalid token. name=%s user_id=%llu", name, user_id);
pdsman.cpp         ALGO_ELOG("SearchInstruments failed" " name=%s" " error=%s", std::string(name), std::string(error.What()));
pdsman.cpp         ALGO_ILOG("SearchInstruments worked!" " name=%s", std::string(name));
pdsman.cpp             ALGO_WLOG("DownloadResourceFile failed - invalid token. resource_name=%s user_id=%llu", resource_name, user_id);
pdsman.cpp         ALGO_ELOG("DownloadResourceFile failed - Memory allocation");
pdsman.cpp         ALGO_ELOG("DownloadResourceFile failed - Failed to open file. file=%s", dest_path);
pdsman.cpp         ALGO_ELOG("DownloadResourceFile failed - Failed to write to file. file=%s", dest_path);
pdsman.cpp             ALGO_WLOG("DownloadResourceFile failed - invalid token. resource_name=%s user_id=%llu", resource_name, user_id);
pdsman.cpp     ALGO_ILOG("DownloadResourceString() name=%s", resource_name);
pdsman.cpp         ALGO_ELOG("GetCurrencyRate failed error=%s", std::string(error.What()));
pdsman.cpp         ALGO_ELOG("GetAllSecurityExchange failed error=%s", std::string(error.What()));
pdsman.cpp         ALGO_ILOG("Building SecurityExchange Map: [%u,%s]=%u", key.market_id, key.name, security_exchange_id );
pdsman.cpp         ALGO_ELOG("GetMarketName failed" " market_id=%d" " error=%s", market_id, std::string(error.What()));
pdsman.cpp     ALGO_ILOG("AliasOrName=[%s] " "user_id=%llu, ", name_or_alias, user_id);
pdsman.cpp         ALGO_ELOG("GetInstrumentByAlias=[%s] Failed", name_or_alias);
pdsman.cpp             ALGO_ELOG("GetInstrumentByName=[%s] Failed", name_or_alias);
pdsman.cpp     ALGO_ILOG("AliasOrName=[%s] downloaded instr_id=%llu. About to download prod_id=%llu", name_or_alias, result->instr_snap.instr_id, prod_id);
pdsman.cpp             ALGO_ILOG("AliasOrName=[%s] found prod_id=%llu in cache", name_or_alias, prod_id);
pdsman.cpp                     ALGO_ELOG("AliasOrName=[%s] GetProduct failed product_id=%llu product_ptr is null ", name_or_alias, prod_id);
pdsman.cpp                 ALGO_ELOG("AliasOrName=[%s] GetProduct failed product_id=%llu error=%s", name_or_alias, prod_id, tt::sdk::internal::to_string(rt));
pdsman.cpp         ALGO_ILOG("AliasOrName=[%s] About to get ticket_table_id=%llu", name_or_alias, result->tick_table_id);
pdsman.cpp             ALGO_ELOG("AliasOrName=[%s] GetTickTable failed tick_table_id=%lu error=%s", name_or_alias, result->tick_table_id, tt::sdk::internal::to_string(static_cast<PDSDownloadResult>(rt.GetValue())));
pdsman.cpp         ALGO_ILOG("AliasOrName=[%s] About to get legs_size=%llu", name_or_alias, leg_size);
pdsman.cpp                     ALGO_ILOG("AliasOrName=[%s] Sucessful get leg(%d/%d) out_right_id=%llu", name_or_alias, result->legs.size(), leg_size, leg.out_right_id);
pdsman.cpp                     ALGO_ELOG("AliasOrName=[%s] Sucessful get leg(%d/%d) out_right_id=%llu, but the number of instrument legs exceeds the max (%zu)", name_or_alias, result->legs.size(), leg_size, leg.out_right_id, TTSDK_MAX_LEG_COUNT);
pdsman.cpp                 ALGO_ELOG("AliasOrName=[%s]Failed to get leg(%d/%d) out_right_id=%llu error=%s", name_or_alias, result->legs.size()+1, leg_size, leg.out_right_id, tt::sdk::internal::to_string(leg_result.first));
pdsman.cpp         ALGO_ELOG("PreloadSseInstruments failed - could not get names and ids for the environment");
pdsman.cpp                     ALGO_ELOG("ERROR - count=%d id=%llu - should be 0\n", count, id.instr_id);
pdsman.cpp                 ALGO_ILOG("PreloadSseInstruments OK. count=%d instr_id=%llu", count, id.instr_id);
pdsman.cpp                 ALGO_ELOG("PreloadSseInstruments Failed. count=%d instr_id=%llu error=", count, id.instr_id, result.first);
algo_store.cpp              ALGO_ELOG("Requesting url=%s failed. code=%ld response=%s", std::string(url.c_str()), code, std::string(output));
algo_store.cpp                 ALGO_ILOG("Got Ottif data! url=%s", endpoint);
algo_store.cpp                     ALGO_ILOG("ottif: ot=%d tif=%d", ottif.ot, ottif.tif);
algo_store.cpp                 ALGO_ILOG("DownloadProductOttifSync failed" " url=%s" " http_code=%ld" " reason=%s", endpoint, observer.http_code, observer.failure_reason);
algo_store.cpp         ALGO_ILOG("DownloadProductOttifSync: Exception caught." " url=%s" " error=%s", endpoint, std::string(ex.what()));
algo_store.cpp          ALGO_ILOG("DownloadProductOttifSync failed: Unknown exception caught." " url=%s", endpoint);
algo_store.cpp     ALGO_ILOG("DownloadPDSSystemDataSync ");
algo_store.cpp                 ALGO_ILOG("Got PDS system data");
algo_store.cpp                     ALGO_ILOG("OrderType: i=%d n=%s d=%s", ot.i, ot.n, ot.d);
algo_store.cpp                     ALGO_ILOG("TimeInForce: i=%d n=%s d=%s", tif.i, tif.n, tif.d);
algo_store.cpp                 ALGO_ILOG("DownloadPDSSystemDataSync failed" " url=%s" " http_code=%ld" " reason=%s", systemdata_endpoint, observer.http_code, observer.failure_reason);
algo_store.cpp         ALGO_ILOG("DownloadPDSSystemDataSync: Exception caught." " url=%s" " error=%s", systemdata_endpoint, std::string(ex.what()));
algo_store.cpp          ALGO_ILOG("DownloadPDSSystemDataSync failed: Unknown exception caught." " url=%s", systemdata_endpoint);
algo_store.cpp     ALGO_ILOG("Sending AlgoStore def request. url=%s", request_url);
algo_store.cpp                 ALGO_ELOG("AlgoStore algo def request failed." " url=%s" " http_code=%ld" " reason=%s", request_url, observer.http_code, observer.failure_reason);
algo_store.cpp         ALGO_ELOG("AlgoStore algo def request failed: Exception caught." " url=%s" " error=%s", request_url, error);
algo_store.cpp         ALGO_ELOG("AlgoStore algo def request failed: Unknown exception caught." " url=%s", request_url);
algo_store.cpp         ALGO_ILOG("Sending algo resource request. url=%s", url);
algo_store.cpp                 ALGO_ELOG("Algo resource request failed." " url=%s" " http_code=%ld" " reason=%s", url, observer.http_code, observer.failure_reason);
algo_store.cpp         ALGO_ELOG("Algo resource request failed: Exception caught." " url=%s" " error=%s", url, error);
algo_store.cpp         ALGO_ELOG("Algo resource request failed: Unknown exception caught." " url=%s", url);
algo_store.cpp     ALGO_ILOG("GetInstrumentFromEndPoint request_url=%s is_retry=%d", request_url, is_retry);
algo_store.cpp                 ALGO_ELOG("GetInstrumentFromEndPoint failed." " url=%s" " http_code=%ld" " reason=%s", request_url, observer.http_code, observer.failure_reason);
algo_store.cpp                     ALGO_ELOG("GetInstrumentFromEndPoint: No instrument! " " url=%s", request_url);
algo_store.cpp                     ALGO_ELOG("GetInstrumentFromEndPoint: Ambiguity!." " url=%s" " return size=%d", request_url, observer.response.instruments.size());
algo_store.cpp         ALGO_ELOG("GetInstrumentFromEndPoint failed: Exception caught." " url=%s" " error=%s", request_url, std::string(ex.what()));
algo_store.cpp         ALGO_ELOG("GetInstrumentFromEndPoint failed: Unknown exception caught." " url=%s", request_url);
algoinstmgr.cpp     ALGO_WLOG("TTSDKNullptrEventCallback -------------- user_request_id=%d", user_request_id);
algoinstmgr.cpp             ALGO_WLOG("ProcessOrderEvent received a response for an order whose parent_id does NOT match algo_inst_id: " "order_data=%p " "order_snap->order_id=%s " "algo_inst_mgr=%p " "algo_inst_mgr->parent_id=%s", static_cast<void*>(order_data), std::string(order_snap_order_id_str), static_cast<void*>(algo_mgr.get()), algo_mgr->GetAlgoInstanceId().to_string());
algoinstmgr.cpp                 ALGO_WLOG("ProcessOrderEvent received downloaded. " "order_data=%p " "[AlgoSDK]algo_order_id=%s", static_cast<void*>(order_data), algo_mgr->GetAlgoInstanceId().to_string());
algoinstmgr.cpp             ALGO_WLOG("ProcessOrderEvent: order_snap == nullptr, " "event=%s, " "user_request_id=%d, " "order_data=%p, " "algo_inst_id=%s ", std::string(TTSDK_OrderEventToString(event)), user_request_id, (void *)order_data, algo_mgr->GetAlgoInstanceId().to_string());
algoinstmgr.cpp         ALGO_ELOG( "ProcessUnsolicitedOrderEvent(): AlgoInstMgr no longer available or active");
algoinstmgr.cpp         ALGO_ELOG("ProcessPositionLimitUpdatedEvent: Callback function ptr was unexpectedly a nullptr, " "the requestor will NOT get a response of any sort.");
algoinstmgr.cpp         ALGO_ELOG("CheckMarketDataPermission: can not find user_id=%llu in s_usersMap " "[market_id=%d " "symbol=%s " "name=%s " "alias=[%s] " "security_exchange_id=%d " "update_source=%u]", user_id, instr_snap->market_id, std::string(instr_snap->symbol), std::string(instr_snap->name), std::string(instr_snap->alias), instr_data->security_exchange_id, instr_data->update_source);
algoinstmgr.cpp                     ALGO_WLOG("CheckMarketDataPermission: found user_id=%llu but permission NOT allowed:" "[market_id=%d " "symbol=%s " "name=%s " "alias=[%s] " "security_exchange_id=%d " "update_source=%u]", user_id, instr_snap->market_id, std::string(instr_snap->symbol), std::string(instr_snap->name), std::string(instr_snap->alias), instr_data->security_exchange_id, instr_data->update_source);
algoinstmgr.cpp     ALGO_ELOG("CheckMarketDataPermission: can not find " "matching exchange_id and security_exchange_id for " "user_id=%llu " "in s_usersMap " "[market_id=%d " "symbol=%s " "name=%s " "alias=[%s] " "security_exchange_id=%d " "update_source=%u]", user_id, instr_snap->market_id, std::string(instr_snap->symbol), std::string(instr_snap->name), std::string(instr_snap->alias), instr_data->security_exchange_id, instr_data->update_source);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] GetEnableNearFarTouchPriceReasonabilityFromUsersMap: Failed to find user_id=%llu in s_usersMap - defaulting to false!", algo_inst_id.to_string(), user_id);
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] GetEnableNearFarTouchPriceReasonabilityFromUsersMap: Found user_id=%llu in s_usersMap - setting=%s!", algo_inst_id.to_string(), user_id, std::string(itr->second->company_enable_near_far_touch_price_reasonability ? "true" : "false"));
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] GetEnableAlgoRiskChecksFromUsersMap: can not find user_id=%llu in s_usersMap. Default to false ", algo_inst_id.to_string(), user_id);
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] GetEnableAlgoRiskChecksFromUsersMap: Found user_id=%llu in s_usersMap - setting=%s!", algo_inst_id.to_string(), user_id, std::string(itr->second->company_enable_algo_risk_checks ? "true" : "false"));
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] ~AlgoInstMgr. " "this=%p " "active=%d " "About to delete ttsdk_order_data size=%zu " , m_instanceId.to_string(), this, (bool)m_active, m_to_delete.size());
algoinstmgr.cpp         ALGO_ILOG("[algo:%s] Removing algo_mgr[%p] from collection collection_size=%u", m_instanceId.to_string(), this, s_algoInstMgrs.size());
algoinstmgr.cpp             ALGO_ILOG("[algo:%s] m_loopCount=%llu, m_loopElapse=%lf", m_instanceId.to_string(), m_loopCount, m_loopElapse);
algoinstmgr.cpp         ALGO_ILOG("[algo:%s] TrackChildOrder: Child order already in track " "order_id=%s", GetAlgoInstanceId().to_string(), child_id.to_string());
algoinstmgr.cpp         ALGO_WLOG("[algo:%s] TrackChildOrder: logical_child_order_size=%zu", GetAlgoInstanceId().to_string(), m_childOrders.size());
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] OnChildOrderEvent: RiskReject, all subsequent orders will be rejected " "user_request_id= %llu " "order_id=%s " "order_data=%p " "rejectDetails=%s", m_instanceId.to_string(), user_request_id, child_id.to_string(), static_cast<void*>(order_data), m_childRejectDetails);
algoinstmgr.cpp                 ALGO_WLOG("[algo:%s] OnChildOrderEvent: CXL rejected due to already pending, " "Order moved to pending list! order_id=%s user_request_id=%u, " "remaining m_mapWaitChildDeletes.size=%u ", GetAlgoInstanceId().to_string(), childIdInMap.to_string(), user_request_id, m_mapWaitChildDeletes.size());
algoinstmgr.cpp                 ALGO_ELOG("[algo:%s] OnChildOrderEvent: Request time out! " "user_request_id=%llu ", m_instanceId.to_string(), user_request_id);
algoinstmgr.cpp                         ALGO_WLOG("[algo:%s] OnChildOrderEvent: First PurgChildOrder failure " "user_request_id=%llu " "status=%s ", GetAlgoInstanceId().to_string(), user_request_id, TTSDK_OrderStatusToString(order_snap->last_status));
algoinstmgr.cpp             ALGO_ILOG("[algo:%s] OnChildOrderEvent: Remove user_request_id=%u, remaining m_mapWaitChildDeletes.size=%u ", GetAlgoInstanceId().to_string(), user_request_id, m_mapWaitChildDeletes.size());
algoinstmgr.cpp                 ALGO_WLOG("[algo:%s] OnChildOrderEvent: Unsolcited CXL received. " "Remove from pending delete list! order_id=%s " "m_listPendingDeletes.size()=%d", GetAlgoInstanceId().to_string(), child_id.to_string(), m_listPendingDeletes.size());
algoinstmgr.cpp                 ALGO_WLOG("[algo:%s] OnChildOrderEvent respond_to_adlhost purgeChildOrdersSucceed=%d", GetAlgoInstanceId().to_string(), m_purgeChildOrdersSucceed);
algoinstmgr.cpp         ALGO_WLOG("[algo:%s] OnDetachOrder: logical_child_order_size=%zu", GetAlgoInstanceId().to_string(), m_childOrders.size());
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] PurgeChildOrders(%s) START", GetAlgoInstanceId().to_string(), (action == AlgoInstMgrAction::Cancel) ? "Cancel/Fail" : "Pause");
algoinstmgr.cpp                 ALGO_ILOG("[algo:%s] PurgeChildOrders: Detected in-flight child. Sending delete. " "user_request_id=%zu " "parent_id=%s " "action=%s " "order_data=%p", m_instanceId.to_string(), user_request_id, child->parent_id.to_string(), (action == AlgoInstMgrAction::Cancel) ? "Cancel" : "Pause", static_cast<void*>(child));
algoinstmgr.cpp         ALGO_ILOG("[algo:%s] PurgeChildOrders: (%u of %u), " "oma_parent_id=%s " "parent_id=%s " "order_id=%s " "am_I_oma_algo=%s, " "am_I_parent_algo=%s " "action=%s " "leave_on_cancel=%s " "leave_on_pause=%s ", m_instanceId.to_string(), iteration, m_childOrders.size(), (oma_exists) ? oma_parent_id_tt.to_string() : "nullptr", (parent_exists) ? parent_id_tt.to_string() : "nullptr", child_id.to_string(), (am_I_oma_algo)?"yes":"no", (am_I_parent_algo)?"yes":"no", (action == AlgoInstMgrAction::Cancel) ? "Cancel" : "Pause", (leave_on & ttsdk_leave_on_cancel)?"true":"false", (leave_on & ttsdk_leave_on_pause)?"true":"false");
algoinstmgr.cpp                 ALGO_ILOG("[algo:%s] PurgeChildOrders: MarshallDetachOrder(OMA): " "request_id=%u, " "order_id=%s, " "parent_order_id=%s, " "oma_parent_order_id=%s ", m_instanceId.to_string(), requestId, child_id.to_string(), (parent_exists) ? parent_id_tt.to_string() : "nullptr", (oma_exists) ? oma_parent_id_tt.to_string() : "nullptr");
algoinstmgr.cpp                     ALGO_ILOG("[algo:%s] PurgeChildOrders: MarshallDetachOrder(parent): " "request_id=%u, " "order_id=%s, " "parent_order_id=%s", m_instanceId.to_string(), requestId, child_id.to_string(), (parent_exists) ? child->parent_id.to_string() : "nullptr");
algoinstmgr.cpp             ALGO_DLOG("[algo:%s] PurgeChildOrders: CancelRequest: " "user_request_id=%d " "parent_id=%s " "order_id=%s ", m_instanceId.to_string(), user_request_id, (parent_exists) ? child->parent_id.to_string() : "nullptr", child_id.to_string());
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] PurgeChildOrders: waitForChildOrderDeletes=%d, m_mapWaitChildDeletes.size=%u", m_instanceId.to_string(), m_waitForChildOrderDeletes, m_mapWaitChildDeletes.size());
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] DetachChildOrders START", m_instanceId.to_string());
algoinstmgr.cpp         ALGO_ILOG( "[algo:%s] DetachChildOrders: (%u of %u), order_id=%s ", m_instanceId.to_string(), iteration, numChildren, child_id.to_string() );
algoinstmgr.cpp         ALGO_ILOG( "[algo:%s] DetachChildOrders: " "request_id=%u, " "order_id=%s, ", m_instanceId.to_string(), requestId, child_id.to_string() );
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] DownloadInstrument succeeded, but the instrument is invalid " "(deleted, inactive, or invalid_upload_source in PDS) " "instr_id=%llu " "use_token=%d", m_instanceId.to_string(), instr_id, use_token);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] DownloadInstrument failed " "instr_id=%llu " "error=%s " "use_token=%d ", m_instanceId.to_string(), instr_id, to_string(dl_result.first), use_token);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] DownloadInstrumentByName failed. name=nullptr", m_instanceId.to_string());
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] DownloadInstrumentByName starting. name=%s", m_instanceId.to_string(), std_name);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] DownloadInstrumentByName succeeded, but instrument is invalid " "(deleted, inactive, or invalid_upload_source in PDS) " "name=%s " "use_token=%d ", m_instanceId.to_string(), std_name, use_token);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] DownloadInstrumentByName failed " "name=%s " "error=%s " "use_token=%d ", m_instanceId.to_string(), std_name, to_string(dl_result.first), use_token);
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] DownloadInstrumentByName succeeded name=%s", m_instanceId.to_string(), std_name);
algoinstmgr.cpp         ALGO_ILOG("[Algo:%s] SearchInstruments failed " "query=%s " "error=%s ", m_instanceId.to_string(), query == nullptr ? NULL_STR : std::string(query), to_string(error));
algoinstmgr.cpp             ALGO_ELOG("[algo:%s] OpenPriceSub failed, requested subscription exceeds max allowed " "instr=%p " "instr_id=%llu " "user_id=%llu " "max_allowed=%u ", m_instanceId.to_string(), instr, instr_id, m_userId, env::instance().max_allowed_price_sub());
algoinstmgr.cpp         ALGO_ILOG( "[algo:%s] OpenPriceSub: Widened price interests to accomodate PnL calculations: " "instr=%p " "instr_id=%llu " "original_interests=%s " "widened_interests=%s", m_instanceId.to_string(), instr, instr_id, Filter(interests).to_string(), Filter(interests | ttsdk_interests_pnl).to_string() );
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] OpenPriceSub instr=%p instr_id=%llu interests=%s, subscribe_to_implies=%d", m_instanceId.to_string(), instr, instr_id, filter.to_string(), subscribe_to_implies);
algoinstmgr.cpp         ALGO_ILOG("[algo:%s] OpenPriceSub succeeded " "instr=%p " "instr_id=%llu " "user_id=%llu " "price_sub=%llu " "interests=%s", m_instanceId.to_string(), instr, instr_id, m_userId, *price_sub, filter.to_string());
algoinstmgr.cpp         ALGO_ILOG( "[algo:%s] CheckPriceSnap: user_request_id=%u instr_id=%llu " "address=%p " "ref_count=%u " "PriceSnap:seq_no=%llu, exchange_tm=%llu, " //[ 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 ] "[%llu->%llu->%llu->%llu->%llu->%llu->%llu->%llu->%llu] " "algo_recv_tm=%llu " "conflate_no=%llu " "b1=[%lf @ %0.8f(%0.8f)] " "b0=[%lf @ %0.8f(%0.8f)] " "a0=[%lf @ %0.8f(%0.8f)] " "a1=[%lf @ %0.8f(%0.8f)] " "non_matching=%d(%s) " "best_market_price=%lf " "crossing_levels=[%s]", m_instanceId.to_string(), request_id, instr_id, address, it->second->ref_count(), p->seq_no, p->exchange_time, p->mdrc_recv_time, //1 eReceivedByServer p->client_recv_time, //2 eReceived p->queue_up_time, //3 eQueuedUp p->dequeue_time, //4 eDequeued p->before_parse_time, //5 eBeforeParse p->after_parse_time, //6 eAfterParse p->after_cache_time, //7 eAfterCache p->after_merge_time, //8 eAfterMerge p->before_callback_time, //9 eBeforeUnifierCallback p->order_stimulus_received_algo, p->conflation_no, b1,b1_q,b1_implied, b0,b0_q,b0_implied, a0,a0_q,a0_implied, a1,a1_q,a1_implied, params_internal->non_matching, params_internal->non_matching?"NO internal match":"TTINT will do internal match", params_internal->best_market_price, crossing_levels_string );
algoinstmgr.cpp         ALGO_ILOG("[algo:%s] CheckPriceSnap: user_request_id=%u instr_id=%llu, non_matching=true(NO internal match) No PriceSnap!", m_instanceId.to_string(), request_id, instr_id);
algoinstmgr.cpp         ALGO_DLOG("[algo:%s] CalculateCrossingLevels: Exempting cancel request: user_request_id=%u", m_instanceId.to_string(), request_id);
algoinstmgr.cpp             ALGO_DLOG("[algo:%s] CalculateCrossingLevels: Market Order with no opposite side qty --> crossing_level=-1: user_request_id=%u", m_instanceId.to_string(), request_id);
algoinstmgr.cpp         ALGO_DLOG("[algo:%s] CalculateCrossingLevels: Limit Order with no opposite side qty --> crossing_level=0: user_request_id=%u", m_instanceId.to_string(), request_id);
algoinstmgr.cpp         ALGO_DLOG("[algo:%s] CalculateCrossingLevels: Order price will not cross opposite side market --> crossing_level=0: user_request_id=%u", m_instanceId.to_string(), request_id);
algoinstmgr.cpp             ALGO_DLOG("[algo:%s] CalculateCrossingLevels: Incoming order qty satisfied: user_request_id=%u", m_instanceId.to_string(), request_id);
algoinstmgr.cpp             ALGO_DLOG("[algo:%s] CalculateCrossingLevels: Incoming order will cross this price level: " "user_request_id=%u " "price_level=%f " "how_many_crossed_so_far=%d " "remaining_qty_to_match=%f", m_instanceId.to_string(), request_id, opposite_market.levels[i].price, crossing_level, remaining_qty_to_match);
algoinstmgr.cpp             ALGO_DLOG("[algo:%s] CalculateCrossingLevels: Incoming order price satisfied: user_request_id=%u", m_instanceId.to_string(), request_id);
algoinstmgr.cpp         ALGO_DLOG("[algo:%s] CalculateCrossingLevels: crossing_level=%d: user_request_id=%u", m_instanceId.to_string(), crossing_level, request_id);
algoinstmgr.cpp         ALGO_DLOG("[algo:%s] CalculateCrossingLevels: crossing_level=%d: user_request_id=%u", m_instanceId.to_string(), crossing_level, request_id);
algoinstmgr.cpp     ALGO_DLOG("[algo:%s] CalculateCrossingLevels: Incoming order will exhaust entire opposite market qty: user_request_id=%u", m_instanceId.to_string(), request_id);
algoinstmgr.cpp         ALGO_DLOG("[algo:%s] CalculateCrossingLevels: Market Order will exhaust entire opposite market --> crossing_level=-1: user_request_id=%u", m_instanceId.to_string(), request_id);
algoinstmgr.cpp     ALGO_DLOG("[algo:%s] CalculateCrossingLevels: Limit Order will exhaust entire opposite market --> crossing_level=%d: user_request_id=%u", m_instanceId.to_string(), crossing_level, request_id);
algoinstmgr.cpp             ALGO_ILOG( "[algo:%s] UpdatePriceInterests: Widened price interests to accomodate PnL calculations: " "price_sub=%llu " "original_interests=%s " "widened_interests=%s", m_instanceId.to_string(), price_sub, Filter(interests).to_string(), Filter(interests | ttsdk_interests_pnl).to_string() );
algoinstmgr.cpp                 ALGO_ILOG("[algo:%s] UpdatePriceInterests " "price_sub=%llu " "interests=%s", m_instanceId.to_string(), price_sub, Filter(interests).to_string());
algoinstmgr.cpp         ALGO_ILOG("[algo:%s] ReActivatePriceSubscriber ttsdk_price_sub=%llu", m_instanceId.to_string(), price_sub);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] ReActivatePriceSubscriber ttsdk_price_sub=%llu, but not found in s_priceSubscribers", m_instanceId.to_string(), price_sub);
algoinstmgr.cpp         ALGO_ILOG("[algo:%s] DeActivatePriceSubscriber ttsdk_price_sub=%llu", m_instanceId.to_string(), price_sub);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] DeActivatePriceSubscriber ttsdk_price_sub=%llu, but not found in s_priceSubscribers", m_instanceId.to_string(), price_sub);
algoinstmgr.cpp         ALGO_WLOG("[algo:%s] PlaceOrder: Rejecting request - " "PurgeChildOrders is waiting for child delete acknowledgements" " request_id=%d", m_instanceId.to_string(), request_id);
algoinstmgr.cpp             ALGO_ILOG("[algo:%s] PlaceOrder: params has at least one GDAX instrument", m_instanceId.to_string());
algoinstmgr.cpp                 ALGO_ILOG("[algo:%s] PlaceOrder: params has no primary_market_id. " "Value will be set from first leg market_id=%d", m_instanceId.to_string(), static_cast<int>(primary_market_id));
algoinstmgr.cpp             ALGO_ELOG("[algo:%s] PlaceOrder: sending PR order on synthetic instrument", m_instanceId.to_string());
algoinstmgr.cpp         ALGO_ILOG("Will route synthetic order(market_id=%u) to %s", market_id, answer);
algoinstmgr.cpp         ALGO_ILOG("Will route algo order to myself=%s", myself);
algoinstmgr.cpp         ALGO_DLOG("[algo:%s] PlaceOrder: request_id=%u price_deviation_data=%s", m_instanceId.to_string(), request_id, DebugDumpPriceDeviationData(price_deviation_data));
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] RegisterForUnsolicitedOrders() request_id=%u, callback=%p, user_id=%llu, account_id=%llu", m_instanceId.to_string(), request_id, (void *)unsolicited_cb, GetUserId(), account_id);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] ChangeOrder: Failed to find instr_data for order_data=%p", m_instanceId.to_string(), static_cast<void*>(order_data));
algoinstmgr.cpp             ALGO_WLOG("[algo:%s] ChangeOrder: Rejecting request - " "PurgeChildOrders is waiting for child delete acknowledgements" " request_id=%d", m_instanceId.to_string(), request_id);
algoinstmgr.cpp         ALGO_DLOG("[algo:%s] ChangeOrder: request_id=%u price_deviation_data=%s", m_instanceId.to_string(), request_id, DebugDumpPriceDeviationData(price_deviation_data));
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] RegisterProfitLossSub: refused to start a REDUNDANT p&l subscription: algo_inst_mgr=%p", m_instanceId.to_string(), (void*)this);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] RegisterProfitLossSub: FAILED - event_cb was null: algo_inst_mgr=%p", m_instanceId.to_string(), (void*)this);
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] RegisterProfitLossSub: algo_inst_mgr=%p currency=%s", m_instanceId.to_string(), (void*)this, preferred_currency == ttsdk_currency_code_USD ? "USD": std::to_string(preferred_currency));
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] UpdateProfitLoss (order): failed to get INSTR ID from order_snap: " "error=%s " "order_snap->last_status=%d " "order_snap=%p", m_instanceId.to_string(), TTSDK_ERROR_STR[error], order_snap->last_status, order_snap.get());
algoinstmgr.cpp             ALGO_ELOG("[algo:%s] UpdateProfitLoss (order): failed to retrieve CURRENCY CONVERSION RATE: " "error=%s " "product_id=%llu " "order_snap->last_status=%d " "order_snap=%p", m_instanceId.to_string(), ex.what(), instr_snap.product_id, order_snap->last_status, order_snap.get());
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] UpdateProfitLoss (order): failed to retrieve FILL SIDE out of order_snap: " "error=%s " "order_snap->last_status=%d " "order_snap->instr_id=%llu " "order_snap=%p", m_instanceId.to_string(), TTSDK_ERROR_STR[error], order_snap->last_status, instr_id, order_snap.get());
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] UpdateProfitLoss (order): failed to retrieve FILL QTY out of order_snap: " "error=%s " "order_snap->last_status=%d " "order_snap->instr_id=%llu " "order_snap=%p", m_instanceId.to_string(), TTSDK_ERROR_STR[error], order_snap->last_status, instr_id, order_snap.get());
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] UpdateProfitLoss (order): failed to retrieve FILL PRC out of order_snap: " "error=%s " "order_snap->last_status=%d " "order_snap->instr_id=%llu " "order_snap=%p", m_instanceId.to_string(), TTSDK_ERROR_STR[error], order_snap->last_status, instr_id, order_snap.get());
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] UpdateProfitLoss (order): failed to derive THEO EXIT PRC: " "error=%s " "order_snap->last_status=%d " "order_snap->instr_id=%llu " "order_snap=%p", m_instanceId.to_string(), TTSDK_ERROR_STR[error], order_snap->last_status, instr_id, order_snap.get());
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] UpdateProfitLoss (price): failed to derive THEO EXIT PRC: " "error=%s " "instr_id=%llu", m_instanceId.to_string(), TTSDK_ERROR_STR[error], instr_id);
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] current_user_id %llu->%llu ", m_instanceId.to_string(), m_userId, new_current_user_id);
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] %s", m_instanceId.to_string(), GroupIDsToString(group_ids));
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] GetAlgoSettings: can not find user_id=%llu in s_usersMap ", m_instanceId.to_string(), m_userId);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] GetAlgoSettings: Internal Error. userobjPtr->ptr_accounts==nullptr; can not find matching account=%llu ", m_instanceId.to_string(), account_id);
algoinstmgr.cpp     ALGO_ELOG("[algo:%s] GetAlgoSettings: can not find matching account=%llu ", m_instanceId.to_string(), account_id);
algoinstmgr.cpp         ALGO_ILOG("[algo:%s] CheckSSEPermission: using originating_user_id=%llu (user_id=%llu)", m_instanceId.to_string(), effective_user_id, m_userId);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] CheckSSEPermission: can not find user_id=%llu in s_usersMap ", m_instanceId.to_string(), effective_user_id);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] CheckSSEPermission: Internal Error. userobjPtr->ptr_accounts==nullptr; account=%llu ", m_instanceId.to_string(), account_id);
algoinstmgr.cpp                     ALGO_ELOG("[algo:%s] CheckSSEPermission: algo_obv_access denied, %d", env::instance().algo_obv_access());
algoinstmgr.cpp                 ALGO_ELOG("[algo:%s] CheckSSEPermission: %s is not set in TTUS.", m_instanceId.to_string(), TTSDK_ORDER_SYNTHETIC_TYPE_STR[sse_type]);
algoinstmgr.cpp                 ALGO_ELOG("[algo:%s] CheckSSEPermission: found matching account=%llu , but %s disallowed", m_instanceId.to_string(), account_id, TTSDK_ORDER_SYNTHETIC_TYPE_STR[sse_type]);
algoinstmgr.cpp     ALGO_ELOG("[algo:%s] CheckSSEPermission: can not find matching account=%llu for user_id=%llu", m_instanceId.to_string(), account_id, effective_user_id);
algoinstmgr.cpp         ALGO_ILOG("[algo:%s] CheckSSEPermission: using originating_user_id=%llu (user_id=%llu)", m_instanceId.to_string(), effective_user_id, m_userId);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] CheckADLPermission: can not find user_id=%llu in s_usersMap ", m_instanceId.to_string(), effective_user_id);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] CheckADLPermission: Internal Error. userobjPtr->ptr_accounts==nullptr", m_instanceId.to_string());
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] CheckADLPermission: No account specified for algo. " "And user_id=%llu has no ADL permission from any account", m_instanceId.to_string(), m_userId);
algoinstmgr.cpp                     ALGO_ELOG("[algo:%s] CheckADLPermission: account=%llu does not allow ADL", m_instanceId.to_string(), account_id);
algoinstmgr.cpp             ALGO_ELOG("[algo:%s] CheckADLPermission: can not find matching account=%llu ", m_instanceId.to_string(), account_id);
algoinstmgr.cpp         ALGO_ILOG("AlgoInstMgr::ScheduleOBVGreekEvent() active=%d algo_inst_mgr=%p url=%s", this->Active(), (void *)this, std::string(url));
algoinstmgr.cpp         ALGO_ILOG("[algo:%s] Create new algo_mgr[%p]", algo_inst_id.to_string(), static_cast<void*>(algo_mgr.get()));
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] CreateAlgoInstMgr failed to allocate memory", algo_inst_id.to_string());
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] CreateAlgoInstMgr exception=%s", algo_inst_id.to_string(), std::string(what ? what : "unknown"));
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] DetermineEnableNearFarTouchPriceReasonability: Failed to retrieve EnableNearFarTouchPriceReasonability param for user_id=%llu during recovery - defaulting to false!", algo_inst_id.to_string(), user_id);
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] DetermineEnableNearFarTouchPriceReasonability: %s", algo_inst_id.to_string(), std::string(value == 1 ? "true" : "false"));
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] DetermineEnableAlgoRiskChecks: Failed to retrieve EnableAlgoRiskChecks param for user_id=%llu during recovery - defaulting to false!", algo_inst_id.to_string(), user_id);
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] DetermineEnableAlgoRiskChecks: %s", algo_inst_id.to_string(), std::string(value == 1 ? "true" : "false"));
algoinstmgr.cpp                 ALGO_ELOG("Receive synthetic order of type %s. Ignoring it!", TTSDK_ORDER_SYNTHETIC_TYPE_STR[synth_type]);
algoinstmgr.cpp         ALGO_ELOG("TTSDKUtil_ThreadSwitchOrderEvent error=%s " "event=%s " "order_data=%p " "user_request_id=%llu ", TTSDK_ERROR_STR[error], std::string(TTSDK_OrderEventToString(event)), order_data, user_request_id);
algoinstmgr.cpp         ALGO_ELOG("RecoveryEvent: AlgoInstMgr is invalid or inactive, dropping response");
algoinstmgr.cpp             ALGO_ELOG("RecoveryEvent: Callback cannot be invoked." " callback=%p" " active=%d", (void*)cb, mgr->Active());
algoinstmgr.cpp     ALGO_ILOG("Enqueue recovery response:" " algo_inst_mgr=%p" " inst_id=%s", static_cast<void*>(algo_inst_mgr), algo_mgr->GetAlgoInstanceId().to_string());
algoinstmgr.cpp     ALGO_DLOG("TTSDKUtil_ThreadSwitchPositionLimitUpdate: " "Delivering position limit updated response from OrderD Thread to Algojob Thread: " "result=%s " "is_long_limit=%s " "limit=%f " "algo_inst_mgr=%p " "user_data=%p", result ? std::string("true") : std::string("false"), is_long_limit ? std::string("true") : std::string("false"), limit, static_cast<void*>(algo_inst_mgr), user_data);
algoinstmgr.cpp         ALGO_ELOG("TTSDKUtil_ThreadSwitchPositionLimitUpdate: AlgoInstMgr is invalid or inactive," " the requestor will NOT get a response of any sort.");
algoinstmgr.cpp     ALGO_ILOG("TTSDKUtil_ThreadSwitchPositionLimitUpdate: Enqueue position limit updated event: " "algo_inst_mgr=%p " "inst_id=%s ", static_cast<void*>(algo_inst_mgr), algo_mgr->GetAlgoInstanceId().to_string());
algoinstmgr.cpp     ALGO_ILOG("ClosePriceSub price_sub=%llu", price_sub);
algoinstmgr.cpp             ALGO_ILOG("ClosePriceSub. Did not find in s_jobInstrPriceSubCount instr_id=%llu user_id=%llu", instr_id, user_id);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] TTSDK_DownloadInstrByAliasOrName instrument is invalid " "name_or_alias=[%s] ", algo_mgr->GetAlgoInstanceId().to_string(), name_or_alias);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] TTSDK_DownloadInstrByAliasOrName failed " "name_or_alias=[%s] " "error=%s ", algo_mgr->GetAlgoInstanceId().to_string(), name_or_alias, to_string(dl_result.first));
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] TTSDK_DownloadInstrByAliasOrName succeeded " "name_or_alias=[%s]", algo_mgr->GetAlgoInstanceId().to_string(), name_or_alias);
algoinstmgr.cpp     ALGO_ILOG("TTSDKUtil_UpdateUser: " "user_id=%llu user_company_id=%llu account_count=%zu market_data_count=%zu sim_party_id=%llu " "[AlgoJob: thread_id= %d]", user_id, user->user_company_id, user->account_count, user->market_data_count, user->sim_party_id, syscall(SYS_gettid));
algoinstmgr.cpp     ALGO_ILOG( "TTSDKUtil_UpdateOrderD: user_id=%llu " "[OrderD: thread_id= %d]" , user_id, syscall(SYS_gettid) );
algoinstmgr.cpp         ALGO_ELOG( "TTSDKUtil_UpdateOrderD: Can not find user_id=%llu", user_id );
algoinstmgr.cpp         ALGO_ELOG("CheckUserRequireApprova: can not find user_id=%llu in s_usersMap ", user_id);
algoinstmgr.cpp         ALGO_ELOG("GetPersonId: can not find user_id=%llu in s_usersMap ", user_id);
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] UpdatePositionLimit: Failed - user_data or cb or was null!", m_instanceId.to_string());
algoinstmgr.cpp         ALGO_ILOG("[algo:%s] isGdaxMarketIdSet() Found gdax recursion=%d, instr_id=%llu, market_id=%d, name=%s", m_instanceId.to_string(), level, instr_data->instr_snap.instr_id, instr_data->instr_snap.market_id, ( (instr_data->instr_snap.name != nullptr) ? std::string(instr_data->instr_snap.name) : "") );
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] isGdaxMarketIdSet() recursion=%d, instr_id=%llu, market_id=%d, name=%s", m_instanceId.to_string(), level, instr_data->instr_snap.instr_id, instr_data->instr_snap.market_id, ( (instr_data->instr_snap.name != nullptr) ? std::string(instr_data->instr_snap.name) : "") );
algoinstmgr.cpp         ALGO_DLOG("EpiqSwitch order_id=%s, instr_id=%llu, epiq=%f", tt::algoutil::ttuuid(order_id).to_string(), instr_id, epiq_value);
algoinstmgr.cpp                     ALGO_ELOG( "TTSDKUtil_ThreadSwitchEpiqEvent(): AlgoInstMgr no longer available or active");
algoinstmgr.cpp     ALGO_ILOG("[algo:%s] OnClass2FieldsChanged ", m_instanceId.to_string());
algoinstmgr.cpp         ALGO_ELOG("[algo:%s] CollectToDelete. order_data=%p exist already (Detached twice?) ", m_instanceId.to_string(), order_data);
position_downloader.cpp     ALGO_ILOG("PositionDownloader created: id=%zu, " "user_id=%llu, " "account_id=%llu, " "product_id=%llu " "host_algo=%p " "url=%s ", m_id, m_userId, m_accountId, m_productId, m_host_algo, m_positionServiceUrl);
position_downloader.cpp          ALGO_ILOG("PositionDownloader OnDownloadCompleted. m_host_algo=%p no longer valid", m_host_algo);
position_downloader.cpp       ALGO_ILOG("raw=%s", j.dump());
position_downloader.cpp           ALGO_ILOG("PositionDownloader httpCode=%llu, id=%zu, user_id=%llu request_id=%s no position!", httpCode, m_id, m_userId, request_id);
position_downloader.cpp           ALGO_ILOG("PositionDownloader request_id=%s", request_id);
position_downloader.cpp                   ALGO_ILOG("No position for market_id=%llu account_id=%llu ", market_id, account_id);
position_downloader.cpp                           ALGO_ILOG("instrument_data with no quantity_total. raw=%s", i.dump());
position_downloader.cpp                           ALGO_ILOG("Add position count=%llu " "instrument_id=%llu " "net_pos=%lf " "sod_net=%lf " "wrk_buy=%lf " "wrk_sell=%lf " "filled_buy=%lf " "filled_sell=%lf", count, p.instrument_id, p.net_pos, p.sod_net, p.wrk_buy, p.wrk_sell, p.buy_qty, p.sell_qty );
position_downloader.cpp           ALGO_ILOG("PositionDownloader: totally delievered count=%zu ", count);
position_downloader.cpp         ALGO_ELOG("PositionDownloader OnDownloadCompleted failed: " " id=%zu" " exception=%s " "count=%llu " "record=%s ", m_id, std::string(e.what()), count, r.dump());
position_downloader.cpp     ALGO_ELOG("PositionDownloader fail: %s", std::string(errorBuffer.c_str()));
position_downloader.cpp     ALGO_ILOG("PositionDownloader Run: id=%zu, user_id=%llu product_id=%llu request_id=%s", m_id, m_userId, m_productId, request_id);
position_downloader.cpp             ALGO_ELOG("PositionDownloader RUn failed: no account");
position_downloader.cpp         ALGO_ILOG("PositionDownloader DownloadAsync %s", url);
position_downloader.cpp         ALGO_ELOG("PositionDownloader Run failed:" " id=%zu" " exception=%s", m_id, std::string(e.what()));
position_downloader.cpp         ALGO_ILOG("PositionDownloader Run failed: id=%zu, unknown exception", m_id);
service.cpp         ALGO_WLOG("[algo:%s] Stop called, but InValid algo", m_instance_id);
service.cpp         ALGO_ELOG("[algo:%s] Stop. error=%s", m_instance_id, TTSDK_ERROR_STR[error]);
service.cpp         ALGO_ILOG("[algo:%s] Stop request queued", m_instance_id);
service.cpp         ALGO_ILOG("Downloader %zu removed", m_id);
service.cpp     ALGO_ILOG("-------------------------> ~RestfulAPI: m_downloaders.size()=%d", m_downloaders.size());
service.cpp         ALGO_ILOG("-------------------------> ~RestfulAPI(): finished");
service.cpp         ALGO_WLOG("-------------------------> ~RestfulAPI(): still unfinished downloads: m_downloaders.size()=%d", m_downloaders.size());
service.cpp         ALGO_ILOG("[algo:%s this=%p] About to OnStartAlgo",algo->m_instance_id, (void*)algo);
service.cpp         ALGO_ILOG("[algo:%s this=%p] OnStartAlgo error=%s ttsdk_build_date=" BUILD_DATE " ttsdk_build_commit=" BUILD_COMMIT, algo->m_instance_id, (void*)algo, to_string(error));
service.cpp         ALGO_ELOG("[algo:%s this=%p] OnStartAlgo Failed",algo->m_instance_id, (void*)algo);
service.cpp         ALGO_ILOG("[algo:%s this=%p] OnUpdateAlgo error=%s",algo->m_instance_id, (void*)algo, to_string(error));
service.cpp         ALGO_ELOG("[algo:%s this=%p] OnUpdateAlgo Failed ex=%s",algo->m_instance_id, (void*)algo, std::string(ex.what()));
service.cpp         ALGO_ELOG("[algo:%s this=%p] OnUpdateAlgo Failed",algo->m_instance_id, (void*)algo);
service.cpp         ALGO_ILOG("[algo:%s this=%p] OnPauseAlgo error=%s",algo->m_instance_id, (void*)algo, to_string(error));
service.cpp         ALGO_ELOG("[algo:%s this=%p] OnPauseAlgo Failed ex=%s",algo->m_instance_id, (void*)algo, std::string(ex.what()));
service.cpp         ALGO_ELOG("[algo:%s this=%p] OnPauseAlgo Failed",algo->m_instance_id, (void*)algo);
service.cpp         ALGO_WLOG("[algo=%p] OnStopAlgo, but InValid algo", algo);
service.cpp         ALGO_ILOG("[algo:%s this=%p] OnStopAlgo error=%s",algo->m_instance_id, (void*)algo, to_string(error));
service.cpp         ALGO_ELOG("[algo:%s this=%p] OnStopAlgo Failed ex=%s",algo->m_instance_id, (void*)algo, std::string(ex.what()));
service.cpp         ALGO_ELOG("[algo:%s this=%p] OnStopAlgo Failed",algo->m_instance_id, (void*)algo);
service.cpp         ALGO_WLOG("[algo=%p] OnScheduledEvent, but InValid algo", algo);
service.cpp         ALGO_ILOG("[algo:%s this=%p] OnScheduledEvent Failed",algo->m_instance_id, (void*)algo);
service.cpp         ALGO_WLOG("[algo=%p] OnDestroyAlgo, but InValid algo", algo);
service.cpp     ALGO_ILOG("[algo:%s this=%p] OnDestroyAlgo",algo->m_instance_id, (void*)algo);
service.cpp     ALGO_ILOG("[algo:%s] Registor For Epiq Updates", m_instance_id);
algo_order.cpp         ALGO_WLOG("[AlgoOrder: %p] Can not Detach while m_order is null", (void*)this);
algo_order.cpp         ALGO_WLOG("[algo=%s] Cannot DownloadOrder synthetic_status=%s", m_algo->GetInstanceIdString(), to_string(synstatus));
algo_order.cpp         ALGO_WLOG("[algo=%s] Downloading: order_id=%s request_id=%llu order_data=%p", m_algo->GetInstanceIdString(), order_id, request_id, order_data);
algo_order.cpp                 ALGO_WLOG("[AlgoOrderManager: %p] Pausing Algo. Risk reject received while working." " user_request_id=%d", (void*)this, user_request_id);
algo_instrument.cpp     ALGO_ILOG("[algo:%p] successfully create AlgoInstrument by id=%llu: name=%s leg_count=%zu", algo, instrument_id, data->name, data->instr_snap.instr_legs.count);
algo_instrument.cpp     ALGO_ILOG("[algo:%p] successfully create AlgoInstrument by name/alias=%s: id=%llu leg_count=%zu", algo, instr_name, data->instr_snap.instr_id, data->instr_snap.instr_legs.count);
live_data_provider_via_pricelib.cpp     ALGO_ILOG( "[%s] LiveDataProviderViaPriceLib ctor @%p", m_name, this);
live_data_provider_via_pricelib.cpp     ALGO_ILOG( "[%s] LiveDataProviderViaPriceLib dtor @%p", m_name, this);
live_data_provider_via_pricelib.cpp     ALGO_ILOG( "[%s] LiveDataProviderViaPriceLib::Init @%p", m_name, this);
live_data_provider_via_pricelib.cpp     ALGO_ILOG( "[%s] LiveDataProviderViaPriceLib::Reset @%p", m_name, this);
live_data_provider_via_pricelib.cpp     ALGO_ILOG( "[%s] LiveDataProviderViaPriceLib::Shutdown @%p", m_name, this);
live_data_provider_via_pricelib.cpp     ALGO_ILOG( "[%s] LiveDataProviderViaPriceLib::SubscribeTrades for instrument_id=%llu @%p", m_name, instr_id, this);
live_data_provider_via_pricelib.cpp         ALGO_ELOG( "[%s] LiveDataProviderViaPriceLib::SubscribeTrades failed for instrument_id=%llu @%p result=%d", m_name, instr_id, this, result);
live_data_provider_via_pricelib.cpp     ALGO_ILOG( "[%s] LiveDataProviderViaPriceLib::UnsubscribeTrades for instrument_id=%llu @%p %s", m_name, instr_id, this, (m_priceSub == nullptr ? "m_priceSub==nullptr" : ""));
live_data_provider_via_pricelib.cpp     ALGO_DLOG( "[%s] LiveDataProviderViaPriceLib::OnTimeSalesUpdate @%p", m_name, this);
live_data_provider_via_pricelib.cpp     ALGO_ILOG( "[%s] LiveDataProviderViaPriceLib::OnPriceUpdate for %s @%p", m_name, m_instr_name, this);
live_data_provider_via_pricelib.cpp     ALGO_ILOG( "[%s] LiveDataProviderViaPriceLib::OnError @%p error=%d", m_name, this, error);

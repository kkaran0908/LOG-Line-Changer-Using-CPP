host_exec_if.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] InternalInitiateAction="<<algoif::ALGO_ACTION_STR[action]<<", state="<<ALGO_STATE_STR[get_state()]<<endl;
host_exec_if.cpp            TTLOG(INFO,13)<<"Pausing: "<<m_algo_bin.report_statistics()<<endl;
host_exec_if.cpp        TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] ScheduleAction: Invalid or redundant action. Skip. state="<<ALGO_STATE_STR[state]<<" action="<<ALGO_ACTION_STR[action]<<endl;
host_exec_if.cpp        TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"] ScheduleAction="<<ALGO_ACTION_STR[action]<<" state="<<ALGO_STATE_STR[state]<<endl;
host_exec_if.cpp        TTLOG(INFO,13)<<"InitiateNextAction pop="<<ALGO_ACTION_STR[nextAction]<<", state="<<ALGO_STATE_STR[get_state()]<<","<<endl;
host_exec_if.cpp            TTLOG(ERROR,13)<<"Action Invalid, dropping."<<endl;
host_exec_if.cpp    TTLOG(INFO,13)<<" DownloadOrder: order_id="<<order_id<<", ttuuid="<<order_uuid<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: Download request failed("<<TTSDK_ERROR_STR[result]<<") for order_id="<<order_id<<" request_id="<<request_id<<" "<<endl;
host_exec_if.cpp        TTLOG(INFO,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: Download request sent for order_id="<<order_id<<" request_id="<<request_id<<" "<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: TTSDK_AttachSyntheticChildOrder failed:("<<TTSDK_ERROR_STR[result]<<"), for order_id="<<order_id_string<<endl;
host_exec_if.cpp        TTLOG(INFO,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: TTSDK_AttachSyntheticChildOrder finished for order_id="<<order_id_string<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: TTSDK_PlaceBasicOrder failed:("<<TTSDK_ORDER_ERR_STR[result]<<")"<<endl;
host_exec_if.cpp                TTLOG(WARNING,13)<<"[algo:"<<m_algo_bin.inst_id()<<"]: "<<msg<<endl;
host_exec_if.cpp                TTLOG(WARNING,13)<<"[algo:"<<m_algo_bin.inst_id()<<"]: "<<msg<<endl;
host_exec_if.cpp        TTLOG(DEBUG,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: FlushAlert: total_count="<<total_count<<" total_audit_trail_count="<<total_audit_trail_count<<endl;
host_exec_if.cpp    TTLOG(INFO,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: SearchConnector called with \n path="<<path<<"\n splitted_path.size()="<<splitted_path.size()<<" \n referenced_block_id="<<referenced_block_id<<" \n connector_id="<<connector_id<<endl;
host_exec_if.cpp        TTLOG(INFO,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: push owning_graph[name="<<owning_block->blockInst->name<<", owning_block->id="<<owning_block_guid<<"] to path_of_alert_block. Now size()="<<path_of_alert_block.size()<<"."<<endl;
host_exec_if.cpp            TTLOG(DEBUG,13)<<"[algo:"<<m_algo_bin.inst_id()<<"]: Found groupblock with segment "<<path_segment<<endl;
host_exec_if.cpp                    TTLOG(WARNING,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: Alert and Reference block deviated: Alert:"<<graph_on_path_of_alert_block==nullptr?"NULL":GuidToString(graph_on_path_of_alert_block->owningBlockInstData->blockInst->id<<", ReferenceBlock:"<<'-')<<" "<<endl;
host_exec_if.cpp                    TTLOG(ERROR,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: Found virtual gourp on ReferenceBlock path for "<<path_segment<<". But there is no corresponding graph on Alert path!! This is likely due to Alert and Referenced block are on DIFFERENT virtual group path."<<endl;
host_exec_if.cpp                    TTLOG(WARNING,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: Found virtual gourp on ReferenceBlock path for "<<path_segment<<". use the graph["<<GuidToString(graph_on_path_of_alert_block->owningBlockInstData->blockInst->id<<"] on Alert path to ping down the proper virtualizaiton"<<endl;
host_exec_if.cpp            TTLOG(ERROR,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: AlertBlock formula failed to find block: "<<path_segment<<" in current graph"<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: AlertBlock formula failed to find block by Id: "<<referenced_block_id<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<"TTSDKOrderEventCallback. Something is wrong. user_data is NULL!!"<<endl;
host_exec_if.cpp            TTLOG(WARNING,13)<<"TTSDKOrderEventCallback: receive ttsdk_order_event_detached for existing order[pointer="<<static_cast<void*>(subscriber->order)<<"] orderSubscriber->callbacks.size()="<<call_back_size<<"u [should be 0]"<<endl;
host_exec_if.cpp        TTLOG(INFO,13)<<"TTSDKOrderEventCallback: No listerner in the callbacks of existing order[pointer="<<static_cast<void*>(subscriber->order)<<"] [order_event="<<TTSDK_OrderEventToString(event)<<"].[status="<<(order_snap==nullptr?"order_snapisnull!":TTSDK_OrderStatusToString(order_snap->last_status))<<"]. Likely this event is generated before OrderD detach"<<endl;
host_exec_if.cpp        TTLOG(INFO,13)<<"TTSDKOrderEventCallback: Order is Orphan-ed: subscriber="<<subscriber<<" subscriber.order="<<static_cast<void*>(subscriber->order)<<" [order_event="<<TTSDK_OrderEventToString(event)<<"] [status="<<(order_snap==nullptr?"order_snapisnull!":TTSDK_OrderStatusToString(order_snap->last_status))<<"] "<<endl;
host_exec_if.cpp        TTLOG(WARNING,13)<<"TTSDKProfitLossEventCallback: PnlManager=nullptr algo_inst_mgr="<<static_cast<void*>(algo_inst_mgr)<<" user_data="<<user_data<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_algo_bin.inst_id()<<"]: price_sub="<<price_sub<<"lu is not in m_priceSubscriptions"<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] IsSOAFill: Child fill missing instr_id"<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] IsSOAFill: Parent Order Instrument missing"<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] IsSOAFill: Child fill missing side"<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] IsSOAFill: Parent Order Side missing"<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] OnSOAFilled: Child fill missing last fill prc or qty"<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] OnSOAFilled: Parent Order Qty missing"<<endl;
host_exec_if.cpp    TTLOG(INFO,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: OnSOAFilled: Publishing fill: parent_cum_fill_qty: "<<parent_cum_fill_qty<<" parent_order_qty: "<<parent_order_qty<<" child_last_fill_price: "<<child_last_fill_price<<" child_last_fill_qty: "<<child_last_fill_qty<<" trade_date="<<trade_date<<"lu "<<endl;
host_exec_if.cpp        TTLOG(INFO,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: OnSOAFilled: Fully/Over filled - scheduling algo stop: parent_cum_fill_qty: "<<parent_cum_fill_qty<<" parent_order_qty: "<<parent_order_qty<<" child_last_fill_price: "<<child_last_fill_price<<" child_last_fill_qty: "<<child_last_fill_qty<<endl;
host_exec_if.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] OnSOAFilled: Suppressing all send status from this point on."<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] OnSOAUpdated: Parent Order Qty missing"<<endl;
host_exec_if.cpp        TTLOG(INFO,13)<<" [algo:"<<m_algo_bin.inst_id()<<"]: OnSOAUpdated: Parent order qty decreased to/below parent cum qty - scheduling algo stop: parent_cum_fill_qty: "<<parent_cum_fill_qty<<" parent_order_qty: "<<parent_order_qty<<" parent_wrk_qty: "<<parent_wrk_qty<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] VerifySOAParams: Parent Order Instrument missing"<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] VerifySOAParams: Parent Order Qty missing"<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] VerifySOAParams: Parent Side missing"<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<"TTSDKPositionLimitUpdatedEvent: user_data was unexpectedly a nullptr, the requestor will NOT get a response of any sort."<<endl;
host_exec_if.cpp        TTLOG(WARNING,13)<<"[algo:"<<m_algo_bin.inst_id()<<"]: SaveStateToDisk: Will not save state to disk since synth_status is ["<<TTSDK_SYNTH_STATUS_STR[synth_status]<<"]!"<<endl;
host_exec_if.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] Saving state to disk."<<endl;
host_exec_if.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] Loading state from disk."<<endl;
host_exec_if.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] Marking recovery file as stale."<<endl;
host_exec_if.cpp    TTLOG(DEBUG,13)<<""<<msg.str()<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_algo_bin.inst_id()<<"]: CanRecover: Missing pre-recovery synthetic status!"<<endl;
host_exec_if.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_algo_bin.inst_id()<<"]: CanRecover: Cannot recover back to synth status of ["<<TTSDK_SYNTH_STATUS_STR[pre_recovery_synth_status]<<"]!"<<endl;
host_exec_if.cpp    TTLOG(INFO,13)<<"[algo:"<<m_algo_bin.inst_id()<<"]: highest_recursion_level="<<m_highest_recursion_level<<"u"<<endl;
so_algo_bin_host_events.cpp                TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] process_external_request: Failed to get Algo Instrument ID!"<<endl;
so_algo_bin_host_events.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] DetermineEnableNearFarTouchPriceReasonability: using originating_user_id="<<effective_user_id<<"lu (user_id="<<m_algo_bin.user_id()<<"lu)"<<endl;
so_algo_bin_host_events.cpp        TTLOG(DEBUG,13)<<"[algo:"<<inst_id()<<"]: Creating AlgoInstMgr with "<<GroupIDsToString(group_ids)<<endl;
so_algo_bin_host_events.cpp                TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] process_external_request: Failed to update FIX params for reject response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" IGNORE this warning if FIX is not involved!"<<endl;
so_algo_bin_host_events.cpp                TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] process_external_request: Updated FIX params for reject response"<<endl;
so_algo_bin_host_events.cpp                TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] process_external_request: Failed to update CL_ORD_ID params for reject response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" "<<endl;
so_algo_bin_host_events.cpp                TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] process_external_request: Updated CL_ORD_ID params for reject response cl_ord_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu"<<endl;
so_algo_bin_host_events.cpp                TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] set m_dl: "<<(void*)dl<<". type="<<typeid(dl).name()<<endl;
so_algo_bin_host_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"]Dispatch SO extraction to service thread"<<endl;
so_algo_bin_host_events.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] Set exec_restatement_reason to REPLACED."<<endl;
so_algo_bin_host_events.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] Set exec_restatement_reason to REPLACE-REJECTED."<<endl;
so_algo_bin_host_events.cpp        TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] so_algo_bin::process_external_request: error="<<ALGOJOB_ERROR_STR[error]<<", state="<<ALGO_STATE_STR[get_state()]<<" ttsdk_error="<<TTSDK_ERROR_STR[ttsdk_error]<<endl;
so_algo_bin_host_events.cpp            TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] process_external_request: Failed to update FIX params for reject response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" IGNORE this warning if FIX is not involved!"<<endl;
so_algo_bin_host_events.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] process_external_request: Updated FIX params for reject response"<<endl;
so_algo_bin_host_events.cpp            TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] process_external_request: Failed to update CL_ORD_ID params for reject response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" "<<endl;
so_algo_bin_host_events.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] process_external_request: Updated CL_ORD_ID params for reject response cl_ord_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu"<<endl;
so_algo_bin_host_events.cpp        TTLOG(WARNING,13)<<"[algo:"<<inst_id<<"] process_external_request: Failed to promote FIX params for accept response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" IGNORE this warning if FIX is not involved!"<<endl;
so_algo_bin_host_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id<<"] process_external_request: Promoted FIX params for accept response"<<endl;
so_algo_bin_host_events.cpp        TTLOG(WARNING,13)<<"[algo:"<<inst_id<<"] process_external_request: Failed to promote CL_ORD_ID params for accept response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" "<<endl;
so_algo_bin_host_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id<<"] process_external_request: Promoted CL_ORD_ID params for accept response cl_ord_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu"<<endl;
so_algo_bin_host_events.cpp        TTLOG(ERROR,13)<<" [algo:"<<inst_id()<<"] Failed to update OMA Parent ID: request is missing ID"<<endl;
so_algo_bin_host_events.cpp    TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"] Updated OMA Parent ID on request: request=algojob__request_set_oma_parent_id new_oma_parent_id="<<oma_parent_uuid_string<<endl;
so_algo_bin_host_events.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] Failed update review_status and review_user_id"<<endl;
so_algo_bin_host_events.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] Updated review/approve parameters on request: request=algojob__request_review_approve_via_update review_status="<<TTSDK_ReviewStatusToString(review_status)<<" review_user_id="<<review_user_id<<"lu"<<endl;
so_algo_bin_host_events.cpp    TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"] Cleared OMA Parent ID on request: request=algojob__request_clear_oma_parent_id"<<endl;
so_algo_bin_host_events.cpp                TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] SO can not handle update_current_user"<<endl;
so_algo_bin_host_events.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] process_request="<<ALGOJOB_REQUEST_ID_STR[request_id]<<", current_state="<<ALGO_STATE_STR[algo_state]<<" active_user_param_count="<<active_params.count<<" request_user_param_count="<<request_params?std::to_string(request_params->count):"N/A"<<" resultant_user_param_count="<<resultant_params.count<<" "<<endl;
so_algo_bin_host_events.cpp                TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: request_params was a nullptr"<<endl;
so_algo_bin_host_events.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: Attempting to update so_algo_bin and SO's params with: obp_state="<<OrderPassToString(obp_state)<<" current_group_id="<<current_group_id<<"lu pass_to_group_id="<<pass_to_group_id<<"lu previous_pass_to_group_id="<<previous_pass_to_group_id<<"lu original_group_id="<<original_group_id<<"lu"<<endl;
so_algo_bin_host_events.cpp                TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: Not allowed in current state="<<ALGO_STATE_STR[algo_state_before_action]<<endl;
so_algo_bin_host_events.cpp                TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: Missing OBP state!"<<endl;
so_algo_bin_host_events.cpp                    TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: Missing current_group_id for OBP state="<<OrderPassToString(obp_state)<<"!"<<endl;
so_algo_bin_host_events.cpp                    TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: Missing AlgoInstMgr for OBP state="<<OrderPassToString(obp_state)<<"!"<<endl;
so_algo_bin_host_events.cpp                    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: SO does not implement [on_update_obp_params]"<<endl;
so_algo_bin_host_events.cpp                TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: Set current and future child orders with "<<GroupIDsToString(group_ids)<<endl;
so_algo_bin_host_events.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: Success!"<<endl;
so_algo_bin_host_events.cpp                TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] dl()->on_pause_algo: error="<<TTSDK_ERROR_STR[error]<<endl;
so_algo_bin_host_events.cpp                    TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"] dl()->on_stop_algo: error="<<TTSDK_ERROR_STR[error]<<endl;
so_algo_bin_host_events.cpp                    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] algojob__request_review_approve_via_update: SO does not implement [on_update_review_approve_params]"<<endl;
so_algo_bin_host_events.cpp        TTLOG(ERROR,13)<<" [algo:"<<inst_id()<<"] process_request "<<ALGOJOB_REQUEST_ID_STR[request_id]<<" error="<<TTSDK_ERROR_STR[error]<<endl;
so_algo_bin_host_events.cpp            TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"] OnRecoverAlgo not implemented, failing recovery"<<endl;
so_algo_bin_host_events.cpp                TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] process_extraction_complete_event: This is a special resume->cancel request to resume first and then cancel immediately afterwards"<<endl;
so_algo_bin_host_events.cpp            TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"] OnResumeAlgo not implemented, failing resuming process"<<endl;
so_algo_bin_host_events.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] Unrecognized instr_extract_reason!"<<endl;
so_algo_bin_host_events.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] process_extraction_complete_event: error="<<TTSDK_ERROR_STR[error]<<endl;
so_algo_bin_host_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] Always skip price deviation calc for TT_STOP"<<endl;
so_algo_bin_host_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] OnStartAlgo successful and now awaiting price sub callback - suppressing send_status to avoid sending duplicate 'starting' state back to TTW: "<<endl;
so_algo_bin_host_events.cpp    TTLOG(ERROR,13)<<"ProcessExtractionFailedEvent: failure="<<ALGO_REQ_FAILURE_CODE_STR[failure]<<endl;
so_algo_bin_host_events.cpp        TTLOG(ERROR,13)<<"ProcessExtractionFailedEvent: recovering algo="<<ALGO_REQ_FAILURE_CODE_STR[failure]<<" destroy algo_bin"<<endl;
so_algo_bin_host_events.cpp    TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"]process_inst_event calling on_scheduled_event order_id="<<order_id_str<<" user_data_addr="<<&m_so_user_data<<endl;
so_algo_bin_host_events.cpp        TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"]process_pause_finished_event pause_result="<<data->action_status?"success":"failed"<<", user_data_addr="<<&m_so_user_data<<endl;
so_algo_bin_host_events.cpp                TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] process_pause_finished_event: Failed to update FIX params for reject response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" IGNORE this warning if FIX is not involved!"<<endl;
so_algo_bin_host_events.cpp                TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] process_pause_finished_event: Updated FIX params for reject response"<<endl;
so_algo_bin_host_events.cpp                TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] process_pause_finished_event: Failed to update CL_ORD_ID params for reject response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" "<<endl;
so_algo_bin_host_events.cpp                TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] process_pause_finished_event: Updated CL_ORD_ID params for reject response cl_ord_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu"<<endl;
so_algo_bin_host_events.cpp        TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"]process_cancel_finished_event calling on_destroy_algo cancel_result="<<data->action_status?"success":"failed"<<", user_data_addr="<<&m_so_user_data<<endl;
so_algo_bin_host_events.cpp                TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] process_cancel_finished_event: Failed to update FIX params for reject response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" IGNORE this warning if FIX is not involved!"<<endl;
so_algo_bin_host_events.cpp                TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] process_cancel_finished_event: Updated FIX params for reject response"<<endl;
so_algo_bin_host_events.cpp                TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] process_cancel_finished_event: Failed to update CL_ORD_ID params for reject response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<endl;
so_algo_bin_host_events.cpp                TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] process_cancel_finished_event: Updated CL_ORD_ID params for reject response cl_ord_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu"<<endl;
synthetic_server_monitor.cpp    TTLOG(INFO,13)<<"SSM::Observer: start for "<<m_serviceName<<endl;
synthetic_server_monitor.cpp    TTLOG(INFO,13)<<"SSM::Observer: stop for "<<m_serviceName<<endl;
synthetic_server_monitor.cpp    TTLOG(INFO,13)<<"SSM::Observer::OnInstanceAdded: [m_serviceName="<<m_serviceName<<" service_id="<<to_string(serviceId)<<"] status="<<status<<" status_ext="<<tt::messaging::darwin::StatusExt_Name(status_ext).to_std()<<endl;
synthetic_server_monitor.cpp        TTLOG(WARNING,13)<<" SSM::Observer::OnInstanceAdded: [m_serviceName="<<m_serviceName<<" serviceId="<<to_string(serviceId)<<"] no instance_id."<<endl;
synthetic_server_monitor.cpp        TTLOG(INFO,13)<<"SSM::Observer::GetCustomData: service_id="<<to_string(serviceId)<<", custom data not ready"<<endl;
synthetic_server_monitor.cpp        TTLOG(INFO,13)<<"SSM::Observer::GetCustomData: failed to parse custom data for service_id="<<to_string(serviceId)<<endl;
synthetic_server_monitor.cpp    TTLOG(INFO,13)<<"SSM::Observer::OnInstanceRemoved: [m_serviceName="<<m_serviceName<<" service_id="<<to_string(serviceId)<<"] removed."<<endl;
synthetic_server_monitor.cpp        TTLOG(WARNING,13)<<"SSM::Observer::OnInstanceRemoved: [m_serviceName="<<m_serviceName<<" service_id="<<to_string(serviceId)<<"] is not in our map"<<endl;
synthetic_server_monitor.cpp            TTLOG(WARNING,13)<<"SSM::Observer::OnInstanceRemoved: Routing Library cannot find it by exch_order_assoc="<<iter->second<<" "<<endl;
synthetic_server_monitor.cpp    TTLOG(INFO,13)<<"SSM::Observer::OnInstanceModified: [m_serviceName="<<m_serviceName<<" service_id="<<to_string(serviceId)<<"] status="<<status<<" status_ext="<<tt::messaging::darwin::StatusExt_Name(status_ext).to_std()<<endl;
synthetic_server_monitor.cpp        TTLOG(WARNING,13)<<" SSM::Observer::OnInstanceModified: "<<m_serviceName<<"["<<to_string(serviceId)<<"] updated. no instance_id"<<endl;
synthetic_server_monitor.cpp            TTLOG(WARNING,13)<<" SSM::Observer: markets is empty. skip adding to RL. m_lbmTopicPrefix="<<m_lbmTopicPrefix<<" instanceId="<<instanceId<<" m_serviceName="<<m_serviceName<<" serviceId="<<to_string(serviceId)<<" "<<endl;
synthetic_server_monitor.cpp            TTLOG(INFO,13)<<"SSM::Observer: Add ["<<m_lbmTopicPrefix<<"."<<instanceId<<"] to Routing Library!"<<endl;
synthetic_server_monitor.cpp            TTLOG(ERROR,13)<<" SSM::Observer: Failed to add ["<<m_lbmTopicPrefix<<"."<<instanceId<<"] to Routing Library with status="<<(m_synthServerMonitor.GetRoutingLibraryStatus())?"RLup":"RLdown"<<endl;
synthetic_server_monitor.cpp        TTLOG(INFO,13)<<"SSM: Failed to create server for topic="<<m_lbmTopicPrefix<<"."<<instanceId<<", error="<<e.what()<<endl;
synthetic_server_monitor.cpp    TTLOG(INFO,13)<<"SSM: Start client_id="<<client_id<<", client_secret="<<Elide(client_secret<<", ttid="<<4)<<", risk="<<ttid_url<<", riskws="<<risk_url<<", ssl="<<risk_ws_url<<", allow_aggregator="<<ssl_ca_path<<endl;
synthetic_server_monitor.cpp                                       TTLOG(INFO,13)<<"SSM: Connection up"<<endl;
synthetic_server_monitor.cpp                                       TTLOG(INFO,13)<<"SSM: Connection down"<<endl;
synthetic_server_monitor.cpp    TTLOG(INFO,13)<<"SSM: HandleSyntheticRouterConnectionUp"<<endl;
synthetic_server_monitor.cpp    TTLOG(WARNING,13)<<"SSM: HandleSyntheticRouterConnectionDown"<<endl;
synthetic_server_monitor.cpp    TTLOG(INFO,13)<<"SSM: AddSyntheticServer server_type="<<serverType<<" exch_order_assoc="<<exchAssocId<<" mktsize="<<markets.size()<<" status_ext="<<tt::messaging::darwin::StatusExt_Name(status_ext).to_std()<<" user_data="<<userData.get()<<". RL status="<<m_routingLibraryStatus?"up":"down(RLwillqueue)"<<endl;
algojob_thread_context.cpp    TTLOG(INFO,13)<<""<<m_name<<" thread pending add algo "<<algo->inst_id()<<endl;
algojob_thread_context.cpp    TTLOG(INFO,13)<<""<<m_name<<" thread pending remove algo "<<inst_id<<endl;
algojob_thread_context.cpp    TTLOG(INFO,13)<<"********** Enter "<<m_name<<" thread. thrd_id=0x"<<std::this_thread::get_id()<<" **********"<<endl;
algojob_thread_context.cpp                        TTLOG(INFO,13)<<"[algo: "<<kvp.second->inst_id()<<"] execute high priority event "<<ALGO_EVENT_TYPE_STR[e]<<endl;
algojob_thread_context.cpp                            TTLOG(ERROR,13)<<" [algo: "<<kvp.second->inst_id()<<"] execute "<<ALGO_EVENT_TYPE_STR[(unsignedint)event->event_type]<<" caught exception. "<<what?what:""<<endl;
algojob_thread_context.cpp                            TTLOG(ERROR,13)<<" [algo: "<<kvp.second->inst_id()<<"] execute "<<ALGO_EVENT_TYPE_STR[(unsignedint)event->event_type]<<" caught unknown exception."<<endl;
algojob_thread_context.cpp                            TTLOG(ERROR,13)<<" [algo: "<<kvp.second->inst_id()<<"] execute "<<event->event_type<<" caught exception. "<<what?what:""<<endl;
algojob_thread_context.cpp                            TTLOG(ERROR,13)<<"[algo: "<<kvp.second->inst_id()<<"] execute "<<event->event_type<<" caught unknown exception."<<endl;
algojob_thread_context.cpp                TTLOG(INFO,13)<<""<<m_name<<" thread loop_count="<<m_loop_count<<"lu, loop_time="<<m_loop_time<<"lu, process_time="<<m_process_time<<"lu, average ratio="<<m_ratio/m_loop_count<<"f"<<endl;
algojob_thread_context.cpp            TTLOG(INFO,13)<<""<<m_name<<" thread add algo["<<algo->inst_id()<<"]"<<endl;
algojob_thread_context.cpp            TTLOG(INFO,13)<<""<<m_name<<" thread remove algo["<<inst_id<<"]"<<endl;
algojob_thread_context.cpp                TTLOG(INFO,13)<<"---------- algo["<<inst_id<<"] removed from "<<m_name<<", ref_count="<<(unsignedlonglong)algo.use_count()<<"lu ----------"<<endl;
algojob_thread_context.cpp    TTLOG(DEBUG,13)<<"Thread "<<m_name<<" (thrd_id=0x"<<std::this_thread::get_id()<<") is exiting with m_pendginAddAlgo.size()="<<m_pendingAddAlgo.size()<<"u m_pendingRemoveAlgo.size()="<<m_pendingRemoveAlgo.size()<<"u"<<endl;
algojob_thread_context.cpp        TTLOG(INFO,13)<<"---------- algo["<<kvp.second->inst_id()<<"]: saving state to disk for recovery ---------- "<<endl;
algojob_thread_context.cpp        TTLOG(INFO,13)<<"algo["<<kvp.second->inst_id()<<"] has m_high_priority_event_buffer.size()="<<m_high_priority_event_buffer[kvp.first].size()<<"u m_event_buffer.size()="<<m_event_buffer[kvp.first].size()<<"u"<<endl;
algojob_thread_context.cpp    TTLOG(INFO,13)<<"********** Exit "<<m_name<<" thread. thrd_id=0x"<<std::this_thread::get_id()<<" **********"<<endl;
algojob_thread_context.cpp    TTLOG(INFO,13)<<""<<m_name<<" thread pending add algo "<<algo->inst_id()<<endl;
so_algo_bin_service_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] download_instr: instr_id="<<instrId<<"lu extract_reason="<<event->extract_reason<<endl;
so_algo_bin_service_events.cpp        TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] download_instr: Can not find order instrument id"<<endl;
so_algo_bin_service_events.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] download_instr: instr_id="<<instrId<<"lu extract_reason="<<event->extract_reason<<", retry="<<retry<<", retry_delay="<<retry_delay<<" (msec)"<<endl;
so_algo_bin_service_events.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] download_instr: failed instr_id="<<instrId<<"lu error="<<tt::sdk::internal::to_string(result_code)<<endl;
so_algo_bin_service_events.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] extract_instr: instr_id="<<instr_id<<"lu algo_type=["<<TTSDK_ALGO_TYPE_STR[event->algo_type]<<"] algo_verion=["<<version<<"] extract_reason="<<event->extract_reason<<endl;
so_algo_bin_service_events.cpp            TTLOG(INFO,13)<<"Loading pre-configured local so, algo_instr_id="<<instr_id<<"lu, bin="<<local_so_path<<endl;
so_algo_bin_service_events.cpp            TTLOG(INFO,13)<<"Loading local so, algo_instr_id="<<instr_id<<"lu, bin="<<local_so_path<<endl;
so_algo_bin_service_events.cpp            TTLOG(INFO,13)<<"Downloading resource="<<algo_uuid_string<<endl;
so_algo_bin_service_events.cpp                TTLOG(ERROR,13)<<"Failed to download resource="<<algo_uuid_string<<" error="<<tt::sdk::internal::to_string(error)<<endl;
so_algo_bin_service_events.cpp                TTLOG(ERROR,13)<<"Failed to extract resource"<<endl;
so_algo_bin_service_events.cpp        TTLOG(ERROR,13)<<"ExtractInstr failed: "<<ALGO_REQ_FAILURE_CODE_STR[failure]<<endl;
so_algo_bin_service_events.cpp        TTLOG(ERROR,13)<<"failed to load shared object: "<<ALGO_REQ_FAILURE_CODE_STR[failure]<<endl;
so_algo_bin_service_events.cpp        TTLOG(ERROR,13)<<"Failed to dlopen shared object: "<<dlerror()<<endl;
so_algo_bin_service_events.cpp        TTLOG(INFO,13)<<"dlopen so_handle: instr_id="<<instr_id<<"lu, so_file_path="<<so_file_path<<endl;
so_algo_bin_service_events.cpp        TTLOG(ERROR,13)<<"Missing version from shared object"<<endl;
so_algo_bin_service_events.cpp        TTLOG(WARNING,13)<<" warning_msg=TTSDK_VERSION_mismatch! file="<<so_file_path<<" server_version="<<server_version<<" user_version="<<user_version<<" "<<endl;
so_algo_bin_service_events.cpp        TTLOG(INFO,13)<<"file="<<so_file_path<<" server_version="<<server_version<<" user_version="<<user_version<<" "<<endl;
so_algo_bin_service_events.cpp        TTLOG(ERROR,13)<<"Missing exports from shared object"<<endl;
algo_bin_impl.cpp    TTLOG(INFO,13)<<"Create algo_dl: instr_id="<<instr_id<<"lu version="<<version<<" user_id="<<user_id<<"lu algo_compliance_id="<<algo_compliance_id<<"lu"<<endl;
algo_bin_impl.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] algo_bin_impl: Failed! class_1_2_fields_size="<<data->request->class_1_2_fields_size<<"u"<<endl;
algo_bin_impl.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] algo_bin_impl: originating_user_id="<<m_algo_bin.m_originating_user_id<<"lu class_1_2_fields_size="<<data->request->class_1_2_fields_size<<"u ["<<m_class_1_2_fields->ShortDebugString().to_std()<<"]"<<endl;
algo_bin_impl.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] algo_bin_impl: originating_user_id="<<m_algo_bin.m_originating_user_id<<"lu (set from user_id) class_1_2_fields_size="<<data->request->class_1_2_fields_size<<"u ["<<m_class_1_2_fields->ShortDebugString().to_std()<<"]"<<endl;
algo_bin_impl.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] algo_bin_impl: Destroyed. this="<<this<<" algo_mgr="<<m_algo_inst_mgr.get()<<" dl="<<m_dl<<endl;
algo_bin_impl.cpp    TTLOG(INFO,13)<<"add_algo_dl["<<dl.get()<<"]: instr_id="<<instr_id<<"lu version="<<version<<" user_id="<<user_id<<"lu is_adl="<<is_adl<<endl;
algo_bin_impl.cpp        TTLOG(INFO,13)<<"ref_algo_dl["<<itr->second.get()<<"]: ref_count="<<itr->second->ref_count.load(std::memory_order_relaxed)<<"lu instr_id="<<instr_id<<"lu version="<<version<<" user_id="<<user_id<<"lu is_adl="<<is_adl<<endl;
algo_bin_impl.cpp    TTLOG(INFO,13)<<"ref_algo_dl: not found. instr_id="<<instr_id<<"lu version="<<version<<" user_id="<<user_id<<"lu is_adl="<<is_adl<<endl;
algo_bin_impl.cpp        TTLOG(INFO,13)<<"unref_algo_dl["<<dl<<"]: ref_count="<<dl->ref_count.load(std::memory_order_relaxed)<<"lu instr_id="<<dl->instr_id<<"lu version="<<dl->version<<" user_id="<<dl->user_id<<"lu is_adl="<<dl->is_adl<<endl;
algo_bin_impl.cpp        TTLOG(WARNING,13)<<"unref_algo_dl["<<dl<<"]: not found. instr_id="<<dl->instr_id<<"lu version="<<dl->version<<" user_id="<<dl->user_id<<"lu is_adl="<<dl->is_adl<<endl;
algo_bin_impl.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] set pending request=["<<ALGOJOB_REQUEST_ID_STR[m_pending_request.request_id]<<"] user_request_id="<<m_pending_request.user_request_id<<"lu"<<endl;
algo_bin_impl.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] clean pending request=["<<ALGOJOB_REQUEST_ID_STR[m_pending_request.request_id]<<"] user_request_id="<<m_pending_request.user_request_id<<"lu"<<endl;
algo_bin_impl.cpp            TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"]: check_class_2_fields: request=["<<ALGOJOB_REQUEST_ID_STR[request->id]<<"], Failed! class_2_size="<<data->request->class_1_2_fields_size<<"u"<<endl;
algo_bin_impl.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"]: check_class_2_fields: request=["<<ALGOJOB_REQUEST_ID_STR[request->id]<<"], class_2_size="<<data->request->class_1_2_fields_size<<"u tmp="<<tmp->ShortDebugString().to_std()<<" m_class_1_2_fields="<<m_class_1_2_fields->class_2().ShortDebugString().to_std()<<endl;
algojob_0.cpp        TTLOG(WARNING,13)<<"Delay starting Job0 delay="<<delay<<endl;
algojob_0.cpp        TTLOG(ERROR,13)<<"Failed to initialize communication between Jobs"<<endl;
algojob_0.cpp        TTLOG(ERROR,13)<<"Failed to start SSM"<<endl;
algojob_0.cpp            TTLOG(INFO,13)<<"IPC0: Remove job_connection="<<(void*)job_connection<<", socket="<<job_connection->socket<<" from s_job0_epoll_file, error="<<ALGOUTIL_ERROR_STR[error]<<endl;
algojob_0.cpp            TTLOG(ERROR,13)<<"Exception while stopping ZooKeeperClient. error="<<ex.what()<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"ConfigXml: data_center_name="<<data_center_name<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"ConfigXml: client_id="<<client_id<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"ConfigXml: client_secret="<<Elide(client_secret<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"ConfigXml: ttid_url="<<ttid_url<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"ConfigXml: admin_url="<<admin_url<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"ConfigXml: risk_url="<<risk_url<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"ConfigXml: risk_ws_url="<<risk_ws_url<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"ConfigXml: ssl_ca_path="<<ssl_ca_path<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"ConfigXml: allow_aggregator="<<allow_aggregator<<endl;
algojob_0.cpp        TTLOG(ERROR,13)<<"Exception starting SSM: error="<<error<<endl;
algojob_0.cpp        TTLOG(ERROR,13)<<"Exception starting SSM: error="<<ex.what()<<endl;
algojob_0.cpp    TTLOG(INFO,13)<<"IPC0: gonna hangup job_connection.socket="<<socket<<endl;
algojob_0.cpp    TTLOG(INFO,13)<<"IPC0: Remove job_connection socket="<<socket<<" from s_job0_epoll_file, error="<<ALGOUTIL_ERROR_STR[error]<<endl;
algojob_0.cpp    TTLOG(INFO,13)<<"IPC0: Removed job_connection="<<(void*)job_connection<<". s_connections.size="<<s_connections.size()<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"IPC0: CleanupJobConnection: job_connection="<<(void*)job_connection<<" not found"<<endl;
algojob_0.cpp        TTLOG(ERROR,13)<<"IPC0: HandleHangup: epoll_data is null"<<endl;
algojob_0.cpp    TTLOG(INFO,13)<<"IPC0: receive Hangup"<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"IPC0: s_job0_ipc_server.listen_socket="<<s_job0_ipc_server.listen_socket);}else{//Thisisanon-safepointer.Thispointershouldnotbedereferenceduntil//itisverifiedthatitisstillvalid.constautojob_connection=static_cast<algoutil__ipc_connection*>(epoll_data<<" hangup"<<endl;
algojob_0.cpp    TTLOG(INFO,13)<<"IPC0: HandleJobConnecting"<<endl;
algojob_0.cpp    TTLOG(INFO,13)<<"IPC0: Add job_connection.socket="<<job_connection->socket<<" to s_job0_epoll_file, error="<<ALGOUTIL_ERROR_STR[error]<<endl;
algojob_0.cpp    TTLOG(INFO,13)<<"IPC0: Added job_connection="<<(void*)job_connection<<". s_connections.size="<<s_connections.size()<<endl;
algojob_0.cpp    TTLOG(INFO,13)<<"IPC0: JobQuestionReceiverThread starting......"<<endl;
algojob_0.cpp            TTLOG(ERROR,13)<<"IPC0: epoll_wait received signal_count==-1"<<endl;
algojob_0.cpp                    TTLOG(INFO,13)<<"IPC0: JobQuestionReceiverThread::AlgoUtil_RecvMessage: job_connection="<<(void*)job_connection<<" not found"<<endl;
algojob_0.cpp                    TTLOG(ERROR,13)<<"IPC0: AlgoUtil_RecvMessage error="<<ALGOUTIL_ERROR_STR[err]<<endl;
algojob_0.cpp                TTLOG(INFO,13)<<"IPC0: Socket became invalid ...., So new scoket has been created."<<endl;
algojob_0.cpp                    TTLOG(ERROR,13)<<"IPC0: Failed to add listen_socket="<<s_job0_ipc_server.listen_socket<<" to s_job0_epoll_file error="<<ALGOUTIL_ERROR_STR[epoll_error]<<" errno="<<errno<<endl;
algojob_0.cpp                    TTLOG(INFO,13)<<"IPC0: listen_socket="<<s_job0_ipc_server.listen_socket<<" added to s_job0_epoll_file"<<endl;
algojob_0.cpp    TTLOG(INFO,13)<<"IPC0: JobQuestionReceiverThread stopping......"<<endl;
algojob_0.cpp    TTLOG(INFO,13)<<"IPC0: Init IPC Server: address=job0.ipc"<<endl;
algojob_0.cpp        TTLOG(ERROR,13)<<"IPC0: Failed to init JOB0 IPC Server:"<<job0_ipc_address<<", error="<<ALGOUTIL_ERROR_STR[error]<<" errno="<<sys_err_no<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"IPC0: Created IPC Server: listen_socket="<<s_job0_ipc_server.listen_socket<<", listen_name="<<s_job0_ipc_server.listen_name<<endl;
algojob_0.cpp        TTLOG(ERROR,13)<<"IPC0: Failed to epoll_create s_job0_epoll_file"<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"IPC0: epoll_create s_job0_epoll_file="<<s_job0_epoll_file<<endl;
algojob_0.cpp        TTLOG(ERROR,13)<<"IPC0: Failed to add listen_socket="<<s_job0_ipc_server.listen_socket<<" to s_job0_epoll_file error="<<ALGOUTIL_ERROR_STR[error]<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"IPC0: Add listen_socket="<<s_job0_ipc_server.listen_socket<<" to s_job0_epoll_file"<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"QA: routing_library_query, market_id="<<question->data.rl_query.market_id<<" primary_market_id="<<question->data.rl_query.primary_market_id<<" user_id="<<question->data.rl_query.user_id<<"lu acct_company="<<question->data.rl_query.acct_company<<"lu user_company="<<question->data.rl_query.user_company<<"lu And result topic="<<topic<<endl;
algojob_0.cpp                    TTLOG(INFO,13)<<"IPC0: ProcessJobQuestion encountered a job that is no longer valid. job_connection="<<(void*)job_connection<<endl;
algojob_0.cpp            TTLOG(INFO,13)<<"QA: reply to question_id="<<answer.question.question_id<<"lu job_id="<<answer.question.job_id<<"lu user_id="<<answer.question.user_id<<"lu, error="<<ALGOUTIL_ERROR_STR[error]<<endl;
algojob_0.cpp        TTLOG(ERROR,13)<<"ProcessJobQuestion Unknown type="<<question->type<<endl;
algojob_0.cpp                                        TTLOG(INFO,13)<<"IPC0: NotifySyntheticServer encountered a job that is no longer valid. job_connection="<<(void*)job_connection<<", topic="<<topic.c_str()<<endl;
algojob_0.cpp                                TTLOG(INFO,13)<<"Send to job socket="<<job_connection->socket<<" topic="<<topic<<" error="<<ALGOUTIL_ERROR_STR[error]<<endl;
algojob_0.cpp        TTLOG(WARNING,13)<<"Invalid parameter was passed to AlgoUtil_ValidateListenSocket."<<endl;
algojob_0.cpp        TTLOG(INFO,13)<<"IPC0: re-initialize IPC Server: address=job0.ipc"<<endl;
algojob_0.cpp            TTLOG(ERROR,13)<<"IPC0: Failed to re-initialize JOB0 IPC Server:"<<listen_address.c_str()<<", error="<<ALGOUTIL_ERROR_STR[ipc_error]<<" errno="<<sys_err_no<<endl;
algo_bin.cpp    TTLOG(INFO,13)<<"[algo:"<<m_inst_id<<"] algo_bin: Destroyed. this="<<this<<" stats=["<<report_statistics()<<"]"<<endl;
algo_bin.cpp    TTLOG(ERROR,13)<<"[algo:"<<m_inst_id<<"] fail_algo_on_exception. reason="<<reason<<endl;
algo_bin.cpp        TTLOG(INFO,13)<<"[algo:"<<m_inst_id<<"] faile algo, impl is not created. algo will be removed."<<endl;
algo_bin.cpp                        TTLOG(INFO,13)<<"[algo:"<<m_inst_id<<"] user_id="<<m_user_id<<"lu event="<<request_id==algojob__request_pause?"pause":"cancel"<<" flushed_events="<<flushed<<"u (thread_context_events.size="<<thread_context_events.size()<<"u algo_bin_events.size="<<algo_bin_events.size()<<"u)"<<endl;
algo_bin.cpp                            TTLOG(ERROR,13)<<"[algo:"<<m_inst_id<<"] user_id="<<m_user_id<<"lu event="<<request_id==algojob__request_pause?"pause":"cancel"<<". Too many flushed_events or algo failed previously on queue limit violation flushed_events="<<flushed<<"u and failing algo"<<endl;
algo_bin.cpp                            TTLOG(INFO,13)<<"[algo:"<<m_inst_id<<"] user_id="<<m_user_id<<"lu event="<<request_id==algojob__request_pause?"pause":"cancel"<<". Executing flushed_events="<<flushed<<"u"<<endl;
algo_bin.cpp                                TTLOG(INFO,13)<<"[algo:"<<m_inst_id<<"] user_id="<<m_user_id<<"lu event="<<request_id==algojob__request_pause?"pause":"cancel"<<". Executed flushed_events="<<flushed<<"u"<<endl;
algo_bin.cpp        TTLOG(INFO,13)<<"[algo:"<<m_inst_id<<"] "<<str<<endl;
algo_bin.cpp                    TTLOG(WARNING,13)<<"[algo:"<<m_inst_id<<"] process_job_request_on_algo_thread: Failed to update FIX params for reject response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" IGNORE this warning if FIX is not involved!"<<endl;
algo_bin.cpp                    TTLOG(INFO,13)<<"[algo:"<<m_inst_id<<"] process_job_request_on_algo_thread: Updated FIX params for reject response"<<endl;
algo_bin.cpp                    TTLOG(WARNING,13)<<"[algo:"<<m_inst_id<<"] process_job_request_on_algo_thread: Failed to update CL_ORD_ID params for reject response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" "<<endl;
algo_bin.cpp                    TTLOG(INFO,13)<<"[algo:"<<m_inst_id<<"] process_job_request_on_algo_thread: Updated CL_ORD_ID params for reject response cl_ord_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu"<<endl;
algo_bin.cpp                TTLOG(ERROR,13)<<"[algo:"<<m_inst_id<<"]Reject stale New order: request=["<<ALGOJOB_REQUEST_ID_STR[request_id]<<"], user_request_id="<<request->user_request_id<<", timeSent="<<timeSent<<"lu, timeRecd="<<timeRecd<<"lu delay_ms="<<delay_ms<<"lu, threshold_ms="<<threshold_ms<<"lu"<<endl;
algo_bin.cpp        TTLOG(ERROR,13)<<" internal_process_job_request: m_impl is null request=["<<ALGOJOB_REQUEST_ID_STR[request_id]<<"], user_id="<<request->user_id<<"lu "<<endl;
algo_bin.cpp    TTLOG(INFO,13)<<"[algo:"<<m_inst_id<<"] algo_bin is being deactivated. this="<<this<<" active="<<(bool)m_active<<" impl="<<m_impl.get()<<endl;
server_connection.cpp        TTLOG(WARNING,13)<<"Failed to connect to "<<address<<", job_id="<<job_id<<", system errno="<<sys_errno<<endl;
server_connection.cpp        TTLOG(INFO,13)<<"Connected to "<<address<<", job_id="<<job_id<<", m_pConnection="<<m_pConnection<<", m_pConnection->socket="<<m_pConnection->socket<<endl;
server_connection.cpp        TTLOG(ERROR,13)<<"Failed to send connect response to algo server "<<address<<". job_id="<<job_id<<endl;
server_connection.cpp        TTLOG(ERROR,13)<<" Error receiving server messages, job_id="<<m_job_id<<", algoutil_error="<<ALGOUTIL_ERROR_STR[error]<<", recvd_size="<<recvd_size<<"u, compressed_recvd_size="<<compressed_recvd_data_size<<"u errno="<<strerror(errno)<<endl;
server_connection.cpp    TTLOG(INFO,13)<<"Recevied AlgoServer Message: request=["<<ALGOJOB_REQUEST_ID_STR[request->id]<<"] recvd_size="<<recvd_size<<"u compressed_recvd_size="<<compressed_recvd_data_size<<"u latency_us="<<latency_us<<"u"<<endl;
server_connection.cpp        TTLOG(ERROR,13)<<"AlgoUtil_RecvMessage error. error="<<ALGOUTIL_ERROR_STR[error]<<endl;
server_connection.cpp        TTLOG(WARNING,13)<<"No algoserver connection. Drop message type="<<type<<endl;
server_connection.cpp        TTLOG(ERROR,13)<<"Failure sending "<<std::move(type)<<" ["<<ALGOUTIL_ERROR_STR[error]<<"], ["<<strerror(errno)<<"]"<<endl;
server_connection.cpp    TTLOG(INFO,13)<<" server_connection::send_loopback_order_request() sending size="<<payload_size<<endl;
server_connection.cpp        TTLOG(ERROR,13)<<"Deserialization error. recvd_size_result="<<*recvd_size_result<<"u cb="<<cb<<"u"<<endl;
adl_algo_bin_host_events.cpp    TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"]: process_external_request=["<<ALGOJOB_REQUEST_ID_STR[request->id]<<"], state="<<ALGO_STATE_STR[state]<<endl;
adl_algo_bin_host_events.cpp                TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"]: ADL Recovery is not supported - setting algo_state to [failed] and cleaning up child orders"<<endl;
adl_algo_bin_host_events.cpp                TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] Request is missing algo version."<<endl;
adl_algo_bin_host_events.cpp            TTLOG(DEBUG,13)<<"[algo:"<<inst_id()<<"] EPIQ_flag="<<epiqFlag<<endl;
adl_algo_bin_host_events.cpp                TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] Algo has no Export Value. Ignore reuqest="<<ALGOJOB_REQUEST_ID_STR[request->id]<<endl;
adl_algo_bin_host_events.cpp                TTLOG(DEBUG,13)<<"Algo has no Export Value. Ignore reuqest="<<ALGOJOB_REQUEST_ID_STR[request->id]<<endl;
adl_algo_bin_host_events.cpp            TTLOG(DEBUG,13)<<"[algo:"<<inst_id()<<"] Detected server disconnect but will ignore it!"<<endl;
adl_algo_bin_host_events.cpp            TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"] Updated OMA Parent ID on request: request="<<ALGOJOB_REQUEST_ID_STR[request->id]<<" new_oma_parent_id="<<oma_parent_uuid_string<<endl;
adl_algo_bin_host_events.cpp            TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"] Cleared OMA Parent ID on request: request="<<ALGOJOB_REQUEST_ID_STR[request->id]<<endl;
adl_algo_bin_host_events.cpp                TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: request_params was a nullptr"<<endl;
adl_algo_bin_host_events.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: Attempting to update params with: obp_state="<<OrderPassToString(obp_state)<<" current_group_id="<<current_group_id<<"lu pass_to_group_id="<<pass_to_group_id<<"lu previous_pass_to_group_id="<<previous_pass_to_group_id<<"lu original_group_id="<<original_group_id<<"lu"<<endl;
adl_algo_bin_host_events.cpp                TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: Not allowed in current state="<<ALGO_STATE_STR[state]<<endl;
adl_algo_bin_host_events.cpp                TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: Missing OBP state!"<<endl;
adl_algo_bin_host_events.cpp                    TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: Missing current_group_id for OBP state="<<OrderPassToString(obp_state)<<"!"<<endl;
adl_algo_bin_host_events.cpp                    TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: Missing AlgoInstMgr for OBP state="<<OrderPassToString(obp_state)<<"!"<<endl;
adl_algo_bin_host_events.cpp                TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: Set current and future child orders with "<<GroupIDsToString(group_ids)<<endl;
adl_algo_bin_host_events.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] algojob__request_order_pass: Success!"<<endl;
adl_algo_bin_host_events.cpp        TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] action="<<ALGO_ACTION_STR[action]<<" invalid: state="<<ALGO_STATE_STR[m_host_if->get_state()]<<endl;
adl_algo_bin_host_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] queue up action="<<ALGO_ACTION_STR[action]<<". state="<<ALGO_STATE_STR[m_host_if->get_state()]<<endl;
adl_algo_bin_host_events.cpp                 TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] signaler_id="<<event->signaler_id<<"lu is stopped, dropped this event"<<endl;
adl_algo_bin_host_events.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] now process scheduled exit_block_graph m_globalVIndex="<<event->m_globalVIndex<<"lu"<<endl;
adl_algo_bin_host_events.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"]: process_compilation_completed_event: state="<<ALGO_STATE_STR[state]<<" compile_reason="<<instr_compile_reason_to_string(reason)<<endl;
adl_algo_bin_host_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"]: hasAnalytics="<<(dl()->algo_graph.analyticsBlockCount>0)<<" analyticsBlockCount="<<//keepingthebooleanhasAnalyticsforlog-levelcompatibilitydl()->algo_graph.analyticsBlockCount<<endl;
adl_algo_bin_host_events.cpp            TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"]: Analytics Block usage is disabled on the server"<<endl;
adl_algo_bin_host_events.cpp            TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"]: The number of Analytics Blocks in the algo ("<<dl()->algo_graph.analyticsBlockCount<<") exceeds the max allowed on the server ("<<env::instance().max_analytics_blocks()<<")"<<endl;
adl_algo_bin_host_events.cpp        TTLOG(DEBUG,13)<<"[algo:"<<inst_id()<<"]: Creating AlgoInstMgr with "<<GroupIDsToString(group_ids)<<endl;
adl_algo_bin_host_events.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"]: process_compilation_completed_event: Asynchronously download child orders for recovery before continuing."<<endl;
adl_algo_bin_host_events.cpp        TTLOG(ERROR,13)<<""<<error<<endl;
adl_algo_bin_host_events.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"]: create_block_graph_and_init_action: Continue processing compilation completed event: state="<<ALGO_STATE_STR[state]<<" compile_reason="<<instr_compile_reason_to_string(reason)<<endl;
adl_algo_bin_host_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"]: m_has_periodic_task="<<m_has_periodic_task<<" HasExportValue="<<m_inst_if->HasExportValue()<<" hasAlert="<<dl()->algo_graph.hasAlert<<" hasPnL="<<m_algo_inst_mgr->m_hasPnl<<endl;
adl_algo_bin_host_events.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"]: will use account_id="<<accountId<<"lu"<<endl;
adl_algo_bin_host_events.cpp        TTLOG(ERROR,13)<<""<<error<<endl;
adl_algo_bin_host_events.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] process_action_failed_event: current_synth_status="<<TTSDK_SYNTH_STATUS_STR[current_synth_status]<<" next_synth_status="<<TTSDK_SYNTH_STATUS_STR[next_synth_status]<<" current_algo_state="<<ALGO_STATE_STR[current_algo_state]<<" next_algo_state="<<ALGO_STATE_STR[next_algo_state]<<" (note: current and next algo_state are expected to be both algojob__algo_failed) failed_action="<<ALGOJOB_REQUEST_ID_STR[failed_action]<<endl;
adl_algo_bin_host_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] process_action_failed_event: Skipping purge child orders to allow recovery to be retried."<<endl;
adl_algo_bin_host_events.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] process_action_complete_event:action="<<ALGO_ACTION_STR[action]<<" state="<<ALGO_STATE_STR[state]<<","<<endl;
adl_algo_bin_host_events.cpp    TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] request["<<ALGOJOB_REQUEST_ID_STR[request->id]<<"][id:"<<request->user_request_id<<"lu] rejected. state="<<ALGO_STATE_STR[state]<<endl;
adl_algo_bin_host_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] suppress action"<<endl;
adl_algo_bin_host_events.cpp        TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] skip SetSuppressActionFlag. state="<<ALGO_STATE_STR[state]<<endl;
adl_algo_bin_host_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] Saving state to disk."<<endl;
adl_algo_bin_host_events.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] recover_children: Downloading children."<<endl;
adl_algo_bin_host_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] recover_children: Will attempt to delete PR child order (if any) because: is_sse_pr_enabled="<<env::instance().is_sse_pr_enabled()?"true":"false"<<endl;
adl_algo_bin_host_events.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] on_children_recovered: state="<<ALGO_STATE_STR[state]<<" result="<<result?"true":"false"<<" children_count="<<size<<"u"<<endl;
adl_algo_bin_host_events.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] on_children_recovered: Download failed, declaring recovery failure!"<<endl;
adl_algo_bin_host_events.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] on_children_recovered: Download success, printing recovered child order IDs."<<endl;
adl_algo_bin_host_events.cpp            TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] on_children_recovered: Param for a recovered child was unexpectedly a nullptr: index="<<i<<"u"<<endl;
adl_algo_bin_host_events.cpp            TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] on_children_recovered: Order ID missing for a recovered child: index="<<i<<"u"<<endl;
adl_algo_bin_host_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] on_children_recovered: index="<<i<<"u order_id="<<order_id<<endl;
adl_algo_bin.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"]--------- Schedule Destroy adl_algo_bin ---------"<<endl;
adl_algo_bin.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"]========= Destroy adl_algo_bin ========="<<endl;
adl_algo_bin.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] destroy inst_if "<<static_cast<void*>(m_inst_if)<<endl;
adl_algo_bin.cpp            TTLOG(ERROR,13)<<" [algo:"<<inst_id()<<"] destroy adl_algo_bin. state="<<ALGO_STATE_STR[m_state.load(std::memory_order_relaxed)]<<endl;
adl_algo_bin.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] inst_if destroyed"<<endl;
adl_algo_bin.cpp                    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] export_values="<<(int)export_values<<" collect_values="<<(int)collect_values<<" force_collect="<<(int)force_collect<<" bool export value id="<<exportValue->blockAndConnectorId.c_str()<<" name="<<exportValue->name<<" value="<<(int)value.value<<endl;
adl_algo_bin.cpp                        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] has more than "<<TTSDK_PARAM_MAX_COUNT<<" export values"<<endl;
adl_algo_bin.cpp                    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] export_values="<<(int)export_values<<" collect_values="<<(int)collect_values<<" force_collect="<<(int)force_collect<<" INT export value id="<<exportValue->blockAndConnectorId.c_str()<<" name="<<exportValue->name<<" value="<<value.value<<endl;
adl_algo_bin.cpp                        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] has more than "<<TTSDK_PARAM_MAX_COUNT<<" export values"<<endl;
adl_algo_bin.cpp                    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] export_values="<<(int)export_values<<" collect_values="<<(int)collect_values<<" force_collect="<<(int)force_collect<<" REAL export value id="<<exportValue->blockAndConnectorId.c_str()<<" name="<<exportValue->name<<" value="<<(double)value.value<<endl;
adl_algo_bin.cpp                        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] has more than "<<TTSDK_PARAM_MAX_COUNT<<" export values"<<endl;
adl_algo_bin.cpp                        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] has more than "<<TTSDK_PARAM_MAX_COUNT<<" export values"<<endl;
adl_algo_bin.cpp                TTLOG(INFO,13)<<" TryCollectAndSendValues when forceToCollect: export_values_data.count="<<export_values_data.count<<endl;
adl_algo_bin.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] Suppressed sending status"<<endl;
adl_algo_bin.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] Suppressed sending status"<<endl;
adl_algo_bin.cpp    TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] fail_algo_on_exception. reason="<<reason<<" "<<endl;
algojob.cpp    TTLOG(INFO,13)<<"LoopBackToServer: size="<<payload_size<<"u"<<endl;
algojob.cpp        TTLOG(INFO,13)<<"Stop and Join m_job_qa_thread"<<endl;
algojob.cpp        TTLOG(ERROR,13)<<"No Job0 for question type="<<question_copy->type<<endl;
algojob.cpp    TTLOG(INFO,13)<<"Question: question_id="<<question_id<<"lu"<<endl;
algojob.cpp                                                    TTLOG(INFO,13)<<"Question: send to job0 question_id="<<question_copy->question_id<<"lu error="<<ALGOUTIL_ERROR_STR[error]<<endl;
algojob.cpp            TTLOG(ERROR,13)<<"Question: question_id="<<question_id<<"lu timeout"<<endl;
algojob.cpp        TTLOG(ERROR,13)<<"Question: question_id="<<question_id<<"lu has no answer"<<endl;
algojob.cpp    TTLOG(INFO,13)<<"ConfigXml: simulation_mode="<<isSim<<endl;
algojob.cpp    TTLOG(INFO,13)<<"ConfigXml: thread_mode="<<thr_mode<<endl;
algojob.cpp    TTLOG(INFO,13)<<"ConfigXml: thread_pool_count="<<thread_pool_count<<endl;
algojob.cpp    TTLOG(INFO,13)<<"ConfigXml: algo_thread_static_affinities="<<algo_thread_static_affinities<<endl;
algojob.cpp        TTLOG(ERROR,13)<<"Failed to initialize OrderD"<<endl;
algojob.cpp        TTLOG(ERROR,13)<<"Failed to start controller"<<endl;
algojob.cpp    TTLOG(INFO,13)<<"Initializing pricelib"<<endl;
algojob.cpp        TTLOG(ERROR,13)<<"Failed to initialize pricefs lib"<<endl;
algojob.cpp        TTLOG(ERROR,13)<<"Failed to init ADL resource"<<endl;
algojob.cpp    TTLOG(INFO,13)<<"Algojob ("<<is_algoserver_debug?"algoserver_debug":"algoserver_exec"<<") Started. Sleep 2 seconds so JOB0 can connect..."<<endl;
algojob.cpp            TTLOG(WARNING,13)<<"Remove sockect="<<s_job0_connection->socket<<" from s_job0_epoll_file="<<s_job0_epoll_file<<endl;
algojob.cpp        TTLOG(WARNING,13)<<"Closing s_job0_epoll_file="<<s_job0_epoll_file<<endl;
algojob.cpp        TTLOG(WARNING,13)<<"Error loading plugin ["<<info.pluginName<<"]: "<<info.loadError<<endl;
algojob.cpp        TTLOG(ERROR,13)<<" Error(s) loading plugins: "<<error<<"x, num blocks: "<<plugin_loader.blockIfLib.BlockCount()<<endl;
algojob.cpp        TTLOG(ERROR,13)<<"Failed to load standard_blocks."<<endl;
algojob.cpp        TTLOG(ERROR,13)<<"Failed to create precompile_path, err="<<ALGOUTIL_ERROR_STR[algoutil_error]<<endl;
algojob.cpp        TTLOG(INFO,13)<<"successfully create precompile_path="<<precompile_path<<endl;
algojob.cpp        TTLOG(ERROR,13)<<"PrecompileCommon failed. "<<compiler_command<<endl;
algojob.cpp    TTLOG(INFO,13)<<"PrecompileCommon succeed: compiler_command="<<compiler_command<<endl;
algojob.cpp        TTLOG(ERROR,13)<<" Could not delete unifierConfig="<<unifier_config_file<<", error="<<error<<endl;
algojob.cpp    TTLOG(INFO,13)<<"Trying to connect to JOB0"<<endl;
algojob.cpp        TTLOG(WARNING,13)<<"Failed to connect to JOB0 IPC: job0.ipc error="<<ALGOUTIL_ERROR_STR[error]<<", system errno="<<sys_errno<<endl;
algojob.cpp    TTLOG(INFO,13)<<"Connected to JOB0: socket="<<s_job0_connection->socket<<endl;
algojob.cpp        TTLOG(ERROR,13)<<"IPC: Failed to epoll_create s_job0_epoll_file"<<endl;
algojob.cpp    TTLOG(INFO,13)<<"IPC: epoll_create s_job0_epoll_file="<<s_job0_epoll_file<<endl;
algojob.cpp        TTLOG(ERROR,13)<<"IPC: Failed to add socket="<<s_job0_connection->socket<<" to s_job0_epoll_file. error="<<ALGOUTIL_ERROR_STR[error]<<endl;
algojob.cpp        TTLOG(INFO,13)<<"IPC: Add socket="<<s_job0_connection->socket<<" to s_job0_epoll_file"<<endl;
algojob.cpp    TTLOG(INFO,13)<<"IPC: JobAnswerReceiverThread starting......"<<endl;
algojob.cpp                TTLOG(ERROR,13)<<"IPC: epoll_wait received EINVAL(Invalid argument). Reconnect to Job0"<<endl;
algojob.cpp                TTLOG(ERROR,13)<<"IPC: epoll_wait received signal_count==-1 errno="<<errno<<" job zero died?"<<endl;
algojob.cpp                TTLOG(INFO,13)<<"IPC: receive Hangup s_job0_connection="<<s_job0_connection.get()<<" epoll_data="<<epoll_data<<" job zero died?"<<endl;
algojob.cpp                    TTLOG(ERROR,13)<<"IPC: AlgoUtil_RecvMessage error="<<ALGOUTIL_ERROR_STR[err]<<". Closing connection to job zero"<<endl;
algojob.cpp    TTLOG(INFO,13)<<"IPC: JobAnswerReceiverThread stopping......"<<endl;
algojob.cpp        TTLOG(INFO,13)<<"Answer: RL update: topic="<<answer->data.synthetic_server_topic<<endl;
algojob.cpp        TTLOG(INFO,13)<<"Answer: RL query: topic="<<answer->data.synthetic_server_topic<<endl;
algojob.cpp                TTLOG(ERROR,13)<<"Answer: but question_id="<<answer->question.question_id<<"lu not in map!!"<<endl;
algojob.cpp        TTLOG(WARNING,13)<<"Answer: but type unknown"<<endl;
controller.cpp    TTLOG(INFO,13)<<"Start controller...n_threads="<<n_threads<<" cpu_affinities="<<cpu_affinities<<endl;
controller.cpp        TTLOG(ERROR,13)<<"Failed to start periodic timer. "<<err.what()<<endl;
controller.cpp        TTLOG(INFO,13)<<"Stop algojob threads"<<endl;
controller.cpp        TTLOG(INFO,13)<<"Join algojob threads"<<endl;
controller.cpp            TTLOG(INFO,13)<<" create new algo_bin with inst_id="<<inst_id<<" user_id="<<request->user_id<<"lu request_id="<<ALGOJOB_REQUEST_ID_STR[request->id]<<" total m_algos.size()="<<m_algos.size()<<" on reserved algo thread"<<endl;
controller.cpp            TTLOG(INFO,13)<<" create new algo_bin with inst_id="<<inst_id<<" user_id="<<request->user_id<<"lu request_id="<<ALGOJOB_REQUEST_ID_STR[request->id]<<" total m_algos.size()="<<m_algos.size()<<", job_thread_index="<<job_thread_index<<endl;
controller.cpp    TTLOG(ERROR,13)<<"create_algo unexpectedly found existing inst_id="<<inst_id<<" user_id="<<request->user_id<<"lu request_id="<<ALGOJOB_REQUEST_ID_STR[request->id]<<"! Sending request-failure back to server!"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"search_algo can NOT find inst_id="<<inst_id<<" user_id="<<request->user_id<<"lu request_id="<<ALGOJOB_REQUEST_ID_STR[request->id]<<" "<<endl;
controller.cpp    TTLOG(INFO,13)<<" Parsing reserved users "<<reserved_users<<endl;
controller.cpp        TTLOG(INFO,13)<<" Add reserved user "<<user_id<<endl;
request_receiver.cpp        TTLOG(ERROR,13)<<"epoll_create failed. err: "<<strerror(errno)<<endl;
request_receiver.cpp    TTLOG(INFO,13)<<"epoll_create m_epoll_file="<<m_epoll_file<<endl;
request_receiver.cpp        TTLOG(ERROR,13)<<"failed to set epoll file "<<ALGOUTIL_ERROR_STR[algoutil_error]<<endl;
request_receiver.cpp                TTLOG(INFO,13)<<"Re-connected to algoserver"<<endl;
request_receiver.cpp                    TTLOG(ERROR,13)<<"Failed to connect to algoserver for 2 hours"<<endl;
request_receiver.cpp                    TTLOG(ERROR,13)<<"epoll_wait failure: m_epoll_file="<<m_epoll_file<<" errno="<<strerror(errno)<<endl;
request_receiver.cpp             TTLOG(INFO,13)<<err.what()<<endl;
request_receiver.cpp    TTLOG(INFO,13)<<"request: "<<request->id<<endl;
request_receiver.cpp            TTLOG(INFO,13)<<"update token: user_id="<<request->user_id<<"lu, token="<<request->data.toke<<" ......"<<endl;
request_receiver.cpp            TTLOG(INFO,13)<<"saved token to env: user_id="<<request->user_id<<"lu, token="<<saved_toke<<" ......"<<endl;
request_receiver.cpp            TTLOG(INFO,13)<<"update user: "<<request->user_id<<"lu"<<endl;
request_receiver.cpp            TTLOG(ERROR,13)<<"Should not have received this request->id="<<ALGOJOB_REQUEST_ID_STR[request->id]<<endl;
request_receiver.cpp                    TTLOG(WARNING,13)<<"[algo:"<<inst_id<<"] receive_algojob_request: Failed to update FIX params for reject response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" IGNORE this warning if FIX is not involved!"<<endl;
request_receiver.cpp                    TTLOG(INFO,13)<<"[algo:"<<inst_id<<"] receive_algojob_request: Updated FIX params for reject response"<<endl;
request_receiver.cpp                    TTLOG(WARNING,13)<<"[algo:"<<inst_id<<"] receive_algojob_request: Failed to update CL_ORD_ID params for reject response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" "<<endl;
request_receiver.cpp                    TTLOG(INFO,13)<<"[algo:"<<inst_id<<"] receive_algojob_request: Updated CL_ORD_ID params for reject response cl_ord_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu"<<endl;
request_receiver.cpp        TTLOG(ERROR,13)<<"Failed to receive deploy_def message. Can not allocate with size of "<<def_size+1<<endl;
request_receiver.cpp        TTLOG(ERROR,13)<<" Error receiving data, request=["<<ALGOJOB_REQUEST_ID_STR[request->id]<<"], recvd_def_size="<<recvd_def_size<<", err="<<strerror(errno)<<endl;
so_algo_bin.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] set_state old="<<ALGO_STATE_STR[old_state]<<" new="<<ALGO_STATE_STR[new_state]<<endl;
so_algo_bin.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] is loosing broker_id !!!!!!!!!! state="<<ALGO_STATE_STR[get_state()]<<endl;
so_algo_bin.cpp            TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] recover from exising broker_id="<<broker_id<<"lu"<<endl;
so_algo_bin.cpp    TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"] destroy so_algo_bin "<<this<<endl;
so_algo_bin.cpp            TTLOG(WARNING,13)<<" finish_pending_action invoked while not in valid transitional state. State="<<ALGO_STATE_STR[algo_state]<<endl;
so_algo_bin.cpp    TTLOG(INFO,13)<<" finish_pending_action, old_state="<<ALGO_STATE_STR[algo_state]<<" new_state="<<ALGO_STATE_STR[next_job_state]<<" code="<<TTSDK_ERROR_STR[error_code]<<endl;
so_algo_bin.cpp            TTLOG(INFO,13)<<"finish_pending_action - set exec_restatement_reason to REPLACED."<<endl;
so_algo_bin.cpp            TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] finish_pending_action: Failed to update CL_ORD_ID params for pause response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" "<<endl;
so_algo_bin.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] finish_pending_action: Updated CL_ORD_ID params for pause response cl_ord_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu"<<endl;
so_algo_bin.cpp            TTLOG(INFO,13)<<"finish_pending_action - set exec_restatement_reason to REPLACE-REJECTED."<<endl;
so_algo_bin.cpp            TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] finish_pending_action: Failed to update FIX params for reject response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" IGNORE this warning if FIX is not involved!"<<endl;
so_algo_bin.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] finish_pending_action: Updated FIX params for reject response"<<endl;
so_algo_bin.cpp            TTLOG(WARNING,13)<<"[algo:"<<inst_id()<<"] finish_pending_action: Failed to update CL_ORD_ID params for reject response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" "<<endl;
so_algo_bin.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] finish_pending_action: Updated CL_ORD_ID params for reject response cl_ord_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu"<<endl;
so_algo_bin.cpp        TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"] so_algo_bin::pause_algo fail, state="<<ALGO_STATE_STR[algo_state]<<" "<<endl;
so_algo_bin.cpp        TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"] so_algo_bin::stop_algo. Algo already in state="<<ALGO_STATE_STR[algo_state]<<" "<<endl;
so_algo_bin.cpp        TTLOG(INFO,13)<<" [algo:"<<inst_id()<<"] so_algo_bin::stop_algo fail, state="<<ALGO_STATE_STR[algo_state]<<" "<<endl;
so_algo_bin.cpp        TTLOG(ERROR,13)<<" [algo:"<<inst_id()<<"] fail_algo_on_exception state="<<ALGO_STATE_STR[algo_state]<<" reason="<<reason<<endl;
so_algo_bin.cpp    TTLOG(INFO,13)<<""<<ss.str()<<endl;
adl_algo_bin_service_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"]: will use instrument_id="<<orderInstrId<<"lu (order instrument)"<<endl;
adl_algo_bin_service_events.cpp            TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"]: will use instrument_id="<<instrId<<"lu"<<endl;
adl_algo_bin_service_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] download_instr: instr_id="<<instr_id<<"lu on service thread"<<endl;
adl_algo_bin_service_events.cpp            TTLOG(ERROR,13)<<"download_instr: Instrument download failed, instr_id="<<instr_id<<"lu, error="<<tt::sdk::internal::to_string(dl_result.first)<<endl;
adl_algo_bin_service_events.cpp            TTLOG(ERROR,13)<<"compile_instr: Algo def download failed. instr_id="<<algo_instr_id<<"lu error="<<reason<<endl;
adl_algo_bin_service_events.cpp            TTLOG(ERROR,13)<<"compile_instr: Algo def not found, likely the algo is not approved. instr_id="<<algo_instr_id<<"lu"<<endl;
adl_algo_bin_service_events.cpp            TTLOG(ERROR,13)<<"compile_instr: Resource download failed. instr_id="<<algo_instr_id<<"lu error="<<reason<<endl;
adl_algo_bin_service_events.cpp        TTLOG(INFO,13)<<"[algo: "<<inst_id()<<"] Cancel compile_def. algo stopping"<<endl;
adl_algo_bin_service_events.cpp    TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] compile_def: Attempting to deploy algo resource: "<<algo_resource.substr(0<<"..."<<endl;
adl_algo_bin_service_events.cpp            TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] instr_id="<<instr_id<<"lu already exist"<<endl;
adl_algo_bin_service_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] parsing algo resource..."<<endl;
adl_algo_bin_service_events.cpp            TTLOG(ERROR,13)<<" [algo:"<<inst_id()<<"] Error ["<<GRAPH_ERROR_ID_STR[info.errorId]<<"] parsing algo XML at line: "<<info.lineNumber<<", source: "<<BLOCK_SOURCE_STR[info.sourceInfo.source]<<", source param: "<<info.sourceInfo.param<<", error msg: "<<info.msg<<" sourceCodeLineNumber: "<<info.sourceCodeLineNumber<<endl;
adl_algo_bin_service_events.cpp                TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] compile_def: failed to write xml source to file. error="<<strerror(errno)<<endl;
adl_algo_bin_service_events.cpp                TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] compile_def: xml source written to file "<<xml_path<<endl;
adl_algo_bin_service_events.cpp            TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] compile_def: parser_error="<<PARSER_ERROR_STR[parser_error]<<" \n root_def_uuid_string="<<root_def_uuid_string<<" \n algo_resource="<<algo_resource.substr(0<<endl;
adl_algo_bin_service_events.cpp            TTLOG(INFO,13)<<"Cancel compile_def, [algo: "<<inst_id()<<"] request for stopping"<<endl;
adl_algo_bin_service_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] emitting algo source code... to "<<source_path<<endl;
adl_algo_bin_service_events.cpp        TTLOG(INFO,13)<<"Special warning: "<<special_warning.str()<<endl;
adl_algo_bin_service_events.cpp            TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] compile_def: failed to write generated algo source to file. error="<<strerror(errno)<<endl;
adl_algo_bin_service_events.cpp            TTLOG(INFO,13)<<"Cancel compile_def, [algo: "<<inst_id()<<"] request for stopping"<<endl;
adl_algo_bin_service_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] compiling algo source code..."<<endl;
adl_algo_bin_service_events.cpp            TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] compile_def: compilation failed."<<endl;
adl_algo_bin_service_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] CompileSource called: compiler_command="<<compiler_command<<endl;
adl_algo_bin_service_events.cpp            TTLOG(INFO,13)<<"[algo: "<<inst_id()<<"] Cancel compile_def. algo stopping"<<endl;
adl_algo_bin_service_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] Load algo shared object "<<compiled_instr_path<<endl;
adl_algo_bin_service_events.cpp            TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] CompileDef: Error loading algo: "<<failure_string<<endl;
adl_algo_bin_service_events.cpp            TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] compile_def: InitAlgo failed."<<endl;
adl_algo_bin_service_events.cpp        TTLOG(INFO,13)<<"[algo:"<<inst_id()<<"] about to collect_instr. m_dl="<<dl_ptr<<endl;
adl_algo_bin_service_events.cpp        TTLOG(ERROR,13)<<"[algo:"<<inst_id()<<"] compile_def: EmitSource failed="<<ex.what()<<endl;
main.cpp        TTLOG(INFO,13)<<"SigActionHandler: sig="<<sig<<". Shutting down"<<endl;
main.cpp        TTLOG(INFO,13)<<"SigUsrSigHandler: ignoring unsupported signal="<<sig<<". To control the logging level, please use algocli "<<endl;
main.cpp            TTLOG(INFO,13)<<"SetSigAction replacing.... signal="<<sig<<", error="<<error<<", "<<strerror(errno)<<endl;
main.cpp        TTLOG(INFO,13)<<"SIGHUP received"<<endl;
main.cpp        TTLOG(INFO,13)<<"job_id="<<job_id<<", job_ptr="<<job<<endl;
main.cpp        TTLOG(INFO,13)<<"algojob__algoserver_address="<<algojob__algoserver_address<<endl;
main.cpp        TTLOG(INFO,13)<<"instance_identifier="<<instance_identifier<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: compiler="<<compiler<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: min_log_level="<<static_cast<int>(algojob__min_log_level)<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: remote_services="<<static_cast<int>(algojob__is_remote)<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: algojob__persist_xml="<<static_cast<int>(algojob__persist_xml)<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: collect_order_changes_stats="<<static_cast<int>(collect_order_changes_stats)<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: skip_should_apply_log_interval="<<skip_should_apply_log_interval<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: skip_order_change_log_interval="<<skip_order_change_log_interval<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: circular_loop_check="<<(int)circular_loop_check<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: circular_loop_limit="<<circular_loop_limit<<"u"<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: max_recursion_level="<<max_recursion_level<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: send_ahead_interval_ms="<<send_ahead_interval_ms<<endl;
main.cpp            TTLOG(INFO,13)<<"Detected ASAN_OPTIONS="<<asan_options<<endl;
main.cpp            TTLOG(INFO,13)<<"Note: ASAN_OPTIONS are not defined when running instrumented build"<<endl;
main.cpp        TTLOG(INFO,13)<<"Initializing AlgoJob. build_date= BUILD_DATE build_commit="<<endl;
main.cpp                TTLOG(INFO,13)<<""<<preloadEnv<<"="<<preloadVal<<endl;
main.cpp                TTLOG(INFO,13)<<""<<preloadEnv<<"=NULL"<<endl;
main.cpp                TTLOG(INFO,13)<<"Onload is enabled"<<endl;
main.cpp                TTLOG(INFO,13)<<"Onload is not enabled"<<endl;
main.cpp            TTLOG(ERROR,13)<<"Failed to connect to AlgoServer"<<endl;
main.cpp                 TTLOG(ERROR,13)<<oss.str()<<endl;
main.cpp            TTLOG(ERROR,13)<<"Failed to init PDS. url="<<pds_url<<endl;
main.cpp            TTLOG(ERROR,13)<<"Failed to start job."<<endl;
main.cpp            TTLOG(WARNING,13)<<"Failed to Preload SSE algos. Ignoring and continuing the initialization"<<endl;
main.cpp            TTLOG(INFO,13)<<"Analytics disabled via config. Continuing initializing Analytics components in case it's later enabled via CLI"<<endl;
main.cpp            TTLOG(INFO,13)<<"Analytics Initialization succeeded"<<endl;
main.cpp            TTLOG(ERROR,13)<<"Analytics Initialization failed but continuing anyway"<<endl;
main.cpp        TTLOG(ERROR,13)<<"Failed during startup! main_flags="<<flags<<", job_ptr="<<job<<endl;
main.cpp    TTLOG(INFO,13)<<"Shutting down. main_flags="<<main_flags<<endl;
main.cpp            TTLOG(ERROR,13)<<"Incorrect AnalyticsConfig "<<analyticsConfig.ToString()<<endl;
main.cpp            TTLOG(ERROR,13)<<"Incorrect ScheduleConfig "<<scheduleConfig.ToString()<<endl;
main.cpp        TTLOG(INFO,13)<<"AnalyticsConfig "<<analyticsConfig.ToString()<<" ScheduleConfig "<<scheduleConfig.ToString()<<endl;
main.cpp            TTLOG(ERROR,13)<<"AnalyticsEngine initialization failed"<<endl;
comm_websocket.cpp    TTLOG(INFO,13)<<"comm_websocket: New client connection_id: "<<next_connection_id<<"lu"<<endl;
comm_websocket.cpp                TTLOG(ERROR,13)<<"comm_websocket: decode_request_failed"<<endl;
comm_websocket.cpp                TTLOG(ERROR,13)<<"Invalid token. ["<<e.what()<<"]"<<endl;
comm_websocket.cpp        TTLOG(ERROR,13)<<" comm_websocket: Failure processing received data ["<<algoserver_error<<"], remaining_size ["<<remaining_size<<"]"<<endl;
comm_websocket.cpp            TTLOG(ERROR,13)<<"comm_websocket: Failure sending response ["<<websocket_error<<"]"<<endl;
comm_websocket.cpp                        TTLOG(DEBUG,13)<<"WebSocket::JobValue: active="<<algo->activeIndex<<", map[0].size="<<algo->mapBlockDefValues[0].size()<<" map[1].size="<<algo->mapBlockDefValues[1].size()<<endl;
comm_websocket.cpp            TTLOG(ERROR,13)<<"comm_websocket: Failure encoding forwarded data ["<<algoserver_error<<"]"<<endl;
comm_websocket.cpp            TTLOG(ERROR,13)<<"comm_websocket: Failure servicing websocket ["<<error<<"]"<<endl;
comm_websocket.cpp    TTLOG(INFO,13)<<"ConfigXml: port="<<port<<endl;
comm_websocket.cpp    TTLOG(INFO,13)<<"ConfigXml: use_ssl="<<use_ssl<<endl;
comm_websocket.cpp    TTLOG(INFO,13)<<"AlgoServer::comm_websocket context destroyed..."<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"Failed to get all SecurityExchanges from PDS. error="<<ex.what()<<endl;
ttus_user.cpp    TTLOG(INFO,13)<<"Get SecurityExchanges from PDS. security_exchanges.size()="<<security_exchanges.size()<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"AlgoSettings for account="<<account.id()<<"lu algosettings=["<<account.algo_settings().ShortDebugString().to_std()<<"]"<<endl;
ttus_user.cpp    TTLOG(INFO,13)<<"TTUSWeb::Init creating ttus_handler: configFile="<<configFile<<" max_ttus_workers="<<max_ttus_workers<<" enable_ttus_file_cache="<<enable_ttus_file_cache_str<<endl;
ttus_user.cpp    TTLOG(INFO,13)<<"TTUSWeb::Init sizeof(user_obj)="<<sizeof(user_obj)<<"lu "<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"ProcessUserResponse: "<<whichAPI<<" Response NOT OK. response.code="<<TTUS_ResponseCodeToString(response.code)<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"ProcessUserResponse: "<<whichAPI<<" Response OK, but size="<<size<<endl;
ttus_user.cpp    TTLOG(INFO,13)<<"ProcessSingleUser: Processing result from "<<whichAPI<<" for user_id="<<user_id<<"lu user_obj=["<<user.ShortDebugString().to_std()<<"]"<<endl;
ttus_user.cpp            TTLOG(WARNING,13)<<"ProcessSingleUser: Unexpected! Could not find user_id="<<user_id<<"lu in collection!"<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"ProcessSingleUser: user_id="<<user_id<<"lu does not have person_id!"<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"ProcessSingleUser: From "<<whichAPI<<" user_id="<<user_id<<"lu. user.account_ids_size()="<<user.account_ids_size()<<" user.account_settings_size()="<<user.account_settings_size()<<endl;
ttus_user.cpp            TTLOG(ERROR,13)<<"ProcessSingleUser: Too many accounts - dropping some accounts that are over the processing limit!"<<endl;
ttus_user.cpp                TTLOG(ERROR,13)<<"ProcessSingleUser: User updated with a NEW account="<<account_id<<"lu that has not reached us. Run CLI --ResetUserInfo for user_id="<<user_id<<"lu"<<endl;
ttus_user.cpp            TTLOG(ERROR,13)<<"ProcessSingleUser: user.account_settings_size() != user.account_ids_size()"<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"ProcessSingleUser: From "<<whichAPI<<" user_id="<<user_id<<"lu. user.exchange_product_groups_size()="<<user.exchange_product_groups_size()<<endl;
ttus_user.cpp            TTLOG(ERROR,13)<<"ProcessSingleUser: Too many exchange_product_groups - dropping some exchange_product_groups that are over the processing limit!"<<endl;
ttus_user.cpp                    TTLOG(ERROR,13)<<"ProcessSingleUser: Can not find security_exchange_id for exchange_id="<<key.market_id<<" identifier="<<key.name<<" "<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"ProcessSingleUser: From "<<whichAPI<<" user_id="<<user_id<<"lu require_permission_to_run_own_algo="<<userPtr->require_permission_to_run_own_algo<<". "<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"ProcessSingleUser: From "<<whichAPI<<" user_id="<<user_id<<"lu sim_party_id="<<sim_party_id<<"lu. "<<endl;
ttus_user.cpp            TTLOG(ERROR,13)<<"ProcessSingleUser: From "<<whichAPI<<" user_id="<<user_id<<"lu sim_party_id changed, this is not supported! old_party_id="<<userPtr->sim_party_id<<"lu new_party_id="<<sim_party_id<<"lu"<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"ProcessSingleUser: From "<<whichAPI<<" user_id="<<user_id<<"lu. user.custom_fields_size()="<<user.custom_fields_size()<<endl;
ttus_user.cpp            TTLOG(ERROR,13)<<"ProcessSingleUser: Too many custom_fields - dropping some custom_fields that are over the processing limit!"<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"<--All Info user_id="<<p->user_id<<"lu user_company_id="<<p->user_company_id<<"lu require_permission_to_run_own_algo="<<p->require_permission_to_run_own_algo<<" account_count="<<p->account_count<<"u market_data_count="<<p->market_data_count<<"u person_id="<<p->person_id<<"lu company_enable_algo_risk_checks="<<p->company_enable_algo_risk_checks<<" company_enable_near_far_touch_price_reasonability="<<p->company_enable_near_far_touch_price_reasonability<<" sim_party_id="<<p->sim_party_id<<"lu "<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"<-----account_id="<<p->ptr_accounts[i].account_id<<"lu, broker_id="<<p->ptr_accounts[i].broker_id<<"lu, account_company_id="<<p->ptr_accounts[i].account_company_id<<"lu"<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"<--------algo_permission=[ ttsdk="<<p->ptr_accounts[i].algo_permission.ttsdk<<" adl="<<p->ptr_accounts[i].algo_permission.adl<<" timed="<<p->ptr_accounts[i].algo_permission.tt_timed<<" stop="<<p->ptr_accounts[i].algo_permission.tt_stop<<" if_touched="<<p->ptr_accounts[i].algo_permission.tt_if_touched<<" trailing_limit="<<p->ptr_accounts[i].algo_permission.tt_trailing_limit<<" oco="<<p->ptr_accounts[i].algo_permission.tt_oco<<" bracket="<<p->ptr_accounts[i].algo_permission.tt_bracket<<" iceberg="<<p->ptr_accounts[i].algo_permission.tt_iceberg<<" time_duration="<<p->ptr_accounts[i].algo_permission.tt_time_duration<<" time_slicer="<<p->ptr_accounts[i].algo_permission.tt_time_slicer<<" retry="<<p->ptr_accounts[i].algo_permission.tt_retry<<" WAT="<<p->ptr_accounts[i].algo_permission.tt_with_a_tick<<" obv="<<p->ptr_accounts[i].algo_permission.tt_obv<<" auto_hedger="<<p->ptr_accounts[i].algo_permission.tt_auto_hedger<<" volume_slicer="<<p->ptr_accounts[i].algo_permission.tt_volume_slicer<<" volume_duration="<<p->ptr_accounts[i].algo_permission.tt_volume_duration<<"]"<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"<--------"<<ToString(p->ptr_accounts[i].algo_settings)<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"<-----exchange_id="<<p->market_data[i].exchange_id<<"u, security_exchange_id="<<p->market_data[i].security_exchange_id<<"u, "<<p->market_data[i].is_all_market?"all":"individual"<<" "<<p->market_data[i].allowed?"allowed":"notallowed"<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"<-----company_id="<<p->custom_fields[i].company_id<<"lu, name="<<p->custom_fields[i].name<<", value="<<p->custom_fields[i].value<<endl;
ttus_user.cpp    TTLOG(INFO,13)<<"SyncDownloadUser: user_id="<<user_id<<"lu downloading from Admin API..."<<endl;
ttus_user.cpp    TTLOG(INFO,13)<<"SyncDownloadUser: user_id="<<user_id<<"lu downloaded from Admin API: response_code="<<TTUS_ResponseCodeToString(admin_api_response.code)<<endl;
ttus_user.cpp        TTLOG(DEBUG,13)<<"SyncDownloadUser: Printing raw response="<<admin_api_response.response->ShortDebugString().to_std()<<" response_size="<<admin_api_response.response->ByteSize()<<endl;
ttus_user.cpp    TTLOG(INFO,13)<<"SyncDownloadUser: user_id="<<user_id<<"lu downloading from Risk API..."<<endl;
ttus_user.cpp    TTLOG(INFO,13)<<"SyncDownloadUser: user_id="<<user_id<<"lu downloaded from Risk API: response_code="<<TTUS_ResponseCodeToString(risk_api_response.code)<<endl;
ttus_user.cpp        TTLOG(DEBUG,13)<<"SyncDownloadUser: Printing raw response="<<risk_api_response.response->ShortDebugString().to_std()<<" response_size="<<risk_api_response.response->ByteSize()<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"SyncDownloadUser: ADMIN API Response NOT OK - sending FAILED result to Server Thread: response.code="<<TTUS_ResponseCodeToString(admin_api_response.code)<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"SyncDownloadUser: RISK API Response NOT OK - sending FAILED result to Server Thread: response.code="<<TTUS_ResponseCodeToString(risk_api_response.code)<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"SyncDownloadUser: For user_id="<<user_id<<"lu, both ADMIN API and RISK API Responses are OK! Now processing responses and adding user_obj to m_users collection!"<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"SyncDownloadUser: user_id="<<user_id<<"lu processed Admin API response: process_result="<<admin_api_process_result?"success":"failure"<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"SyncDownloadUser: user_id="<<user_id<<"lu processed Risk API response: process_result="<<risk_api_process_result?"success":"failure"<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"SyncDownloadUser: user_id="<<user_id<<"lu detach worker. m_workersForUserDownload.size()="<<m_workersForUserDownload.size()<<" "<<endl;
ttus_user.cpp            TTLOG(ERROR,13)<<"SyncDownloadUser: user_id="<<user_id<<"lu. worker_thread no longer in map!! m_workersForUserDownload.size()="<<m_workersForUserDownload.size()<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"AsyncDownloadUser: user_id="<<user_id<<"lu has already been downloaded"<<endl;
ttus_user.cpp        TTLOG(WARNING,13)<<"AsyncDownloadUser: user_id="<<user_id<<"lu is currently running"<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"AsyncDownloadUser: Too many ttus worker threads. m_workersForUserDownload.size()="<<m_workersForUserDownload.size()<<endl;
ttus_user.cpp    TTLOG(INFO,13)<<"AsyncDownloadUser: user_id="<<user_id<<"lu starts..."<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"DownloadConnectionsSync response OK, response.response->update().size()="<<size<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"DownloadConnectionsSync response NOT OK. response.code="<<TTUS_ResponseCodeToString(response.code)<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"SyncDownloadSpecificConnections response OK: id="<<id<<"lu response.response->update().size()="<<size<<endl;
ttus_user.cpp            TTLOG(ERROR,13)<<"SyncDownloadSpecificConnections response NOT OK: problematic_id="<<id<<"lu response.code="<<TTUS_ResponseCodeToString(response.code)<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"DownloadAccountsSync response OK, response.response->update().size()="<<size<<endl;
ttus_user.cpp                TTLOG(ERROR,13)<<"TTUS:Dropping connections!!!!!!!!!!"<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"DownloadAccountsSync response NOT OK. response.code="<<TTUS_ResponseCodeToString(response.code)<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"SyncDownloadSpecificAccounts response OK: id="<<id<<"lu response.response->update().size()="<<size<<endl;
ttus_user.cpp                    TTLOG(ERROR,13)<<"SyncDownloadSpecificAccounts: This account has too many connections! Dropping the following connections!"<<endl;
ttus_user.cpp                        TTLOG(ERROR,13)<<"SyncDownloadSpecificAccounts: Dropped "<<dropped_connection_id<<"lu"<<endl;
ttus_user.cpp            TTLOG(ERROR,13)<<"SyncDownloadSpecificAccounts response NOT OK: problematic_id="<<id<<"lu response.code="<<TTUS_ResponseCodeToString(response.code)<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"Remove user[user_id="<<user_id<<"lu]"<<endl;
ttus_user.cpp        TTLOG(WARNING,13)<<"TTUSWeb::RefreshToken called before Init()"<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"TTUSWeb::RefreshToken called before Init()"<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"InternalTTUSHandler::Initialize: Asking TTUS Client Library for App Token..."<<endl;
ttus_user.cpp                TTLOG(INFO,13)<<"InternalTTUSHandler::Initialize: App Token not ready yet - sleep 3 seconds and try again..."<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"InternalTTUSHandler::Initialize: App Token obtained!"<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"InternalTTUSHandler::Initialize: Already initialized!"<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"Connection Update received. New connection: connection_id="<<connection_id<<"lu, exchange_id="<<exchange_id<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"Connection Update received. Update connection: connection_id="<<connection_id<<"lu, old exchange_id="<<found->second<<", new exhcange_id="<<exchange_id<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"Account Update received. New Account: account_id="<<account_id<<"lu account_company_id="<<account.company_id()<<"lu, broker_id="<<account.broker_id()<<"lu, connection_count="<<account.connection_ids_size()<<"lu "<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"Account Update received. Change Account: account_id="<<account_id<<"lu account_company_id("<<accountPtr->account_company_id<<"lu-->"<<account.company_id()<<"lu) broker_id("<<accountPtr->broker_id<<"lu-->"<<account.broker_id()<<"lu) connection_count("<<accountPtr->connection_count<<"lu-->"<<account.connection_ids_size()<<"lu) algoSettingsChanged="<<algoSettingsChanged<<endl;
ttus_user.cpp            TTLOG(ERROR,13)<<"TTUS:Dropping connections!!!!!!!!!! account_id="<<account.id()<<"lu connection_size="<<account.connection_ids_size()<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"DownloadSingleResourceWithRetrys: This function does NOT support NON-BLOCKING option! Please call TTUSHandler::DownloadSingleResource directly."<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"DownloadSingleResourceWithRetrys: Sleeping for 100 milliseconds..."<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"DownloadSingleResourceWithRetrys: Calling TTUSHandler::DownloadSingleResource: number_of_attempts_so_far="<<number_of_attempts_so_far<<" max_number_of_attempts="<<max_number_of_attempts<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"DownloadSingleResourceWithRetrys: Completed TTUSHandler::DownloadSingleResource: response.code="<<TTUS_ResponseCodeToString(response.code)<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"DownloadAllResourcesWithRetrys: This function does NOT support NON-BLOCKING option! Please call TTUSHandler::DownloadAllResources directly."<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"DownloadAllResourcesWithRetrys: Calling TTUSHandler::DownloadAllResources: number_of_attempts_so_far="<<number_of_attempts_so_far<<" max_number_of_attempts="<<max_number_of_attempts<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"DownloadAllResourcesWithRetrys: Completed TTUSHandler::DownloadAllResources: response.code="<<TTUS_ResponseCodeToString(response.code)<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"Company: name=["<<c.name().c_str()<<"] id="<<company_id<<"lu generate_synthetic_leg_fill="<<generate_synthetic_leg_fill<<" enable_algo_risk_checks="<<enable_algo_risk_checks<<" enable_near_far_touch_price_reasonability="<<enable_near_far_touch_price_reasonability<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"SyncDownloadCompanies response OK, size="<<size<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"SyncDownloadCompanies response NOT OK. response.code="<<TTUS_ResponseCodeToString(response.code)<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"SyncDownloadSpecificCompanies response OK: id="<<id<<"lu size="<<size<<endl;
ttus_user.cpp            TTLOG(ERROR,13)<<"SyncDownloadSpecificCompanies response NOT OK: problematic_id="<<id<<"lu response.code="<<TTUS_ResponseCodeToString(response.code)<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"CheckCompanyForGenerateLegFills: account_id="<<account_id<<"lu not in map! user_id="<<user_id<<"lu"<<endl;
ttus_user.cpp        TTLOG(DEBUG,13)<<"CheckCompanylevelSetting. company_id="<<userPtr->user_company_id<<"lu for user_id="<<userPtr->user_id<<"lu enable_algo_risk_checks="<<itr->second->enable_algo_risk_checks<<" enable_near_far_touch_price_reasonability="<<itr->second->enable_near_far_touch_price_reasonability<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"CheckCompanylevelSetting. Can not find company_id="<<userPtr->user_company_id<<"lu for user_id="<<userPtr->user_id<<"lu "<<endl;
ttus_user.cpp            TTLOG(ERROR,13)<<"User company not in Company cache! user_company_id="<<user_obj->user_company_id<<"lu user_id=$llu"<<endl;
ttus_user.cpp                    TTLOG(INFO,13)<<"UpdateAlgoSettingsByAccountUpdate: user_id="<<user_obj->user_id<<"lu account_id="<<updated_account_id<<"lu"<<endl;
ttus_user.cpp                        TTLOG(ERROR,13)<<"User account not in Account cache! account_id="<<user_account.account_id<<"lu user_id=$llu"<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"UpdateUserByCompanyUpdate: user_id="<<user_obj->user_id<<"lu company_id="<<updated_company_id<<"lu"<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"TTUSWeb::AsyncDownloadAggregatedRiskLimits: Too many ttus worker threads! inst_id="<<algo_instance_id<<" m_workersForRiskLimitDownload.size()="<<m_workersForRiskLimitDownload.size()<<endl;
ttus_user.cpp    TTLOG(INFO,13)<<"TTUSWeb::AsyncDownloadAggregatedRiskLimits: Starting async download on TTUS Worker Thread: inst_id="<<algo_instance_id<<" worker_id="<<this->m_workersForRiskLimitDownloadID<<"lu user_id="<<user_id<<"lu account_id="<<account_id<<"lu instrument_id="<<instrument_id<<"lu "<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"TTUSWeb::SyncDownloadAggregatedRiskLimits: inst_id="<<algo_instance_id<<": Instrument download failed!"<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"TTUSWeb::SyncDownloadAggregatedRiskLimits: inst_id="<<algo_instance_id<<": Instrument parse failed!"<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"TTUSWeb::SyncDownloadAggregatedRiskLimits: inst_id="<<algo_instance_id<<": Exempted from risk checks because the given instrument is synthetic."<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"TTUSWeb::SyncDownloadAggregatedRiskLimits: inst_id="<<algo_instance_id<<": Given instrument is Calendar Spread / Option Strategy - we must download first child leg instrument and use the child's product_type_id and product_id to locate the proper risk limits!"<<endl;
ttus_user.cpp            TTLOG(ERROR,13)<<"TTUSWeb::SyncDownloadAggregatedRiskLimits: inst_id="<<algo_instance_id<<": Child instrument download failed!"<<endl;
ttus_user.cpp            TTLOG(ERROR,13)<<"TTUSWeb::SyncDownloadAggregatedRiskLimits: inst_id="<<algo_instance_id<<": Child instrument parse failed!"<<endl;
ttus_user.cpp        TTLOG(INFO,13)<<"TTUSWeb::SyncDownloadAggregatedRiskLimits: Using child leg instrument's product_type_id and product_id: inst_id="<<algo_instance_id<<" parent_product_type_id="<<product_type_id<<"lu --> child_product_type_id="<<child_product_type_id<<"lu parent_product_id="<<product_id<<"lu --> child_product_id="<<child_product_id<<"lu"<<endl;
ttus_user.cpp    TTLOG(INFO,13)<<"TTUSWeb::SyncDownloadAggregatedRiskLimits: Starting sync download on TTUS Worker Thread: inst_id="<<algo_instance_id<<" user_id="<<user_id<<"lu account_id="<<account_id<<"lu instrument_id="<<instrument_id<<"lu "<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"TTUSWeb::SyncDownloadAggregatedRiskLimits: Response NOT OK. inst_id="<<algo_instance_id<<" response.code="<<TTUS_ResponseCodeToString(response.code)<<" "<<endl;
ttus_user.cpp    TTLOG(INFO,13)<<"TTUSWeb::SyncDownloadAggregatedRiskLimits: Response OK (zero means not set): inst_id="<<algo_instance_id<<" outright_price_drift_check_interval_one_min_ticks="<<risk_limits_cache->risk_limits.pdci_one_min_ticks<<" outright_price_drift_check_interval_one_min_pct="<<risk_limits_cache->risk_limits.pdci_one_min_pct<<" outright_price_drift_check_interval_three_min_ticks="<<risk_limits_cache->risk_limits.pdci_three_min_ticks<<" outright_price_drift_check_interval_three_min_pct="<<risk_limits_cache->risk_limits.pdci_three_min_pct<<" outright_price_drift_check_interval_lifetime_ticks="<<risk_limits_cache->risk_limits.pdci_lifetime_ticks<<" outright_price_drift_check_interval_lifetime_pct="<<risk_limits_cache->risk_limits.pdci_lifetime_pct<<" spread_price_drift_check_interval_one_min_ticks="<<risk_limits_cache->risk_limits.spdci_one_min_ticks<<" spread_price_drift_check_interval_one_min_pct="<<risk_limits_cache->risk_limits.spdci_one_min_pct<<" spread_price_drift_check_interval_three_min_ticks="<<risk_limits_cache->risk_limits.spdci_three_min_ticks<<" spread_price_drift_check_interval_three_min_pct="<<risk_limits_cache->risk_limits.spdci_three_min_pct<<" spread_price_drift_check_interval_lifetime_ticks="<<risk_limits_cache->risk_limits.spdci_lifetime_ticks<<" spread_price_drift_check_interval_lifetime_pct="<<risk_limits_cache->risk_limits.spdci_lifetime_pct<<" max_child_slice_size="<<risk_limits_cache->risk_limits.max_child_slice_size<<" max_number_of_cancels="<<risk_limits_cache->risk_limits.max_number_of_cancels<<" max_number_of_updates="<<risk_limits_cache->risk_limits.max_number_of_updates<<" is_spread_or_strategy="<<risk_limits_cache->risk_limits.is_spread_or_strategy<<endl;
ttus_user.cpp            TTLOG(INFO,13)<<"SendAggregatedRiskLimitsAndEraseWorker: worker_id="<<worker_id<<"lu --> detached worker. m_workersForRiskLimitDownload.size()="<<m_workersForRiskLimitDownload.size()<<" "<<endl;
ttus_user.cpp            TTLOG(ERROR,13)<<"SendAggregatedRiskLimitsAndEraseWorker: worker_id="<<worker_id<<"lu --> unexpectedly absent in map! m_workersForRiskLimitDownload.size()="<<m_workersForRiskLimitDownload.size()<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"GetUserOrganizationByAccountId: account_id="<<account_id<<"lu not found"<<endl;
ttus_user.cpp        TTLOG(ERROR,13)<<"GetUserOrganizationByAccountId: user_id="<<user_id<<"lu not found"<<endl;
ttus_user.cpp    TTLOG(ERROR,13)<<"GetUserOrganizationByAccountId: organization not found for account_id="<<account_id<<"lu account_company_id="<<account_company_id<<"lu user_id="<<user_id<<"lu"<<endl;
token_manager.cpp        TTLOG(ERROR,13)<<"Skip UpdateAccessToken. user_id="<<user_id<<"lu"<<endl;
token_manager.cpp            TTLOG(ERROR,13)<<"!!!!!!!!! Invalid token: algoserver_request from user="<<user_id<<"lu, but the token is for user="<<token_info.user_id<<"lu !!!!!!!!!!"<<endl;
token_manager.cpp        TTLOG(ERROR,13)<<"Exception while ValidateAndUpdateAccessToken: user_id="<<user_id<<"lu runtime_error="<<e.what()<<" "<<endl;
token_manager.cpp    TTLOG(INFO,13)<<"Started token_manager timer internval=60 seconds"<<endl;
token_manager.cpp                TTLOG(ERROR,13)<<"Token user mismatch. user_id="<<user_id<<"lu token.user_id="<<old_token_info.user_id<<"lu"<<endl;
token_manager.cpp                TTLOG(ERROR,13)<<"Failed to resign tokens., user_id="<<user_id<<"lu error="<<ALGOSERVER_ERROR_STR[error]<<" expiry="<<old_token_info.expiry<<"lu"<<endl;
token_manager.cpp                TTLOG(ERROR,13)<<"Failed to store access token., user_id="<<user_id<<"lu error="<<ALGOSERVER_ERROR_STR[error]<<endl;
token_manager.cpp                TTLOG(WARNING,13)<<"Failed to store refresh token., user_id="<<user_id<<"lu error="<<ALGOSERVER_ERROR_STR[error]<<endl;
token_manager.cpp            TTLOG(INFO,13)<<"Token successfully re-signed. user_id="<<user_id<<"lu expiry="<<new_token_info.expiry<<"lu"<<endl;
token_manager.cpp            TTLOG(ERROR,13)<<"Exception while resign token: user_id="<<user_id<<"lu runtime_error="<<e.what()<<" "<<endl;
token_manager.cpp    TTLOG(INFO,13)<<"Re-signed "<<succeeded<<" of "<<attempts<<" tokens in "<<difftime(start_time<<" seconds"<<endl;
token_manager.cpp            TTLOG(ERROR,13)<<"ExamToken: Failed to resign token. error="<<ALGOSERVER_ERROR_STR[error]<<" user_id="<<token_info.user_id<<"lu"<<endl;
token_manager.cpp            TTLOG(ERROR,13)<<"ExamToken: Failed to save Access Token. error="<<ALGOSERVER_ERROR_STR[error]<<" user_id="<<token_info.user_id<<"lu"<<endl;
token_manager.cpp            TTLOG(INFO,13)<<"Saving access token. user_id="<<token_info.user_id<<"lu expiry="<<token_info.expiry<<"lu"<<endl;
token_manager.cpp            TTLOG(ERROR,13)<<"ExamToken: Failed to save Refresh Token. error="<<ALGOSERVER_ERROR_STR[error]<<" user_id="<<token_info.user_id<<"lu"<<endl;
token_manager.cpp            TTLOG(INFO,13)<<"Saving refresh token for user_id="<<token_info.user_id<<"lu"<<endl;
token_manager.cpp            TTLOG(ERROR,13)<<"RenewTokenUponRecovery: Failed to fetch Access Token from Disk error="<<error<<"("<<ALGOSERVER_ERROR_STR[error]<<") user_id="<<user_id<<"lu order_id="<<order_id<<" "<<endl;
token_manager.cpp            TTLOG(INFO,13)<<"RenewTokenUponRecovery: Fetched Access Token from DIsk: user_id="<<user_id<<"lu order_id="<<order_id<<" "<<endl;
token_manager.cpp            TTLOG(ERROR,13)<<"!!!!!!!!! Invalid token: algoserver_request from user="<<user_id<<"lu, but the token is for user="<<token_info.user_id<<"lu !!!!!!!!!!"<<endl;
token_manager.cpp            TTLOG(ERROR,13)<<"Expired token. but continue recovery. user_id="<<token_info.user_id<<"lu expiry="<<token_info.expiry<<"lu current="<<current_time_ns<<"lu env_missing_token="<<env_missing_token<<endl;
token_manager.cpp        TTLOG(ERROR,13)<<"RenewTokenUponRecovery: Failed. runtime_error="<<e.what()<<", user_id="<<user_id<<"lu order_id="<<order_id<<" "<<endl;
token_manager.cpp        TTLOG(DEBUG,13)<<"Refresh in progress. Skip!"<<endl;
token_manager.cpp            TTLOG(WARNING,13)<<"Skipped "<<skipped<<"lu refresh"<<endl;
token_manager.cpp        TTLOG(INFO,13)<<"About to Refresh "<<local_copy.size()<<" token(s) "<<endl;
token_manager.cpp                            TTLOG(INFO,13)<<"Send updated token to algojob [user_id="<<user_id<<"lu, job_id="<<algojob->algojob_id<<"lu]"<<endl;
token_manager.cpp                TTLOG(ERROR,13)<<"Exception while RefreshOnTimerThreadn: user_id="<<user_id<<"lu runtime_error="<<e.what()<<" "<<endl;
load_balancer.cpp        TTLOG(INFO,13)<<" Selecting an algojob for incoming request: request.id="<<ALGOJOB_REQUEST_ID_STR[request.id]<<" request.inst_id="<<inst_uuid<<" request.user_id="<<request.user_id<<"lu request.user_request_id="<<request.user_request_id<<"lu"<<endl;
load_balancer.cpp            TTLOG(INFO,13)<<"Decided to spawn a new algojob."<<endl;
load_balancer.cpp            TTLOG(INFO,13)<<" Decided to route to an existing algojob: selected_algojob->algojob_id="<<selected_algojob->algojob_id<<"lu"<<endl;
load_balancer.cpp            TTLOG(ERROR,13)<<" RoundRobin threw an out-of-range exception - we will just spawn a new algojob instead of round-robin."<<endl;
load_balancer.cpp            TTLOG(ERROR,13)<<" RoundRobin threw an unknown exception - we will just spawn a new algojob instead of round-robin."<<endl;
load_balancer.cpp                TTLOG(INFO,13)<<" RESERVED: RoundRobinPolicyWithReservedUsers::IsReservedAlgoJobForUserImpl() user_id="<<user_id<<"lu"<<endl;
load_balancer.cpp                    TTLOG(INFO,13)<<" RESERVED: RoundRobinPolicyWithReservedUsers::PickAlgoJobImpl() user_id="<<request.user_id<<"lu, FOUND ALGOJOB\n"<<endl;
load_balancer.cpp                    TTLOG(INFO,13)<<" RESERVED: RoundRobinPolicyWithReservedUsers::PickAlgoJobImpl() user_id="<<request.user_id<<"lu, Empty ALGOJOB\n"<<endl;
load_balancer.cpp            TTLOG(INFO,13)<<" UN-----RESERVED: RoundRobinPolicyWithReservedUsers::PickAlgoJobImpl() user_id="<<request.user_id<<"lu\n"<<endl;
load_balancer.cpp            TTLOG(ERROR,13)<<" RoundRobinPolicyWithReservedUsers threw an out-of-range exception - we will just spawn a new algojob instead of round-robin."<<endl;
load_balancer.cpp            TTLOG(ERROR,13)<<" RoundRobinPolicyWithReservedUsers threw an unknown exception - we will just spawn a new algojob instead of round-robin."<<endl;
load_balancer.cpp    TTLOG(INFO,13)<<" -----------------|> Initialized to policy type: "<<DISTRIBUTION_POLICY_STR[policy]<<" <|----------------- "<<endl;
load_balancer.cpp        TTLOG(INFO,13)<<"algojob "<<algojobData<<" assigned to user "<<user_id<<"lu"<<endl;
pricefs_config_xml.cpp    TTLOG(INFO,13)<<"*****************************Prepare Unifier CRAP for Job="<<algojob_id<<"lu ****************************"<<endl;
pricefs_config_xml.cpp        TTLOG(ERROR,13)<<" PreparePriceUnifierConfigXml "<<unifier_config.str()<<" does not exist"<<endl;
pricefs_config_xml.cpp        TTLOG(INFO,13)<<" unifier crap: read_xml Parsed Successfully for "<<unifier_config.str()<<endl;
pricefs_config_xml.cpp                TTLOG(INFO,13)<<" unifier crap: set price_client_config_file to "<<new_price_client_config.str()<<endl;
pricefs_config_xml.cpp        TTLOG(INFO,13)<<"*****************************Done Unifier CRAP for Job="<<algojob_id<<"lu *******************************"<<endl;
pricefs_config_xml.cpp        TTLOG(ERROR,13)<<" PreparePriceUnifierConfigXml Failed to read "<<unifier_config.str()<<", invalid format"<<endl;
pricefs_config_xml.cpp        TTLOG(ERROR,13)<<" PreparePriceUnifierConfigXml Failed to read "<<unifier_config.str()<<", error "<<e.what()<<endl;
pricefs_config_xml.cpp        TTLOG(INFO,13)<<" PreparePriceClientConfigXml() base="<<baseConfigFile.str()<<", new="<<newConfigFile.str()<<", algojob_id="<<algojob_id<<"lu"<<endl;
pricefs_config_xml.cpp        TTLOG(ERROR,13)<<" ERROR PreparePriceClientConfigXml() boost::property_tree::ptree_bad_path algojob_id="<<algojob_id<<"lu"<<endl;
pricefs_config_xml.cpp        TTLOG(ERROR,13)<<" ERROR PreparePriceClientConfigXml() xml_parser_error::ptree_bad_path algojob_id="<<algojob_id<<"lu"<<endl;
book_downloader.cpp    TTLOG(INFO,13)<<"ConfigXml: skip_order_book_dl_config="<<skip_order_book_dl_config<<endl;
book_downloader.cpp        TTLOG(INFO,13)<<"Skipping order book download (due to config setting)"<<endl;
book_downloader.cpp        TTLOG(INFO,13)<<"Requesting book download, attempt="<<retry_count<<", delay="<<retry_delay<<" secs"<<endl;
book_downloader.cpp            TTLOG(ERROR,13)<<"Failed to get clock time, unable to schedule download requests"<<endl;
book_downloader.cpp        TTLOG(ERROR,13)<<"Failed to receive download response from ledger"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<" Can not get brokerId from algo_params for account_id="<<acctId<<"lu"<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"STAGED: From NewOrderSingle SET_staged_order_id="<<staged<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<" InitRequest: request=["<<ALGOJOB_REQUEST_ID_STR[request_id]<<"], user_id="<<user_id<<", account_id="<<connection_id<<"lu broker_id="<<broker_id<<"lu instr_id="<<instr_id<<"lu, user_req_id="<<user_request_id<<"lu, timeSent="<<timeSent<<"lu source="<<tt::messaging::order::enums::Source_Name(source).to_std()<<" flags="<<flags<<"8x cl_ord_id="<<cl_ord_id<<"lu "<<endl;
protocol_protobuf.cpp                    TTLOG(INFO,13)<<"Recevied long param: "<<user_param_item->name().c_str()<<"="<<user_param_item->v_string().c_str()<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] new_order_single missing user_id"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] new_order_single missing account_id"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] new_order_single missing cl_ord_id"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] new_order_single missing auth_token"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] new_order_single missing algo_instrument_id"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] new_order_single missing instrument_id"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] new_order_single missing market_id"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] new_order_single missing side"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] new_order_single missing ord_type"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] new_order_single missing time_sent"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] new_order_single missing source"<<endl;
protocol_protobuf.cpp        TTLOG(WARNING,13)<<"DecodeNewOrderSingle ParseFromString failed. Trying ParseFromArray. payload_size="<<wire_message->payload(0).length()<<"u"<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"DecodeNewOrderSingle ParseFromArray also failed."<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"Alert condition: [Failure processing LOOPBACK data] IS FIXED"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"new_order_single missing order_id"<<endl;
protocol_protobuf.cpp    TTLOG(DEBUG,13)<<"L([=]() { return std::string([algo_inst_id=) + algo_inst_id.to_string() + ] NewOrderSingle "<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] new_order_single has too many user parameter, user_parameter_count="<<user_parameter_size<<"u"<<endl;
protocol_protobuf.cpp        TTLOG(WARNING,13)<<"Receive deprecated ase_order_info algo_inst_id="<<algo_inst_id<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<"DecodeNewOrderSingle: "<<nos_info.str()<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"DecodeNewOrderSingle: order_id="<<algo_inst_id<<" user_parameters=["<<parsedMessage<<"]"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"UpdateChangedFields: order_id="<<algo_inst_id<<" found no class_1_2_fields"<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"UpdateChangedFields: order_id="<<algo_inst_id<<" change=["<<inbound_class_1_2->ShortDebugString().to_std()<<"]"<<endl;
protocol_protobuf.cpp    TTLOG(DEBUG,13)<<"L([=]() { return std::string([algo_inst_id=) + algo_inst_id.to_string() + ] OrderCancel "<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] order_cancel_request missing user_id"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] order_cancel_request missing account_id"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] order_cancel_request missing cl_ord_id"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] order_cancel_request missing instrument_id"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] order_cancel_request missing market_id"<<endl;
protocol_protobuf.cpp    TTLOG(DEBUG,13)<<"L([=]() { return std::string([algo_inst_id=) + algo_inst_id.to_string() + ] OrderCancelReplace "<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] order_cancel_replace_request missing user_id"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] order_cancel_replace_request missing account_id"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] order_cancel_replace_request missing cl_ord_id"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] order_cancel_replace_request missing instrument_id"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo["<<algo_inst_id<<"] order_cancel_replace_request missing market_id"<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"DecodeOrderCancelReplaceRequest: order_id="<<algo_inst_id<<" user_parameters=["<<parsedMessage<<"]"<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<"DecodeAlgoSideChannelRequest. args: "<<request->data.cli_cmd.argc?oss.str():""<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<"DecodeTriageActionRequest: request_id="<<triage_action_request.request_id().to_std()<<" initiator_name="<<triage_action_request.initiator_name().to_std()<<" message="<<triage_action_request.message().to_std()<<endl;
protocol_protobuf.cpp        TTLOG(WARNING,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: OC rejected OTD NOS with: ord_status=ORD_STATUS_REJECTED"<<endl;
protocol_protobuf.cpp        TTLOG(WARNING,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Failed to find Algo's Class 1/2 Fields!"<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Dumping class_1_2_fields before merge:\n"<<class_1_2_fields->ShortDebugString().to_std()<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD account="<<er->account().to_std()<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD account_override="<<er->account_override().to_std()<<" (Parent ER's [account_override] and [account] fields will honor this value going forward)"<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD text_tt="<<er->text_tt().to_std()<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD text_a="<<er->text_a().to_std()<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD text_b="<<er->text_b().to_std()<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD text_c="<<er->text_c().to_std()<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD vendor_defined_field_1="<<er->vendor_defined_field_1().to_std()<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD vendor_defined_field_2="<<er->vendor_defined_field_2().to_std()<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD vendor_defined_field_3="<<er->vendor_defined_field_3().to_std()<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD vendor_defined_field_4="<<er->vendor_defined_field_4().to_std()<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD vendor_defined_field_5="<<er->vendor_defined_field_5().to_std()<<endl;
protocol_protobuf.cpp                TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_ORDER_ORIGINATION_TRADER"<<endl;
protocol_protobuf.cpp                TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_ACCOUNT_CODE"<<endl;
protocol_protobuf.cpp                TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_TAKEUP_FIRM"<<endl;
protocol_protobuf.cpp                TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_CLIENT_ID"<<endl;
protocol_protobuf.cpp                TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_EXECUTING_TRADER"<<endl;
protocol_protobuf.cpp                TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_INVESTMENT_DECISION_MAKER"<<endl;
protocol_protobuf.cpp                TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_MIFID_ID"<<endl;
protocol_protobuf.cpp                TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Using OTD Party with party_role=PARTY_ROLE_EXECUTING_FIRM"<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderTags: Dumping class_1_2_fields after merge:\n"<<class_1_2_fields->ShortDebugString().to_std()<<endl;
protocol_protobuf.cpp                TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] DecodeOrderResponse: Enqueue fill for order_id="<<order_id<<" instrument_id="<<er->instrument_id()<<"lu order_sequence="<<er->order_sequence()<<"lu last_qty="<<er->last_qty()<<".8f leg_fill_sequence="<<er->leg_fill_sequence()<<"lu reporting_type="<<MultiLegReportingType_Name(er->multi_leg_reporting_type()).to_std().substr(MULTI_LEG_REPORTING_TYPE_PREFIX_SIZE)<<" "<<endl;
protocol_protobuf.cpp    TTLOG(DEBUG,13)<<"L([=]() { return algo[ + algo_inst_id.to_string() + ]: Dumping order_fill_update_msg: "<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"DecodeOrderFillUpdateRequest: order_id="<<algo_inst_id<<" review_status="<<TTSDK_ReviewStatusToString(review_status)<<" review_user_id="<<review_user_id<<"lu The message length cb="<<cb<<"u exceeds the max="<<sizeof(request->data.order_review_approve.serialized_msg)<<"u"<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"DecodeOrderFillUpdateRequest: order_id="<<algo_inst_id<<" review_status="<<TTSDK_ReviewStatusToString(review_status)<<" review_user_id="<<review_user_id<<"lu cb="<<cb<<"u "<<msg.ShortDebugString().to_std()<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"DecodeOrderFillUpdateRequest: could not find order_id="<<algo_inst_id<<" in s_algo_protobufs. Assuming it's a terminated order"<<endl;
protocol_protobuf.cpp                    TTLOG(ERROR,13)<<"DecodeOrderFillUpdateRequest: order_id="<<algo_inst_id<<" text_a="<<text_a<<" text_b="<<text_b<<" text_tt="<<text_tt<<" The message length cb="<<cb<<"u exceeds the max="<<sizeof(request->data.order_review_approve.serialized_msg)<<"u"<<endl;
protocol_protobuf.cpp                TTLOG(INFO,13)<<"DecodeOrderFillUpdateRequest: order_id="<<algo_inst_id<<" text_a="<<text_a<<" text_b="<<text_b<<" text_tt="<<text_tt<<" cb="<<cb<<"u "<<msg.ShortDebugString().to_std()<<endl;
protocol_protobuf.cpp                TTLOG(ERROR,13)<<"DecodeOrderFillUpdateRequest: no changes to any of text fields for order_id="<<algo_inst_id<<". Ignoring OrderFillUpdateRequest"<<endl;
protocol_protobuf.cpp                TTLOG(INFO,13)<<"DecodeOrderFillUpdateRequest: order_id="<<algo_inst_id<<" class_2_change=["<<inbound_class_1_2->ShortDebugString().to_std()<<"] "<<msg.ShortDebugString().to_std()<<endl;
protocol_protobuf.cpp                TTLOG(INFO,13)<<"DecodeOrderFillUpdateRequest: order_id="<<algo_inst_id<<" No class 2 change. "<<msg.ShortDebugString().to_std()<<endl;
protocol_protobuf.cpp    TTLOG(DEBUG,13)<<"L([=]() { return algo[ + algo_inst_id.to_string() + ]: Dumping order_update_msg: "<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"[algo="<<algo_inst_id<<"] order_update_request missing user_id"<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"[algo="<<algo_inst_id<<"] order_update_request has OMA-related info"<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"[algo="<<algo_inst_id<<"] order_update_request reason="<<OrderUpdateReason_Name(reason).to_std()<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"[algo="<<algo_inst_id<<"] order_update_request has no reason"<<endl;
protocol_protobuf.cpp             TTLOG(ERROR,13)<<"[algo="<<algo_inst_id<<"] Order passing initiate - missing (required: curr_user_group_id, pass_to_group_id, curr_user_id)"<<endl;
protocol_protobuf.cpp             TTLOG(ERROR,13)<<"[algo="<<algo_inst_id<<"] Order passing accept - missing (required: curr_user_group_id, curr_user_id)"<<endl;
protocol_protobuf.cpp             TTLOG(ERROR,13)<<"[algo="<<algo_inst_id<<"] Order passing reject - missing (required: curr_user_group_id, curr_user_id)"<<endl;
protocol_protobuf.cpp             TTLOG(ERROR,13)<<"[algo="<<algo_inst_id<<"] Order passing undo - missing (required: curr_user_group_id, curr_user_id)"<<endl;
protocol_protobuf.cpp             TTLOG(ERROR,13)<<"[algo="<<algo_inst_id<<"] Order passing set_child - missing (required: curr_user_group_id, curr_user_id)"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"[algo="<<algo_inst_id<<"] order_update_request=cancel should never come in as a request"<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"[algo="<<algo_inst_id<<"] order_update_request=ORDER_UPDATE_REASON_ORDER_APPROVAL does is missing review_status or review_user_id"<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"[algo="<<algo_inst_id<<"] ORDER_UPDATE_REASON_ORDER_APPROVAL review_status="<<TTSDK_ReviewStatusToString(review_status)<<" review_user_id="<<review_user_id<<"lu"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"[algo="<<algo_inst_id<<"] order_update_request reason="<<OrderUpdateReason_Name(reason).to_std()<<" Not supported!"<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"STAGED: To ExecutionReport SET_staged_account_type="<<stagedAccountType<<endl;
protocol_protobuf.cpp                TTLOG(INFO,13)<<"[algo_inst_id="<<algo_order_id<<"] instrument_id="<<algo_instr_id<<"lu is mapped to so_name="<<so_name<<", which is mapped to SyntheticOrderType="<<tt::messaging::order::enums::SyntheticOrderType_Name(synthTypeEnum).to_std()<<". Using this type for the Execution Report"<<endl;
protocol_protobuf.cpp                TTLOG(WARNING,13)<<"[algo_inst_id="<<algo_order_id<<"] instrument_id="<<algo_instr_id<<"lu is mapped to so_name="<<so_name<<", but so_name is not mapped to any SyntheticOrderType"<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"EncodeExecutionReportInternal: order_id="<<algo_order_id<<" found no class_1_2_fields"<<endl;
protocol_protobuf.cpp                TTLOG(INFO,13)<<"[algo_inst_id="<<algo_order_id<<"] EncodeExecutionReportInternal: fill="<<message.ShortDebugString().to_std()<<endl;
protocol_protobuf.cpp                TTLOG(ERROR,13)<<"[algo_inst_id="<<algo_order_id<<"] EncodeExecutionReportInternal, could not generate ShortDebugString, Exception: "<<reason<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"[algo_inst_id="<<algo_order_id<<"] Delaying fill="<<message.ShortDebugString().to_std()<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<" [algo_inst_id="<<algo_order_id<<"] Encoding ExecutionReport: user_id="<<user_id<<"lu current_user_id="<<algo_params->current_user_id<<"lu account_id="<<connection_id<<"lu broker_id="<<GetBrokerID(algo_params<<"lu order_id="<<connection_id)<<" order_status="<<algo_order_id<<" syn_status=["<<tt::messaging::order::enums::OrdStatus_Name(order_status).to_std()<<"] algoType="<<all_synth_status<<" exec_type="<<TTSDK_ALGO_TYPE_STR[algoType]<<" source="<<tt::messaging::order::enums::ExecType_Name(exec_type).to_std()<<" order_sequence="<<tt::messaging::order::enums::Source_Name(source_enum).to_std()<<"lu synthetic_order_type="<<response_count<<" algoinst_id="<<tt::messaging::order::enums::SyntheticOrderType_Name(synthTypeEnum).to_std()<<"lu side="<<algo_instr_id<<" qty="<<(message.has_side()?tt::messaging::order::enums::Side_Name(message.side()).to_std():"N/A")<<" leaves_qty="<<(message.has_order_qty()?std::to_string(message.order_qty()):"N/A")<<" disp_qty="<<(message.has_leaves_qty()?std::to_string(message.leaves_qty()):"N/A")<<" price="<<(message.has_display_qty()?std::to_string(message.display_qty()):"N/A")<<" stop_price="<<(message.has_price()?std::to_string(message.price()):"N/A")<<" time_in_force="<<(message.has_stop_px()?std::to_string(message.stop_px()):"N/A")<<" user_request_id="<<(message.has_time_in_force()?tt::messaging::order::enums::TimeInForce_Name(message.time_in_force()).to_std():"N/A")<<"lu cl_ord_id="<<user_request_id<<"lu orig_cl_ord_id="<<cl_ord_id<<"lu fix_cl_ord_id="<<orig_cl_ord_id<<" fix_orig_cl_ord_id="<<(message.has_fix_cl_ord_id()?message.fix_cl_ord_id().to_std():"N/A")<<" trade_date="<<(message.has_fix_orig_cl_ord_id()?message.fix_orig_cl_ord_id().to_std():"N/A")<<"lu exec_restatement_reason="<<trade_date<<" organization="<<(message.has_exec_restatement_reason()?tt::messaging::order::enums::ExecRestatementReason_Name(message.exec_restatement_reason()).to_std():"N/A")<<" isFakeExecutionReport="<<(message.has_organization()?message.organization().to_std():"")<<" ["<<isFakeExecutionReport<<"] ["<<prev_exch_order_assoc<<"] //order_passing ["<<has_order_pass?order_pass_info.str():"NoOrderPassing"<<"] //	user parameters review_status="<<(message.has_user_parameters()?UserParametersToString(message.user_parameters()):"")<<" review_user_id="<<(message.has_review_status()?TTSDK_ReviewStatusToString(review_status):"N/A")<<"lu "<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"long_param="<<long_param<<endl;
protocol_protobuf.cpp    TTLOG(DEBUG,13)<<"L([=]() { return std::string([algo_inst_id=) + algo_order_id.to_string() + ] ExecutionReport "<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"EncodeExecutionReportInternal: order_id="<<algo_order_id<<" full_filled or canceled. Queued task to remove cached class_1_2"<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"EncodeOrderCancelRejectInternal: order_id="<<algo_order_id<<" found no class_1_2_fields"<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<"Encoding OrderCancelReject: user_id="<<user_id<<"lu order_id="<<algo_order_id<<" order_status="<<tt::messaging::order::enums::OrdStatus_Name(order_status).to_std()<<" cl_ord_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu fix_cl_ord_id="<<(message.has_fix_cl_ord_id()?message.fix_cl_ord_id().to_std():"N/A")<<" fix_orig_cl_ord_id="<<(message.has_fix_orig_cl_ord_id()?message.fix_orig_cl_ord_id().to_std():"N/A")<<" "<<extra_log_info.str()<<endl;
protocol_protobuf.cpp    TTLOG(DEBUG,13)<<"L([=]() { return std::string([algo_inst_id=) + algo_order_id.to_string() + ] OrderCancelReject "<<endl;
protocol_protobuf.cpp        TTLOG(DEBUG,13)<<"Failed to parse wire header. data_size="<<data_size<<"u"<<endl;
protocol_protobuf.cpp    TTLOG(DEBUG,13)<<"L([=]() { return std::string([algo_inst_id=) + algo_inst_id.to_string() + ] Downloaded ExecutionReport "<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"DecodeDownloadedExecutionReport: get algo order with no synth_status: algo_inst_id="<<algo_inst_id<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<"DecodeDownloadedExecutionReport: [algo="<<algo_inst_id<<"] "<<recovery_info.str()<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<" AlgoServer_EncodeFailure: request=["<<ALGOJOB_REQUEST_ID_STR[request_id]<<"], error="<<ALGOSERVER_ERROR_STR[error]<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"STAGED: To ExecutionReport SET_staged_order_id="<<staged<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<" Encoding AlertExecutionReport: This is a child algo with a parent: order_id="<<algo_order_id<<" parent_order_id="<<parent_order_id_str<<" "<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"algo_params has UNKNOWN AlgoType!"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"algo_params has no AlgoType"<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"STAGED: To ExecutionReport SET_staged_account_type="<<stagedAccountType<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"EncodeExecutionReportInternal: order_id="<<algo_order_id<<" found no class_1_2_fields"<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<"Algo[inst_id="<<algo_order_id<<"] Encoding Alert ER: "<<alert_message<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<"EncodeExportValue order_id="<<algo_order_id<<" "<<side_channel_message.ShortDebugString().to_std()<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<" AlgoServer_EncodeBookieDownloadRequest req_id="<<request_id_string<<", exch_order_assoc="<<algoserver_id<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<"dl_request=["<<protoString.c_str()<<"]"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"AlgoServer_DecodeAndForwardOrderTagDownload: Failed to parse LBM message!"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"AlgoServer_DecodeAndForwardOrderTagDownload: Was expecting [Header::MSG_EXECUTION_REPORT] but received something else!"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"AlgoServer_DecodeAndForwardOrderTagDownload: Failed to parse payload into ER!"<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"AlgoServer_DecodeAndForwardOrderTagDownload: ER is missing the parent_order_id!"<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] AlgoServer_DecodeAndForwardOrderTagDownload: Dumping OTD ER:\n"<<er->ShortDebugString().to_std()<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"Ledger response missing book"<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<"Book downloaded, size="<<book_size<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"AlgoServer_EncodeRecoveryRequest: order_id="<<algo_inst_id<<" found no class_1_2_fields"<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<"AlgoServer_EncodeOrderTagNewOrderSingle: Generating a makeshift child OTD NOS with: order_id="<<order_id_string<<" parent_order_id="<<algo_inst_id_string<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"AlgoServer_EncodeOrderTagNewOrderSingle: Trying to encode non-null terminated account_override string: algo_inst_id="<<algo_inst_id_string<<" value="<<account_overrid<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"AlgoServer_EncodeOrderTagNewOrderSingle: For algo_inst_id="<<algo_inst_id_string<<", dumping the makeshift child OTD NOS:\n"<<toPrint.to_std()<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"AlgoServer_EncodeChildCancel: parent_id="<<parent_id<<" found no class_1_2_fields"<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<"EncodeOrderCancelReject: user_id="<<algo->user_id<<"lu order_id="<<algo->inst_id<<" request="<<ALGOJOB_REQUEST_ID_STR[request.id]<<" "<<endl;
protocol_protobuf.cpp        TTLOG(ERROR,13)<<"EncodeClassOneTwoFields: order_id="<<algo_inst_id<<" found no class_1_2_fields for job_request="<<ALGOJOB_REQUEST_ID_STR[id]<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"EncodeClassOneTwoFields: request="<<ALGOJOB_REQUEST_ID_STR[id]<<" inst_id="<<algo_inst_id<<" class_1_2_fields_size="<<size<<"u too large!!!"<<endl;
protocol_protobuf.cpp            TTLOG(INFO,13)<<"EncodeClassOneTwoFields: request="<<ALGOJOB_REQUEST_ID_STR[id]<<" inst_id="<<algo_inst_id<<" class_1_2_fields_size="<<size<<"u "<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"EncodeClassOneTwoFields: request="<<ALGOJOB_REQUEST_ID_STR[id]<<" inst_id="<<algo_inst_id<<" class_2_size="<<size<<"u too large!!!"<<endl;
protocol_protobuf.cpp            TTLOG(INFO,13)<<"EncodeClassOneTwoFields: request="<<ALGOJOB_REQUEST_ID_STR[id]<<" inst_id="<<algo_inst_id<<" class_2_size="<<size<<"u "<<endl;
protocol_protobuf.cpp    TTLOG(INFO,13)<<"RemoveClassOneTwoFields: order_id="<<algo_order_id<<" "<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"OverrideERAndEncode: order_id="<<algo->inst_id<<" found no class_1_2_fields"<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"[algo_inst_id="<<algo_inst_id<<"]: Cannot get primary_market_id"<<endl;
protocol_protobuf.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] PopulateFill for order_id_on_fill="<<order_id_on_fill<<" order_sequence_on_fill="<<order_sequence_on_fill<<"lu order_sequence_on_er="<<order_sequence_on_er<<"lu primary_market_id="<<primary_market_id<<" "<<endl;
protocol_protobuf.cpp         TTLOG(WARNING,13)<<"[algo_inst_id="<<algo_inst_id<<"] PopulateFill Missing order_id_on_fill="<<order_id<<" order_sequence_on_fill="<<order_sequence_on_fill<<"lu "<<endl;
protocol_protobuf.cpp            TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] PopulateFillsGrp fills_grp_size="<<fills_grp_from_algojob.fills_grp_size()<<"u"<<endl;
protocol_protobuf.cpp            TTLOG(ERROR,13)<<"[algo_inst_id="<<algo_inst_id<<"] PopulateFillsGrp failed"<<endl;
protocol_protobuf.cpp    TTLOG(DEBUG,13)<<"L([=]() { return algo[ + algo_order_id.to_string() + ]: Dumping order_fill_update_resp: "<<endl;
controller.cpp            TTLOG(INFO,13)<<"RetryRecovery "<<msg.str()<<endl;
controller.cpp                TTLOG(INFO,13)<<"Stop retrying after 50"<<endl;
controller.cpp                 TTLOG(ERROR,13)<<error<<endl;
controller.cpp    TTLOG(DEBUG,13)<<"BEFOR DeleteAlgoJobFromMap size="<<mapToAlgoJobData.size()<<", algojob_id="<<algojob_id<<"lu"<<endl;
controller.cpp    TTLOG(DEBUG,13)<<"AFTER DeleteAlgoJobFromMap size="<<mapToAlgoJobData.size()<<", algojob_id="<<algojob_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"[algo_inst_id="<<algo_inst_id<<"] PrepareSyntheticLegInfo: Failed to get instrument error="<<TTSDK_ERROR_STR[error]<<" "<<endl;
controller.cpp        TTLOG(ERROR,13)<<"[algo_inst_id="<<algo_inst_id<<"] PrepareSyntheticLegInfo: DownloadInstrument failed instr_id="<<instr_id<<"lu error="<<to_string(dl_result.first)<<" "<<endl;
controller.cpp        TTLOG(ERROR,13)<<"[algo_inst_id="<<algo_inst_id<<"] PrepareSyntheticLegInfo: invalid instr_id="<<instr_id<<"lu "<<endl;
controller.cpp        TTLOG(WARNING,13)<<"[algo_inst_id="<<algo_inst_id<<"] PrepareSyntheticLegInfo: Downloaded: name="<<instr_data->name<<" no leg."<<endl;
controller.cpp    TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] PrepareSyntheticLegInfo: Downloaded: name="<<instr_data->name<<" leg_size="<<instr_data->legs.size()<<"u"<<endl;
controller.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"] PrepareSyntheticLegInfo: For instrument="<<instr_data->name<<" Add leg info=[instrument_id="<<l.instrument_id<<"lu ratio="<<l.ratio<<".8f cum_qty="<<l.cum_qty<<".8f avg_px=0.0]"<<endl;
controller.cpp    TTLOG(INFO,13)<<"InitAlgoData: Added algo="<<(void*)algo<<" [inst_id="<<algo->inst_id<<", user_id="<<algo->user_id<<"lu, state="<<ALGO_STATE_STR[init_state]<<"] to algojob="<<(void*)algojob<<" [algojob_id="<<algojob->algojob_id<<"lu, pid="<<algojob->pid<<"d connection_established=["<<algojob->flags&connection_established?"Y":"N"<<"] conn_data="<<(void*)(algojob->conn_data)<<" owned_algos: size="<<algojob->owned_algos.size()<<"] "<<endl;
controller.cpp    TTLOG(INFO,13)<<"DestroyAlgoData: algo->inst_id="<<algo->inst_id<<endl;
controller.cpp        TTLOG(INFO,13)<<" DestroyAlgoData: removed algo inst "<<algo->inst_id<<" from algojob "<<(constvoid*)algojob<<"[owned_algos: size="<<algojob->owned_algos.size()<<"d]"<<endl;
controller.cpp    TTLOG(INFO,13)<<" ReportToZK: user_id="<<user_id<<"lu algojob->pid="<<algojob->pid<<"lu count="<<count<<"u "<<endl;
controller.cpp            TTLOG(INFO,13)<<" RESERVED: InitAlgoJobData() user_id="<<user_id<<"lu"<<endl;
controller.cpp        TTLOG(INFO,13)<<"AlgoJobData "<<(void*)algojob<<" [algojob_id="<<algojob_id<<"lu, pid="<<algojob->pid<<"d] created"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"Failed to create algojob_data"<<endl;
controller.cpp        TTLOG(INFO,13)<<"Cancelling child order. inst_id="<<algo->inst_id<<" order_id="<<kvp.first<<endl;
controller.cpp    TTLOG(INFO,13)<<"NoJobKillKids finished for algo="<<algo->inst_id<<", sent_cancel="<<algo->children.size()<<"."<<endl;
controller.cpp    TTLOG(INFO,13)<<" DestroyAlgoJob: "<<(void*)algojob<<" [connection_established="<<algojob->flags&connection_established?"Y":"N"<<", owned_algos="<<algojob->owned_algos.size()<<" queued="<<algojob->queued_requests.size()<<", queued_recovery="<<queued_recovery<<"]"<<endl;
controller.cpp            TTLOG(INFO,13)<<"DestroyAlgoJob: algo="<<algo<<" inst_id="<<algo->inst_id<<" user_id="<<algo->user_id<<"lu current_state="<<ALGO_STATE_STR[algo->state]<<" No recovery Unknown syn_status "<<endl;
controller.cpp            TTLOG(INFO,13)<<"DestroyAlgoJob: algo="<<algo<<" inst_id="<<algo->inst_id<<" user_id="<<algo->user_id<<"lu current_state="<<ALGO_STATE_STR[algo->state]<<" No need to revoery for RECOVERY_FAILED"<<endl;
controller.cpp            TTLOG(INFO,13)<<"DestroyAlgoJob: algo="<<algo<<" inst_id="<<algo->inst_id<<" user_id="<<algo->user_id<<"lu current_state="<<ALGO_STATE_STR[algo->state]<<" created recovery request for current_syn_status="<<SynthStatus_Name(syn_status).to_std()<<" "<<endl;
controller.cpp        TTLOG(WARNING,13)<<"SpawnAlgoJob0: Job0 already exist"<<endl;
controller.cpp        TTLOG(INFO,13)<<"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"<<endl;
controller.cpp        TTLOG(INFO,13)<<"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Job0 pid ="<<job0->pid<<"d !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"<<endl;
controller.cpp        TTLOG(INFO,13)<<"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"xxxxxxxxxxxxxxxxxxxxx Job0 failed to launch xxxxxxxxxxxxxxxxxxxxx"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"fork failed, errno="<<strerror(errno)<<endl;
controller.cpp        TTLOG(INFO,13)<<" Spawned child process for algojob "<<(void*)algojob<<" [algojob_id="<<algojob->algojob_id<<"lu, pid="<<algojob->pid<<"d]"<<endl;
controller.cpp                TTLOG(INFO,13)<<" TrySpawn() Configs, client_server_core_CPU="<<clientServerCoreCPU<<" client_data_core_CPU="<<clientDataCoreCPU<<" client_spin="<<clientSpin<<" client_onload="<<clientOnload<<endl;
controller.cpp                        TTLOG(WARNING,13)<<"Onload is requested for the client (algojob), but is not presently enabled for algoserver. Ignoring the request to enable onload"<<endl;
controller.cpp                TTLOG(ERROR,13)<<" TrySpawn() Generated File Failed, e="<<e.what()<<endl;
controller.cpp            TTLOG(ERROR,13)<<" TrySpawn() SpawnAlgoJob(...) Failed, error="<<ALGOSERVER_ERROR_STR[error]<<endl;
controller.cpp    TTLOG(INFO,13)<<" UpdateAlgo algo_inst_id="<<algo->inst_id<<" from response_id="<<ALGO_RESPONSE_ID_STR[response_id]<<" user_id="<<algo->params.user_id<<"lu current_user_id="<<algo->params.current_user_id<<"lu user_param_count="<<algo->params.count<<endl;
controller.cpp        TTLOG(DEBUG,13)<<"SanitizeAlgoJobResponse fills_grp_size="<<algo_params->fills_grp.fills_grp_size<<"u serialized_size="<<algo_params->fills_grp.struct_size<<"u"<<endl;
controller.cpp    TTLOG(ERROR,13)<<" RespondFailure: request=["<<ALGOJOB_REQUEST_ID_STR[request_id]<<"] user_id="<<user_id<<"lu connection_id="<<connection_id<<"lu inst_id="<<algo_uuid_string<<" market_id="<<market_id<<" response_count="<<response_count<<"lu user_request_id="<<user_request_id<<"lu algo_state="<<ALGO_STATE_STR[state]<<" failure_code=["<<ALGO_REQ_FAILURE_CODE_STR[failure]<<"] request_flags=["<<request_flags&algojob__request_force_success?"force_success":""<<" "<<request_flags&algojob__request_so_algo?"so_algo":""<<" "<<request_flags&algojob__request_recovery_adl_algo?"recovery_adl_algo":""<<"]"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessAlgoJobRequestFailure: For algo="<<ttuuid(response->inst_id)<<", OrderUpdate request="<<ALGOJOB_REQUEST_ID_STR[request_failure.request_id]<<" failed since algo does not exist in Job - no failure ER will be published!"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessAlgoJobRequestFailure: Recovery Request Failed!!! inst_id="<<ttuuid(response->inst_id)<<" failure_code=["<<ALGO_REQ_FAILURE_CODE_STR[request_failure.failure]<<"] request_failure.state=["<<ALGO_STATE_STR[request_failure.state]<<"] algo->state=["<<ALGO_STATE_STR[algo->state]<<"] Run CLI to retry"<<endl;
controller.cpp    TTLOG(ERROR,13)<<"ProcessAlgoJobRequestFailure: request=["<<ALGOJOB_REQUEST_ID_STR[request_failure.request_id]<<"] inst_id="<<ttuuid(response->inst_id)<<" failure_code=["<<ALGO_REQ_FAILURE_CODE_STR[request_failure.failure]<<"] state="<<ALGO_STATE_STR[before]<<"->"<<ALGO_STATE_STR[request_failure.state]<<" flags="<<(int)request_failure.request_flags<<endl;
controller.cpp            TTLOG(INFO,13)<<"Starting or Resuming was interrupted. algojob="<<(void*)algojob<<" state="<<ALGO_STATE_STR[before]<<"->"<<ALGO_STATE_STR[request_complete.state]<<endl;
controller.cpp            TTLOG(INFO,13)<<"Dropping transitional RequestComplete from AlgoJob algojob="<<(void*)algojob<<" state="<<ALGO_STATE_STR[before]<<"->"<<ALGO_STATE_STR[request_complete.state]<<endl;
controller.cpp        TTLOG(ERROR,13)<<"inst_id="<<ttuuid(response->inst_id)<<" Something is not right. We should never be here."<<endl;
controller.cpp    TTLOG(INFO,13)<<"Converting Algojob RequestComplete to Status algojob="<<(void*)algojob<<" state="<<ALGO_STATE_STR[before]<<"->"<<ALGO_STATE_STR[request_complete.state]<<endl;
controller.cpp            TTLOG(ERROR,13)<<"JOB0 reconnecting but job0 exists"<<endl;
controller.cpp            TTLOG(INFO,13)<<"JOB0 reconnected pid="<<job0->pid<<endl;
controller.cpp        TTLOG(ERROR,13)<<"job_id="<<job_id<<"lu not-supported with current design"<<endl;
controller.cpp    TTLOG(INFO,13)<<"AlgoJobData restored with "<<(void*)algojob<<" [algojob_id="<<job_id<<"lu, pid="<<algojob->pid<<"d]"<<endl;
controller.cpp    TTLOG(INFO,13)<<"ProcessAlgoJobInit(), job_id="<<response->job_id<<"lu, user_request_id="<<response->user_request_id<<"lu, response_id="<<ALGO_RESPONSE_ID_STR[response->id]<<endl;
controller.cpp        TTLOG(WARNING,13)<<"***********************************************"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"* Existing job connected, job_id="<<response->job_id<<"llu *"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"***********************************************"<<endl;
controller.cpp            TTLOG(WARNING,13)<<"Can not adopt existing algojob"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"algojob already running for job_id="<<response->job_id<<"lu"<<endl;
controller.cpp    TTLOG(INFO,13)<<" algojob_"<<algojob->algojob_id<<"lu "<<algojob<<" [socket="<<conn_data->ipc_connection->socket<<"] connected."<<endl;
controller.cpp                TTLOG(INFO,13)<<"ProcessAlgoJobStatus: Recovery Request Failed!!! inst_id="<<algo->inst_id<<" reason="<<reason<<" --Run CLI to retry (synth_status will remain unchanged to allow retry)"<<endl;
controller.cpp                TTLOG(INFO,13)<<"ProcessAlgoJobStatus: Recovery Request Failed!!! inst_id="<<algo->inst_id<<" reason="<<reason<<" --Unrecoverable!"<<endl;
controller.cpp                TTLOG(INFO,13)<<"ProcessAlgoJobStatus: Recovery Request Worked!!! inst_id="<<algo->inst_id<<" staus.state="<<ALGO_STATE_STR[status.state]<<" synth_status="<<tt::messaging::order::enums::SynthStatus_Name((tt::messaging::order::enums::SynthStatus)synth_status).to_std()<<" msg="<<reason<<" "<<endl;
controller.cpp            TTLOG(ERROR,13)<<"ProcessAlgoJobStatus: Recovery Request Failed!!! inst_id="<<algo->inst_id<<" response has no synth_status"<<endl;
controller.cpp    TTLOG(INFO,13)<<"ProcessAlgoJobStatus: algo="<<algo->inst_id<<" state="<<ALGO_STATE_STR[before]<<"->"<<ALGO_STATE_STR[status.state]<<endl;
controller.cpp        TTLOG(DEBUG,13)<<"ProcessAlgoJobStatus: algo:"<<algo->inst_id<<" response_count=0 (just came from reconnected job). Skip sending status. State="<<ALGO_STATE_STR[algo->state]<<endl;
controller.cpp        TTLOG(DEBUG,13)<<"ProcessAlgoJobValue: inst_id="<<algo_uuid_string<<", value_type="<<value->type<<", block="<<uuid_block_inst<<", conn="<<uuid_connector_def<<", pathToRoot="<<ossPathToRoot.str()<<", Map.size="<<algo->mapBlockDefValues[(algo->activeIndex)].size()<<", index="<<algo->activeIndex<<endl;
controller.cpp        TTLOG(INFO,13)<<"Found existing algo_inst_id="<<ttuuid(inst_id)<<" . Set seq_num="<<init_seq_num<<"lu and send latest status"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"algo_inst_id="<<ttuuid(inst_id)<<" Can NOT AllocAlgoJobRequestData"<<endl;
controller.cpp            TTLOG(ERROR,13)<<"algo_inst_id="<<ttuuid(inst_id)<<" rejected. user_id="<<user_id<<"ld already has user_sse_algo_count="<<user_sse_algo_count<<" SSE algos running. max_sse_algos_per_user="<<algoserver__max_sse_algos_per_user<<endl;
controller.cpp            TTLOG(ERROR,13)<<"algo_inst_id="<<ttuuid(inst_id)<<" rejected. user_id="<<user_id<<"ld already has user_adl_algo_count="<<user_adl_algo_count<<" ADL algos running. max_adl_algos_per_user="<<algoserver__max_adl_algos_per_user<<endl;
controller.cpp        TTLOG(ERROR,13)<<"algo_inst_id="<<ttuuid(inst_id)<<" Can NOT InitAlgoData"<<endl;
controller.cpp        TTLOG(INFO,13)<<"algo_inst_id="<<ttuuid(algo->inst_id)<<" user_id="<<algo->user_id<<"ld params.algo_type="<<TTSDK_ALGO_TYPE_STR[algo->params.algo_type]<<" state="<<ALGO_STATE_STR[algo->state]<<endl;
controller.cpp            TTLOG(INFO,13)<<"ProcessQueuedRequests: algojob "<<static_cast<void*>(algojob)<<" not connected yet so deferring all queued requests!"<<endl;
controller.cpp                TTLOG(INFO,13)<<"ProcessQueuedRequests: Defer sending this queued request - we need to start a (late) download of USER info: algo_instance_id="<<algo_instance_id<<" algojob="<<static_cast<void*>(algojob)<<" user_request_id="<<request_data->request.user_request_id<<"lu user_id="<<request_data->request.user_id<<"lu originating_user_id="<<request_data->request.params.originating_user_id<<"lu "<<endl;
controller.cpp                            TTLOG(INFO,13)<<"ProcessQueuedRequests: Defer sending this queued request - we need to wait for download of ORDER TAGS to resolve: algo_instance_id="<<algo_instance_id<<" algojob="<<static_cast<void*>(algojob)<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp                        TTLOG(INFO,13)<<"ProcessQueuedRequests: Defer sending this queued request - we need to wait for download of RISK LIMITS to resolve: algo_instance_id="<<algo_instance_id<<" algojob="<<static_cast<void*>(algojob)<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp                        TTLOG(ERROR,13)<<"ProcessQueuedRequests: Dropping this queued request - failed to start async download of Aggregated Instrument Risk Limits: algo_instance_id="<<algo_instance_id<<" algojob="<<static_cast<void*>(algojob)<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp                    TTLOG(INFO,13)<<"ProcessQueuedRequests: Defer sending this queued request - we need to wait for download of USER info to resolve: algo_instance_id="<<algo_instance_id<<" algojob="<<static_cast<void*>(algojob)<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp                        TTLOG(ERROR,13)<<"ProcessQueuedRequests: Failing this algo instance queued for start/recovery: reason="<<failure_reason<<" algo_instance_id="<<algo_instance_id<<" algojob="<<static_cast<void*>(algojob)<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp                    TTLOG(WARNING,13)<<"ProcessQueuedRequests: Failed to download TTUS User Info but sending the request to Job anyway: reason="<<failure_reason<<" algo_instance_id="<<algo_instance_id<<" algojob="<<static_cast<void*>(algojob)<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp            TTLOG(INFO,13)<<"ProcessQueuedRequests: Send this queued request to algojob: algo_instance_id="<<algo_instance_id<<" algojob="<<static_cast<void*>(algojob)<<" user_request_id="<<request_data->request.user_request_id<<"lu "<<endl;
controller.cpp                TTLOG(ERROR,13)<<"ProcessQueuedRequests: Failure forwarding this queued request to algojob: algo_instance_id="<<algo_instance_id<<" algojob="<<static_cast<void*>(algojob)<<" user_request_id="<<request_data->request.user_request_id<<"lu error="<<error<<" "<<endl;
controller.cpp                    TTLOG(ERROR,13)<<"ProcessQueuedRequests: Failure forwarding variable data to algojob: algo_instance_id="<<algo_instance_id<<" algojob="<<								static_cast<void*>(algojob)<<" user_request_id="<<request_data->request.user_request_id<<"lu error="<<error<<" "<<endl;
controller.cpp            TTLOG(INFO,13)<<"ProcessQueuedRequests: for algojob_id="<<algojob->algojob_id<<"lu: processed="<<processedCount<<" skipped="<<skippedCount<<endl;
controller.cpp            TTLOG(INFO,13)<<"MarshalClassOneTwoFields: request="<<ALGOJOB_REQUEST_ID_STR[id]<<" user_request_id="<<user_request_id<<"lu inst_id="<<ttuuid(request_data->request.inst_id)<<" "<<algo_params==nullptr?"algo_paramsisnull":"requesthasnoclass_1_2"<<endl;
controller.cpp    TTLOG(INFO,13)<<" Queued request for algojob "<<(void*)algojob<<", user_id="<<user_id<<"lu, request_id="<<ALGOJOB_REQUEST_ID_STR[request->id]<<", user_request_id="<<user_request_id<<"lu"<<endl;
controller.cpp                TTLOG(INFO,13)<<"ProcessRecoveryRequest: There is still job reconnecting. Requeue this recovery request. user_request_id="<<algoserver_request.user_request_id<<"lu, user_id="<<user_id<<"lu reconnecting_jobs="<<reconnecting_jobs<<endl;
controller.cpp        TTLOG(INFO,13)<<"No need to recover: Algo inst exists. user_request_id="<<algoserver_request.user_request_id<<"lu, user_id="<<user_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessRecoveryRequest: Error="<<ALGOSERVER_ERROR_STR[error]<<", user_request_id="<<algoserver_request.user_request_id<<"lu, user_id="<<user_id<<"lu "<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessRecoveryRequest: user_request_id="<<algoserver_request.user_request_id<<"lu, algo_inst_id="<<algo->inst_id<<". Recovery Succeed for Held/Paused SSE Algo"<<endl;
controller.cpp         TTLOG(ERROR,13)<<"ProcessRecoveryRequest: user_request_id="<<algoserver_request.user_request_id<<"lu, user_id="<<user_id<<"lu order_id="<<order_id<<" Skip recovery for TT Algo SDK order"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessRecoveryRequest: user_request_id="<<algoserver_request.user_request_id<<"lu, user_id="<<user_id<<"lu order_id="<<order_id<<" RenewTokenUponRecovery failed. But will continue Recovery"<<endl;
controller.cpp        TTLOG(INFO,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: Skip download since request is not deploy_instr: inst_id="<<algo_instance_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp    TTLOG(INFO,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: originating_user_id="<<request_data->request.params.originating_user_id<<"lu user_id="<<request_data->request.user_id<<"lu effective_user_id="<<effective_user_id<<"lu"<<endl;
controller.cpp        TTLOG(INFO,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: Skip download since USER's COMPANY has not opted for Algo Risk Checks: inst_id="<<algo_instance_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp        TTLOG(INFO,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: Skip download since this algo is NOT an SSE algo type: inst_id="<<algo_instance_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: User ID missing! inst_id="<<algo_instance_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: Order instrument ID missing! inst_id="<<algo_instance_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: Account ID missing! inst_id="<<algo_instance_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp        TTLOG(INFO,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: Download required! Cache is absent. inst_id="<<algo_instance_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp            TTLOG(INFO,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: Exempt! Instrument is synthetic. inst_id="<<algo_instance_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp            TTLOG(INFO,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: Download pending! inst_id="<<algo_instance_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp                TTLOG(INFO,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: Download required! Cache is stale. cache_age_in_seconds="<<static_cast<longlongint>(cache_age_in_seconds)<<"ld cache_age_in_minutes="<<static_cast<longlongint>(cache_age_in_minutes)<<"ld inst_id="<<algo_instance_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp                    TTLOG(ERROR,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: Failure! Cache is recent but last download was a failure! cache_age_in_seconds="<<static_cast<longlongint>(cache_age_in_seconds)<<"ld cache_age_in_minutes="<<static_cast<longlongint>(cache_age_in_minutes)<<"ld inst_id="<<algo_instance_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp                    TTLOG(INFO,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: No download required! Cache is recent and last download was a success! cache_age_in_seconds="<<static_cast<longlongint>(cache_age_in_seconds)<<"ld cache_age_in_minutes="<<static_cast<longlongint>(cache_age_in_minutes)<<"ld inst_id="<<algo_instance_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp        TTLOG(INFO,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: Using Risk Limits Cache: inst_id="<<algo_instance_id<<" user_request_id="<<request_data->request.user_request_id<<"lu pdci_one_min_ticks="<<cache_ptr->risk_limits.pdci_one_min_ticks<<" pdci_one_min_pct="<<cache_ptr->risk_limits.pdci_one_min_pct<<" pdci_three_min_ticks="<<cache_ptr->risk_limits.pdci_three_min_ticks<<" pdci_three_min_pct="<<cache_ptr->risk_limits.pdci_three_min_pct<<" pdci_lifetime_ticks="<<cache_ptr->risk_limits.pdci_lifetime_ticks<<" pdci_lifetime_pct="<<cache_ptr->risk_limits.pdci_lifetime_pct<<" spdci_one_min_ticks="<<cache_ptr->risk_limits.spdci_one_min_ticks<<" spdci_one_min_pct="<<cache_ptr->risk_limits.spdci_one_min_pct<<" spdci_three_min_ticks="<<cache_ptr->risk_limits.spdci_three_min_ticks<<" spdci_three_min_pct="<<cache_ptr->risk_limits.spdci_three_min_pct<<" spdci_lifetime_ticks="<<cache_ptr->risk_limits.spdci_lifetime_ticks<<" spdci_lifetime_pct="<<cache_ptr->risk_limits.spdci_lifetime_pct<<" max_child_slice_size="<<cache_ptr->risk_limits.max_child_slice_size<<" max_number_of_cancels="<<cache_ptr->risk_limits.max_number_of_cancels<<" max_number_of_updates="<<cache_ptr->risk_limits.max_number_of_updates<<" is_spread_or_strategy="<<cache_ptr->risk_limits.is_spread_or_strategy<<endl;
controller.cpp        TTLOG(ERROR,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: Failed to start async download! inst_id="<<algo_instance_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp    TTLOG(INFO,13)<<"MaybeDownloadAggregatedInstrumentRiskLimits: Started async download and download is now pending! inst_id="<<algo_instance_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"algo_inst_id="<<ttuuid(algoserver_request.inst_id)<<" is missing algo_instr_id in its params!"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"algo_inst_id="<<ttuuid(algoserver_request.inst_id)<<" Can NOT AllocAlgoJobRequestData"<<endl;
controller.cpp        TTLOG(ERROR,13)<<" ProcessDeployInstrRequest: Error="<<ALGOSERVER_ERROR_STR[error]<<", user_request_id="<<algoserver_request.user_request_id<<"lu user_id="<<algoserver_request.user_id<<"lu "<<endl;
controller.cpp        TTLOG(ERROR,13)<<" ProcessResumeRequest: Error="<<ALGOSERVER_ERROR_STR[error]<<", user_request_id="<<algoserver_request.user_request_id<<"lu"<<endl;
controller.cpp        TTLOG(INFO,13)<<"ProcessResumeRequest: Setting [has_class_1_2_fields] to TRUE for: inst_id="<<ttuuid(algoserver_request.inst_id)<<" user_request_id="<<algoserver_request.user_request_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessPauseRequest: Error="<<ALGOSERVER_ERROR_STR[error]<<", user_request_id="<<algoserver_request.user_request_id<<"lu"<<endl;
controller.cpp        TTLOG(WARNING,13)<<" ProcessStopRequest: Error="<<ALGOSERVER_ERROR_STR[error]<<", user_request_id="<<algoserver_request.user_request_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessUpdateRequest: Error="<<ALGOSERVER_ERROR_STR[error]<<", user_request_id="<<algoserver_request.user_request_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<" ProcessRegisterSideChannelRequest: Error="<<ALGOSERVER_ERROR_STR[error]<<". user_request_id="<<algoserver_request.user_request_id<<"lu, user_id="<<algoserver_request.user_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<" ProcessUnregisterSideChannelRequest: Error="<<ALGOSERVER_ERROR_STR[error]<<". user_request_id="<<algoserver_request.user_request_id<<"lu, user_id="<<algoserver_request.user_id<<"lu"<<endl;
controller.cpp        TTLOG(DEBUG,13)<<" ProcessParamSnapshotRequest: Error="<<ALGOSERVER_ERROR_STR[error]<<", user_request_id="<<algoserver_request.user_request_id<<"lu, user_id="<<algoserver_request.user_id<<"lu"<<endl;
controller.cpp        TTLOG(DEBUG,13)<<"ProcessParamSnapshotRequest: Algo has no export value"<<endl;
controller.cpp    TTLOG(INFO,13)<<" ProcessHandleUserDisconnectReq: user_request_id="<<handle_disconnect_request.user_request_id<<"lu, user_id="<<handle_disconnect_request.user_id<<"lu algojob="<<algojob->algojob_id<<"lu"<<endl;
controller.cpp    TTLOG(INFO,13)<<" ProcessSetOMAParentIdRequest: user_request_id="<<request_data->request.user_request_id<<"lu, user_id="<<request_data->request.user_id<<"lu algojob="<<algojob->algojob_id<<"lu"<<endl;
controller.cpp    TTLOG(INFO,13)<<" ProcessClearOMAParentIdRequest: user_request_id="<<request_data->request.user_request_id<<"lu, user_id="<<request_data->request.user_id<<"lu algojob="<<algojob->algojob_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"SendUserToAllJobs: Download for user_id="<<user_id<<"lu failed!"<<endl;
controller.cpp            TTLOG(INFO,13)<<"SendUserToAllJobs: user_id="<<user_id<<"lu, algo_job_id="<<pair.first<<"lu has NULL algojob"<<endl;
controller.cpp            TTLOG(INFO,13)<<" SendUserToAllJobs: user_id="<<user_id<<"lu, but algojob "<<algojob<<" not connection_established. Skip this call"<<endl;
controller.cpp    TTLOG(INFO,13)<<"SendUserToAllJobs: Download for user_id="<<user_id<<"lu completed!"<<endl;
controller.cpp                    TTLOG(ERROR,13)<<"CheckCompanyNeedSynLegFill: algo_inst_id="<<ttuuid(request.inst_id)<<" not found"<<endl;
controller.cpp            TTLOG(ERROR,13)<<"["<<algo_uuid_string<<"]: Account ID missing!"<<endl;
controller.cpp                TTLOG(ERROR,13)<<"["<<algo_uuid_string<<"]: Could not find organization for account_id="<<account_id<<"lu user_id="<<user_id<<"lu. This is expected if this is the first algo for this user_id"<<endl;
controller.cpp                TTLOG(INFO,13)<<"["<<algo_uuid_string<<"]: account_id="<<account_id<<"lu user_id="<<user_id<<"lu organization=["<<organization_str<<"]"<<endl;
controller.cpp                    TTLOG(ERROR,13)<<"CheckUserOrganization: algo_inst_id="<<ttuuid(request.inst_id)<<" not found"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"SendUserUpdateToAlgoJob: TTUSWeb::Instance().GetUser() failed. user_id="<<user_id<<"lu."<<endl;
controller.cpp        TTLOG(ERROR,13)<<"SendUserUpdateToAlgoJob: Failed to send update_user [user_id="<<user_id<<"lu] to algojob "<<algojob<<endl;
controller.cpp        TTLOG(INFO,13)<<"SendUserUpdateToAlgoJob: Sent update_user [user_id="<<user_id<<"lu] to algojob "<<algojob<<endl;
controller.cpp            TTLOG(ERROR,13)<<"SendAppTokenToAllJobs: algo_job_id="<<pair.first<<"lu is a nullptr - skipping"<<endl;
controller.cpp            TTLOG(ERROR,13)<<"SendAppTokenToAllJobs: algojob="<<algojob<<" has not yet established connection - skipping"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"SendAppTokenToJob: algojob ptr was unexpectedly a nullptr!"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"SendAppTokenToJob: algojob="<<algojob<<" has not yet established connection!"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"SendAppTokenToJob: Failed to send update_app_token to algojob "<<algojob<<endl;
controller.cpp    TTLOG(INFO,13)<<"SendAppTokenToJob: Sent update_app_token to algojob "<<algojob<<endl;
controller.cpp        TTLOG(INFO,13)<<"Tracking child. inst_id="<<algo->inst_id<<" order_id="<<child_id<<endl;
controller.cpp            TTLOG(INFO,13)<<"Untracking child. inst_id="<<algo->inst_id<<" order_id="<<child_id<<endl;
controller.cpp        TTLOG(INFO,13)<<"DownloadOrderTagDefaults: OTD download is not required for algo_inst_id="<<algo_inst_id<<" because OTD feature is disabled on the current server"<<endl;
controller.cpp        TTLOG(INFO,13)<<"DownloadOrderTagDefaults: OTD download is not required for algo_inst_id="<<algo_inst_id<<" because it's not an SSE algo"<<endl;
controller.cpp        TTLOG(INFO,13)<<"DownloadOrderTagDefaults: OTD download is not required for algo_inst_id="<<algo_inst_id<<" because this is algoserver_debug"<<endl;
controller.cpp        TTLOG(INFO,13)<<"DownloadOrderTagDefaults: OTD download is not required for algo_inst_id="<<algo_inst_id<<" because this algo instance is recovering (it should use OTDs downloaded in its former life)"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"DownloadOrderTagDefaults: OTD download is not required for algo_inst_id="<<algo_inst_id<<" because primary_market_id is missing"<<endl;
controller.cpp        TTLOG(INFO,13)<<"DownloadOrderTagDefaults: OTD download is not required for algo_inst_id="<<algo_inst_id<<" because primary_market_id is synthetic"<<endl;
controller.cpp        TTLOG(INFO,13)<<"DownloadOrderTagDefaults: OTD download is not required for algo_inst_id="<<algo_inst_id<<" because it is driving an ASE/AGG instrument"<<endl;
controller.cpp        TTLOG(INFO,13)<<"DownloadOrderTagDefaults: OTD download is not required for algo_inst_id="<<algo_inst_id<<" because it is driving an ASE/AGG instrument"<<endl;
controller.cpp        TTLOG(DEBUG,13)<<"DownloadOrderTagDefaults: Download is not required for algo_inst_id="<<algo_inst_id<<" because download is already pending, or, OTD's have been downloaded and are waiting in IPC queue to be sent to job"<<endl;
controller.cpp    TTLOG(INFO,13)<<"DownloadOrderTagDefaults: Attempting to send OTD NOS for algo_inst_id="<<algo_inst_id<<"..."<<endl;
controller.cpp        TTLOG(WARNING,13)<<"DownloadOrderTagDefaults: Failed to send OTD NOS for algo_inst_id="<<algo_inst_id<<"! This error is not fatal - continuing without OTDs!"<<endl;
controller.cpp    TTLOG(INFO,13)<<"DownloadOrderTagDefaults: Sent OTD NOS for algo_inst_id="<<algo_inst_id<<" and awaiting response!"<<endl;
controller.cpp        TTLOG(INFO,13)<<"ProcessRequest: Drop requet="<<ALGOJOB_REQUEST_ID_STR[request.id]<<" for recovering algo="<<ttuuid(request.inst_id)<<endl;
controller.cpp            TTLOG(INFO,13)<<"RESERVED: ProcessRequest() user_id="<<request.user_id<<"lu, job_id="<<algojob->algojob_id<<", reserved="<<algojob->reserved<<", algojob->uid="<<algojob->user_id<<"lu, owned_algos="<<algojob->owned_algos.size()<<endl;
controller.cpp                    TTLOG(ERROR,13)<<"failed to process algojob__request_handle_user_disconnect: user_id="<<request.user_id<<"lu error=algoserver__error_memory_alloc"<<endl;
controller.cpp            TTLOG(INFO,13)<<"ProcessRequest: Received TRIAGE CLI Cmd!"<<endl;
controller.cpp                TTLOG(ERROR,13)<<"ProcessRequest: Params on the request are incomplete and we couldn't find the algo! Skip sending failure OrderCancelReject for: algo="<<ttuuid(request.inst_id)<<" request="<<ALGOJOB_REQUEST_ID_STR[request.id]<<endl;
controller.cpp            TTLOG(ERROR,13)<<"ProcessRequest: ProcessOrderReviewApproveViaUpdate failed! Sending failure OrderCancelReject for: algo="<<ttuuid(request.inst_id)<<" request="<<ALGOJOB_REQUEST_ID_STR[request.id]<<endl;
controller.cpp            TTLOG(INFO,13)<<"ProcessRequest: This request is trivial and doesn't require a failure response. Skip sending failure ER for: algo="<<ttuuid(request.inst_id)<<" request="<<ALGOJOB_REQUEST_ID_STR[request.id]<<endl;
controller.cpp                TTLOG(ERROR,13)<<"Error processing disconnect"<<endl;
controller.cpp            TTLOG(WARNING,13)<<"ProcessDisconnectCommand connection_id="<<algo->connection_id<<"lu sending STOP to [algo="<<algo->inst_id<<"]"<<endl;
controller.cpp                TTLOG(WARNING,13)<<"[algo_inst_id="<<algo->inst_id<<"]: Skip Cleanup"<<endl;
controller.cpp                TTLOG(INFO,13)<<"TryAlgoCleanup: Algo stopped: algo->inst_id="<<algo->inst_id<<" "<<endl;
controller.cpp    TTLOG(INFO,13)<<"New algojob connected [client_connection->socket="<<client_connection->socket<<"]. Add connection_data="<<conn_data<<" to s_connections"<<endl;
controller.cpp                TTLOG(WARNING,13)<<"JOB0 disconnected. Respawning...."<<endl;
controller.cpp                TTLOG(WARNING,13)<<"DestroyClient can not found algojob="<<algojob<<"."<<endl;
controller.cpp        TTLOG(INFO,13)<<"DestroyClient: Found algojob_id="<<algojob->algojob_id<<"lu"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"DestroyClient: Remove connection_data="<<conn_data<<" from s_connections"<<endl;
controller.cpp            TTLOG(INFO,13)<<"CheckOrderTagDownloadTimeouts: Order Tag download timed out: algo_inst_id="<<algo_inst_ttuuid<<" request_time_ns="<<request_time<<"lu"<<endl;
controller.cpp                TTLOG(INFO,13)<<"CheckJob:PeriodicTask: found RUNNING dead Algojob ["<<dead_pid<<"]"<<endl;
controller.cpp                    TTLOG(ERROR,13)<<"CheckJob:PeriodicTask: GetJobProcessStatus failed. Will try on next attempt"<<endl;
controller.cpp            TTLOG(INFO,13)<<"CheckJob:PeriodicTask: found stale Algojob process. stale_jobs="<<std::to_string(stale_jobs)<<" status="<<std::to_string(status)<<endl;
controller.cpp        TTLOG(INFO,13)<<"HandleRemoveClassOneTwo: algo_inst_id="<<ttuuid(algo_inst_id)<<". Skip due to generate_synthetic_leg_fill"<<endl;
controller.cpp        TTLOG(DEBUG,13)<<" process response from algojob "<<(void*)algojob<<" response->id=["<<ALGO_RESPONSE_ID_STR[*id]<<"]"<<endl;
controller.cpp                    TTLOG(ERROR,13)<<"Failed to get algo_instr_Id, can not re-populate inst_id="<<tt::algoutil::ttuuid(response->inst_id)<<endl;
controller.cpp                    TTLOG(ERROR,13)<<"Failed to recreate algo from snapshot"<<endl;
controller.cpp                    TTLOG(INFO,13)<<"Recreated [algo:"<<reconn_algo->inst_id<<"]: algo_instr_Id="<<reconn_algo->instr_id<<"lu, user_id="<<reconn_algo->user_id<<"lu. state="<<ALGO_STATE_STR[reconn_algo->state]<<" algo_type="<<TTSDK_ALGO_TYPE_STR[response->params.algo_type]<<endl;
controller.cpp            TTLOG(INFO,13)<<"Algojob_"<<response->job_id<<"lu has finished sending snapshot of algos"<<endl;
controller.cpp            TTLOG(INFO,13)<<"Algojob_"<<response->job_id<<"lu received LOOPBACK order request, size="<<response->data.loopback_order_request.payload_size<<endl;
controller.cpp                    TTLOG(ERROR,13)<<"!! Error !! Failure processing LOOPBACK data ["<<error<<"]"<<endl;
controller.cpp            TTLOG(ERROR,13)<<"ProcessClientRequest: unknown response->id="<<(int)response->id<<" "<<endl;
controller.cpp        TTLOG(ERROR,13)<<" Error["<<ALGOSERVER_ERROR_STR[error]<<"] while processing algojob response=["<<ALGO_RESPONSE_ID_STR[*id]<<"]"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"***********************************************"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"* Killing Algojob_"<<algojob->algojob_id<<"lu result="<<ret<<" *"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"***********************************************"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"***********************************************"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"* Killing JOB0 result="<<ret<<" *"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"***********************************************"<<endl;
controller.cpp    TTLOG(INFO,13)<<"HOW BAD IS sizeof(ttsdk_params_internal)="<<sizeof(ttsdk_params_internal)<<endl;
controller.cpp    TTLOG(INFO,13)<<"HOW BAD IS sizeof(algojob__request)="<<sizeof(algojob__request)<<endl;
controller.cpp    TTLOG(INFO,13)<<"HOW BAD IS sizeof(algoserver__request)="<<sizeof(algoserver__request)<<endl;
controller.cpp    TTLOG(INFO,13)<<"HOW BAD IS sizeof(user_obj)="<<sizeof(user_obj)<<endl;
controller.cpp    TTLOG(INFO,13)<<"ConfigXml: algojob_bin="<<algojob_bin<<endl;
controller.cpp    TTLOG(INFO,13)<<"ConfigXml: algojob_bin_prefix="<<algojob_bin_prefix<<endl;
controller.cpp    TTLOG(INFO,13)<<"ConfigXml: algojob_user="<<algojob_user<<endl;
controller.cpp    TTLOG(INFO,13)<<"Exiting! mapToAlgoJobData.size="<<mapToAlgoJobData.size()<<endl;
controller.cpp                TTLOG(INFO,13)<<"RequestDownloadUser: Nothing to do since download_status="<<status==user_info_download_status::completed?"completed":"pending"<<" for user_id="<<user_id<<"lu"<<endl;
controller.cpp            TTLOG(INFO,13)<<"RequestDownloadUser: Attempting new download since download_status=failed for user_id="<<user_id<<"lu"<<endl;
controller.cpp            TTLOG(INFO,13)<<"RequestDownloadUser: Server is remote so setting download_status=completed for user_id="<<user_id<<"lu"<<endl;
controller.cpp        TTLOG(INFO,13)<<"RequestDownloadUser: Starting async download for user_id="<<user_id<<"lu onto TTUS Worker Thread..."<<endl;
controller.cpp            TTLOG(INFO,13)<<"RequestDownloadUser: Async download is now pending for user_id="<<user_id<<"lu"<<endl;
controller.cpp            TTLOG(ERROR,13)<<"RequestDownloadUser Async download failed to start for user_id="<<user_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"Check_Job1: GetJobProcessStatus failed. Will sleep 2 sec to allow exsting job to reconnect. cmd=\"<<status.cmd<<"\"<<endl;
controller.cpp        TTLOG(INFO,13)<<"Check_Job1: "<<result<<". cmd=\"<<status.cmd<<"\"<<endl;
controller.cpp            TTLOG(INFO,13)<<"Check_Job1:CmdOutput: "<<data<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessOrderFillUpdate: Algo not found. inst_id="<<ttuuid(request.inst_id)<<endl;
controller.cpp    TTLOG(INFO,13)<<"ProcessOrderFillUpdate: inst_id="<<algo->inst_id<<" cl_ord_id="<<user_request_id<<"lu user_request_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu "<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessOrderPass: Failed with error=Algojob not found (inst_id="<<ttuuid(algoserver_request.inst_id)<<")"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessOrderPass: Failed with error=Algo not found (inst_id="<<ttuuid(algoserver_request.inst_id)<<")"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessOrderPass: Failed with error="<<error<<" (inst_id="<<ttuuid(algoserver_request.inst_id)<<")"<<endl;
controller.cpp    TTLOG(INFO,13)<<"ProcessOrderPass: Sending OBP request (user_request_id="<<request_data->request.user_request_id<<"lu, user_id="<<request_data->request.user_id<<"lu) to algojob="<<algojob->algojob_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessOrderReviewApproveViaUpdate: Algo not found. inst_id="<<ttuuid(algoserver_request.inst_id)<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessOrderReviewApproveViaUpdate: algo:"<<algo->inst_id<<" missing review_status or review_user_id"<<endl;
controller.cpp    TTLOG(INFO,13)<<"ProcessOrderReviewApproveViaUpdate: inst_id="<<algo->inst_id<<" review_status="<<TTSDK_ReviewStatusToString(new_review_status)<<" review_user_id="<<new_review_user_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessOrderReviewApproveViaUpdate: Error="<<ALGOSERVER_ERROR_STR[algoserver__error_memory_alloc]<<", user_request_id="<<algoserver_request.user_request_id<<"lu"<<endl;
controller.cpp    TTLOG(INFO,13)<<" ProcessOrderReviewApproveViaUpdate: user_request_id="<<request_data->request.user_request_id<<"lu, user_id="<<request_data->request.user_id<<"lu algojob="<<algojob->algojob_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessOrderReviewApproveViaFillUpdate: Not allowed for currently working algos. inst_id="<<ttuuid(algoserver_request.inst_id)<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessTextUpdateViaFillUpdate: Not allowed for currently working algos. inst_id="<<ttuuid(algoserver_request.inst_id)<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessDeployHeldOrder: Error="<<ALGOSERVER_ERROR_STR[error]<<", user_request_id="<<request.user_request_id<<"lu user_id="<<request.user_id<<"lu "<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessDeployHeldOrder: algo_inst_id="<<algo->inst_id<<" user_request_id="<<request.user_request_id<<"lu user_id="<<request.user_id<<"lu Only SSE can be placed as HELD"<<endl;
controller.cpp    TTLOG(INFO,13)<<"ProcessRequestToHeldOrder: request="<<ALGOJOB_REQUEST_ID_STR[request.id]<<", user_request_id="<<request.user_request_id<<"lu algo_inst_id="<<algo->inst_id<<endl;
controller.cpp            TTLOG(ERROR,13)<<"ProcessRequestToHeldOrder: Request failed! request="<<ALGOJOB_REQUEST_ID_STR[request.id]<<", user_request_id="<<request.user_request_id<<"lu algo_inst_id="<<algo->inst_id<<endl;
controller.cpp        TTLOG(WARNING,13)<<"ProcessRequestToHeldOrder: Drop request="<<ALGOJOB_REQUEST_ID_STR[request.id]<<" user_request_id="<<request.user_request_id<<"lu SSE algo="<<algo->inst_id<<endl;
controller.cpp    TTLOG(INFO,13)<<"ProcessRequestToPausedOrder: request="<<ALGOJOB_REQUEST_ID_STR[request.id]<<", user_request_id="<<request.user_request_id<<"lu algo_inst_id="<<algo->inst_id<<endl;
controller.cpp        TTLOG(INFO,13)<<"ProcessRequestToPausedOrder: Converting stop request into a special request to resume first and then cancel immediately afterwards: user_request_id="<<request.user_request_id<<"lu algo_inst_id="<<algo->inst_id<<endl;
controller.cpp        TTLOG(WARNING,13)<<"ProcessRequestToPausedOrder: Drop request="<<ALGOJOB_REQUEST_ID_STR[request.id]<<" user_request_id="<<request.user_request_id<<"lu SSE algo="<<algo->inst_id<<endl;
controller.cpp    TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"]: ProcessDelayedFill: for child_order_id="<<child_order_id<<" child_order_seq="<<child_order_seq<<"lu count="<<count<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"[algo_inst_id="<<algo_inst_id<<"]: ProcessDelayedFill: Failed to find algo for child_order_id="<<child_order_id<<" child_order_seq="<<child_order_seq<<"lu"<<endl;
controller.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"]: Send delayed_fill="<<er->ShortDebugString().to_std()<<" should_generate_synthetic_leg_fill become false"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"[algo_inst_id="<<algo_inst_id<<"]: Cannot get primary_market_id"<<endl;
controller.cpp            TTLOG(ERROR,13)<<"[algo_inst_id="<<algo_inst_id<<"]: Drop delayed_fill , child_order_id="<<child_order_id<<" child_order_seq="<<child_order_seq<<"lu count="<<count<<"lu"<<endl;
controller.cpp            TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"]: Requeue delayed_fill , child_order_id="<<child_order_id<<" child_order_seq="<<child_order_seq<<"lu count="<<count<<"lu"<<endl;
controller.cpp    TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"]: er successfully augmented! Send delayed_fill="<<er->ShortDebugString().to_std()<<" "<<endl;
controller.cpp        TTLOG(ERROR,13)<<"[algo_inst_id="<<algo_inst_id<<"]: ProcessChildFill: Failed to find algo for order_id="<<order_id_string<<endl;
controller.cpp            TTLOG(WARNING,13)<<"[algo_inst_id="<<algo_inst_id<<"]: ProcessChildFill: Skip synthetic_order_type="<<TTSDK_ORDER_SYNTHETIC_TYPE_STR[synthetic_order_type]<<endl;
controller.cpp        TTLOG(WARNING,13)<<"[algo_inst_id="<<algo_inst_id<<"]: ProcessChildFill: algo has parent_order_id="<<ttuuid(parent_order_id)<<". Must be child of OCO."<<endl;
controller.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"]: ProcessChildFill: spread fill! Cache and wait for job fill (either come in soon or requeued through ProcessDelayedFill reporting_type="<<MultiLegReportingType_Name(child_fill->multi_leg_reporting_type()).to_std().substr(MULTI_LEG_REPORTING_TYPE_PREFIX_SIZE)<<" order_sequence="<<seq<<"lu order_id="<<order_id_string<<" total_expected_qty_across_legs_per_lot="<<cached_native_spread_fill.total_expected_qty_across_legs_per_lot<<".8f native_spread_fills_received.size="<<algo->native_spread_fills_received.size()<<"u "<<endl;
controller.cpp        TTLOG(ERROR,13)<<"[algo_inst_id="<<algo_inst_id<<"]: ProcessChildFill failed to find spread fill order_id="<<order_id_string<<" seq="<<seq<<"lu "<<endl;
controller.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"]: ProcessChildFill: Add leg fill! reporting_type="<<MultiLegReportingType_Name(child_fill->multi_leg_reporting_type()).to_std().substr(MULTI_LEG_REPORTING_TYPE_PREFIX_SIZE)<<" order_sequence="<<seq<<"lu order_id="<<order_id_string<<" instrument_id="<<child_fill->instrument_id()<<"lu last_qty="<<child_fill->last_qty()<<".8f synthetic_fills_sent.size="<<algo->synthetic_fills_sent.size()<<"u "<<endl;
controller.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"]: ProcessChildFill: Algo already sent spread_fill [order_sequence="<<seq<<"lu order_id="<<order_id_string<<"] with cached_native_spread_fill.algo_er_sequence="<<cached_native_spread_fill.algo_er_sequence<<"lu head_sent="<<head_sent<<" total_sent="<<cached_native_spread_fill.total_sent<<"lu "<<endl;
controller.cpp            TTLOG(ERROR,13)<<"[algo_inst_id="<<algo_inst_id<<"]: Cannot get primary_market_id"<<endl;
controller.cpp               TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"]: ProcessChildFill: All legs sent [order_sequence="<<seq<<"lu order_id="<<order_id_string<<"] with total_sent="<<cached_native_spread_fill.total_sent<<"lu spread_qty="<<spread_qty<<".8f total_sent_qty_across_legs="<<cached_native_spread_fill.total_sent_qty_across_legs<<".8f total_expected_qty_across_legs_per_lot="<<cached_native_spread_fill.total_expected_qty_across_legs_per_lot<<".8f total_expected_qty_across_legs="<<cached_native_spread_fill.total_expected_qty_across_legs_per_lot*spread_qty<<".8f native_spread_fills_received.size="<<algo->native_spread_fills_received.size()<<"u synthetic_fills_sent.size="<<algo->synthetic_fills_sent.size()<<"u "<<endl;
controller.cpp               TTLOG(INFO,13)<<"[algo_inst_id="<<algo_inst_id<<"]: ProcessChildFill: one more leg sent [order_sequence="<<seq<<"lu order_id="<<order_id_string<<"] with total_sent="<<cached_native_spread_fill.total_sent<<"lu spread_qty="<<spread_qty<<".8f total_sent_qty_across_legs="<<cached_native_spread_fill.total_sent_qty_across_legs<<".8f total_expected_qty_across_legs_per_lot="<<cached_native_spread_fill.total_expected_qty_across_legs_per_lot<<".8f total_expected_qty_across_legs="<<cached_native_spread_fill.total_expected_qty_across_legs_per_lot*spread_qty<<".8f"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"[algo_inst_id="<<inst_id<<"]: send_synthetic_leg_fill failed to find leg info for instrument_id="<<leg_instrument_id<<"lu"<<endl;
controller.cpp    TTLOG(INFO,13)<<"[algo_inst_id="<<inst_id<<"]: send_synthetic_leg_fill: leg info=[instrument_id="<<leg_info.instrument_id<<"lu ratio="<<leg_info.ratio<<".8f cum_qty="<<leg_info.cum_qty<<".8f avg_px="<<leg_info.avg_px<<".8f] child_fill=[last_qty="<<last_qty<<".8f, last_px="<<last_px<<".8f] algo_order_qty="<<params.order_qty<<".8f "<<endl;
controller.cpp    TTLOG(INFO,13)<<"[algo_inst_id="<<inst_id<<"]: Send synthetic_leg_fill="<<child_fill->ShortDebugString().to_std()<<" "<<endl;
controller.cpp        TTLOG(DEBUG,13)<<"[algo_inst_id="<<inst_id<<"]: should_generate_synthetic_leg_fill=false"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"[algo_inst_id="<<inst_id<<"]: failed to find spread fill order_id="<<order_id<<" seq="<<seq<<"lu "<<endl;
controller.cpp    TTLOG(INFO,13)<<"[algo_inst_id="<<inst_id<<"] augment ER for [order_id="<<order_id<<" seq="<<seq<<"lu] Copied fills_grp_size="<<fills_grp_size<<"u key="<<key<<" total_sent_qty_across_legs="<<cached_native_spread_fill.total_sent_qty_across_legs<<".8f synthetic_fills_sent.size="<<synthetic_fills_sent.size()<<"u "<<endl;
controller.cpp            TTLOG(INFO,13)<<"[algo_inst_id="<<inst_id<<"]: send_synthetic_leg_fill SKIPPING: sequence mismatch [order_id="<<order_id<<" seq="<<seq<<"lu] total_sent="<<total_sent<<"lu leg_fill_order_id="<<leg_fill_order_id<<" leg_fill->last_qty="<<leg_fill->last_qty()<<".8f leg_fill->order_sequence="<<leg_fill->order_sequence()<<"lu "<<endl;
controller.cpp                TTLOG(INFO,13)<<"[algo_inst_id="<<inst_id<<"]: send_synthetic_leg_fill SKIPPING: order_id mismatch [order_id="<<order_id<<" seq="<<seq<<"lu] total_sent="<<total_sent<<"lu leg_fill_order_id="<<leg_fill_order_id<<" leg_fill->last_qty="<<leg_fill->last_qty()<<".8f "<<endl;
controller.cpp                    TTLOG(INFO,13)<<"[algo_inst_id="<<inst_id<<"]: send_synthetic_leg_fill OK [order_id="<<order_id<<" seq="<<seq<<"lu] total_sent="<<total_sent<<"lu total_sent_qty_across_legs="<<cached_native_spread_fill.total_sent_qty_across_legs<<".8f total_expected_qty_across_legs_per_lot="<<cached_native_spread_fill.total_expected_qty_across_legs_per_lot<<".8f leg_fill->last_qty="<<leg_fill->last_qty()<<".8f primary_market_id="<<primary_market_id<<" "<<endl;
controller.cpp                    TTLOG(ERROR,13)<<"[algo_inst_id="<<inst_id<<"]: send_synthetic_leg_fill failed [order_id="<<order_id<<" seq="<<seq<<"lu] "<<endl;
controller.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<inst_id<<"]: All legs sent! [order_id="<<order_id<<" seq="<<seq<<"lu] total_sent="<<total_sent<<"u spread_qty="<<spread_qty<<".8f total_sent_qty_across_legs="<<cached_native_spread_fill.total_sent_qty_across_legs<<".8f total_expected_qty_across_legs_per_lot="<<cached_native_spread_fill.total_expected_qty_across_legs_per_lot<<".8f total_expected_qty_across_legs="<<cached_native_spread_fill.total_expected_qty_across_legs_per_lot*spread_qty<<".8f leg_size="<<leg_infos.size()<<"u native_spread_fills_received.size="<<native_spread_fills_received.size()<<"u synthetic_fills_sent.size="<<synthetic_fills_sent.size()<<"u "<<endl;
controller.cpp        TTLOG(WARNING,13)<<"[algo_inst_id="<<inst_id<<"]: Not all legs sent! [order_id="<<order_id<<" seq="<<seq<<"lu] total_sent="<<total_sent<<"u spread_qty="<<spread_qty<<".8f total_sent_qty_across_legs="<<cached_native_spread_fill.total_sent_qty_across_legs<<".8f total_expected_qty_across_legs_per_lot="<<cached_native_spread_fill.total_expected_qty_across_legs_per_lot<<".8f total_expected_qty_across_legs="<<cached_native_spread_fill.total_expected_qty_across_legs_per_lot*spread_qty<<".8f leg_size="<<leg_infos.size()<<"u found_matching_leg="<<found_matching_leg<<" "<<endl;
controller.cpp        TTLOG(WARNING,13)<<"[algo_inst_id="<<inst_id<<"]: has no algo type. Will not generate synthetic leg fill"<<endl;
controller.cpp        TTLOG(INFO,13)<<"[algo_inst_id="<<inst_id<<"]: will generate synthetic leg fill"<<endl;
controller.cpp    TTLOG(INFO,13)<<"DownloadInstrument: inst_id="<<algo_instance_id<<": Starting synchronous instrument download: uri="<<uri.str()<<endl;
controller.cpp        TTLOG(ERROR,13)<<"DownloadInstrument: inst_id="<<algo_instance_id<<": Instrument download failed: exception="<<e.what()<<endl;
controller.cpp    TTLOG(INFO,13)<<"DownloadInstrument: inst_id="<<algo_instance_id<<": Instrument download succeeded: response="<<response<<endl;
controller.cpp            TTLOG(ERROR,13)<<"ParseInstrument: inst_id="<<algo_instance_id<<": [result][status] missing!"<<endl;
controller.cpp            TTLOG(ERROR,13)<<"ParseInstrument: inst_id="<<algo_instance_id<<": [result][status][stat] missing!"<<endl;
controller.cpp            TTLOG(ERROR,13)<<"ParseInstrument: inst_id="<<algo_instance_id<<": [result][status][stat]="<<stat<<"!"<<endl;
controller.cpp            TTLOG(ERROR,13)<<"ParseInstrument: inst_id="<<algo_instance_id<<": [instrument] missing!"<<endl;
controller.cpp            TTLOG(INFO,13)<<"ParseInstrument: inst_id="<<algo_instance_id<<": SYNTHETIC instrument parse succeeded: marketId="<<marketId<<"lu productId=(not available) productTypeId=(not available) productFamilyId=(not available)"<<endl;
controller.cpp        TTLOG(INFO,13)<<"ParseInstrument: inst_id="<<algo_instance_id<<": Instrument parse succeeded: marketId="<<marketId<<"lu productId="<<productId<<"lu productTypeId="<<productTypeId<<"lu productFamilyId="<<productFamilyId<<"lu firstLegInstrumentId="<<firstLegInstrumentId<<"lu (0 means absent)"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ParseInstrument: inst_id="<<algo_instance_id<<": Exception=["<<e.what()<<"] thrown during parse!"<<endl;
controller.cpp    TTLOG(INFO,13)<<"DownloadProduct: inst_id="<<algo_instance_id<<": Starting synchronous product download: uri="<<uri.str()<<endl;
controller.cpp        TTLOG(ERROR,13)<<"DownloadProduct: inst_id="<<algo_instance_id<<": Product download failed: exception="<<e.what()<<endl;
controller.cpp    TTLOG(INFO,13)<<"DownloadProduct: inst_id="<<algo_instance_id<<": Product download succeeded: response="<<response<<endl;
controller.cpp            TTLOG(ERROR,13)<<"ParseProduct: inst_id="<<algo_instance_id<<": [result][status] missing!"<<endl;
controller.cpp            TTLOG(ERROR,13)<<"ParseProduct: inst_id="<<algo_instance_id<<": [result][status][stat] missing!"<<endl;
controller.cpp            TTLOG(ERROR,13)<<"ParseProduct: inst_id="<<algo_instance_id<<": [result][status][stat]="<<stat<<"!"<<endl;
controller.cpp            TTLOG(ERROR,13)<<"ParseProduct: inst_id="<<algo_instance_id<<": [product] missing!"<<endl;
controller.cpp        TTLOG(INFO,13)<<"ParseProduct: inst_id="<<algo_instance_id<<": Product parse succeeded: productTypeId="<<productTypeId<<"lu productFamilyId="<<productFamilyId<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ParseProduct: inst_id="<<algo_instance_id<<": Exception=["<<e.what()<<"] thrown during parse!"<<endl;
controller.cpp    TTLOG(INFO,13)<<"RequestDownloadRiskLimits: Server Main Thread is requesting async downlonad onto TTUS Worker Thread: inst_id="<<algo_instance_id<<" user_request_id="<<user_request_id<<"lu"<<endl;
controller.cpp    TTLOG(INFO,13)<<"GetOrCreateRiskLimitsCache: user_id="<<user_id<<"lu account_id="<<account_id<<"lu instr_id="<<instr_id<<"lu"<<endl;
controller.cpp        TTLOG(INFO,13)<<"GetOrCreateRiskLimitsCache: New Risk Limit cache created. user_id="<<user_id<<"lu account_id="<<account_id<<"lu instr_id="<<instr_id<<"lu"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"UpdateAlgoParamsUsingOrderTags: Failed to find algo_data but this algo instance will proceed without Order Tags: algo_inst_id="<<algo_inst_id<<endl;
controller.cpp        TTLOG(INFO,13)<<"UpdateAlgoParamsUsingOrderTags: algo_inst_id="<<algo_inst_id<<" account="<<account<<endl;
controller.cpp        TTLOG(INFO,13)<<"UpdateAlgoParamsUsingOrderTags: algo_inst_id="<<algo_inst_id<<" account_override="<<account_override<<endl;
controller.cpp        TTLOG(WARNING,13)<<"UpdateRequestParamsUsingOrderTags: inst_id was null but this algo instance will proceed without Order Tags: user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"UpdateRequestParamsUsingOrderTags: Failed to encode class_1_2_fields but this algo instance will proceed without Order Tags: algo_inst_id="<<algo_inst_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp        TTLOG(WARNING,13)<<"UpdateRequestParamsUsingOrderTags: Failed to find algo_data but this algo instance will proceed without Order Tags: algo_inst_id="<<algo_inst_id<<" user_request_id="<<request_data->request.user_request_id<<"lu"<<endl;
controller.cpp        TTLOG(INFO,13)<<"UpdateRequestParamsUsingOrderTags: algo_inst_id="<<algo_inst_id<<" user_request_id="<<request_data->request.user_request_id<<"lu account="<<account<<endl;
controller.cpp        TTLOG(INFO,13)<<"UpdateRequestParamsUsingOrderTags: algo_inst_id="<<algo_inst_id<<" user_request_id="<<request_data->request.user_request_id<<"lu account_override="<<account_override<<endl;
controller.cpp    TTLOG(INFO,13)<<"ProcessOrderTagDownload: Order Tags downloaded and notified on Server Main Thread: algo_inst_id="<<algo_inst_id<<" download_result="<<order_tag_download.download_result?std::string("true"):std::string("false")<<endl;
controller.cpp        TTLOG(INFO,13)<<"ProcessOrderTagDownload: Download info was unexpectedly missing but this error is not fatal - the algo instance will still start without Order Tags: algo_inst_id="<<algo_inst_id<<endl;
controller.cpp        TTLOG(WARNING,13)<<"ProcessOrderTagDownload: Order Tags download failed but this error is not fatal - the algo instance will still start without Order Tags: algo_inst_id="<<algo_inst_id<<endl;
controller.cpp    TTLOG(INFO,13)<<"ProcessRiskLimitsDownload: Risk Limits received on Server Main Thread: user_id="<<risk_limits_download.user_id<<"lu account_id="<<risk_limits_download.account_id<<"lu instr_id="<<risk_limits_download.instr_id<<"lu"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"ProcessRiskLimitsDownload: Cache was unexpectedly absent at this point! New cache was created nonetheless and we will proceed to populate it with the downloaded limits: user_id="<<risk_limits_download.user_id<<"lu account_id="<<risk_limits_download.account_id<<"lu instr_id="<<risk_limits_download.instr_id<<"lu"<<endl;
controller.cpp    TTLOG(INFO,13)<<"dest_cb="<<dest_cb<<"u id="<<algojob_request->id<<"u account_count="<<algojob_request->data.user_update.account_count<<"u"<<endl;
controller.cpp        TTLOG(ERROR,13)<<"restore_algojob_request error. cb="<<cb<<"u cb1="<<cb1<<"u"<<endl;
controller.cpp            TTLOG(ERROR,13)<<"compare_algojob__requests error. cb="<<cb<<"u cb1="<<cb1<<"u cb2="<<cb2<<"u"<<endl;
controller.cpp    TTLOG(INFO,13)<<""<<ss.str()<<endl;
main.cpp                TTLOG(INFO,13)<<"Waiting for thread shutdown. name="<<m_name<<endl;
main.cpp    TTLOG(INFO,13)<<"Parsing TTUS connection_ids=["<<connection_ids<<"]"<<endl;
main.cpp        TTLOG(INFO,13)<<"Added connection_id="<<connection_id<<endl;
main.cpp    TTLOG(INFO,13)<<"Parsing TTUS account_ids=["<<account_ids<<"]"<<endl;
main.cpp        TTLOG(INFO,13)<<"Added connection_id="<<account_id<<endl;
main.cpp    TTLOG(INFO,13)<<"Parsing TTUS company_ids=["<<company_ids<<"]"<<endl;
main.cpp        TTLOG(INFO,13)<<"Added company_id="<<company_id<<endl;
main.cpp        TTLOG(ERROR,13)<<"Read AlgoServer config failed"<<endl;
main.cpp        TTLOG(ERROR,13)<<"failed to get SelfBinaryName"<<endl;
main.cpp        TTLOG(ERROR,13)<<"failed to make path. path="<<algoserver__variable_state_path<<endl;
main.cpp    TTLOG(INFO,13)<<"Initializing AlgoServer. build_date= BUILD_DATE build_commit="<<endl;
main.cpp    TTLOG(INFO,13)<<"ConfigXml: client_id ="<<client_id<<endl;
main.cpp    TTLOG(INFO,13)<<"ConfigXml: client_secret ="<<Elide(client_secret<<endl;
main.cpp    TTLOG(INFO,13)<<"ConfigXml: ttid_url ="<<ttid_url<<endl;
main.cpp    TTLOG(INFO,13)<<"ConfigXml: admin_url ="<<admin_url<<endl;
main.cpp    TTLOG(INFO,13)<<"ConfigXml: risk_url ="<<risk_url<<endl;
main.cpp    TTLOG(INFO,13)<<"ConfigXml: risk_ws_url ="<<risk_ws_url<<endl;
main.cpp    TTLOG(INFO,13)<<"ConfigXml: ssl_ca_path ="<<ssl_ca_path<<endl;
main.cpp    TTLOG(INFO,13)<<"ConfigXml: ttus_config_xml ="<<ttus_config_xml<<endl;
main.cpp    TTLOG(INFO,13)<<"ConfigXml: jobCount ="<<jobCount<<endl;
main.cpp        TTLOG(INFO,13)<<"Detected ASAN_OPTIONS="<<asan_options<<endl;
main.cpp        TTLOG(ERROR,13)<<"Note: ASAN_OPTIONS are not defined when running instrumented build"<<endl;
main.cpp        TTLOG(ERROR,13)<<"Failed to init env. error="<<err.what()<<endl;
main.cpp     TTLOG(WARNING,13)<<oss.str()<<endl;
main.cpp            TTLOG(ERROR,13)<<"Init HSM Proxy connection failed ["<<algoserver_error<<"]"<<endl;
main.cpp            TTLOG(ERROR,13)<<"Invalid zookeeper config"<<endl;
main.cpp        TTLOG(ERROR,13)<<"Init comm failed: "<<ALGOSERVER_ERROR_STR[algoserver_error]<<endl;
main.cpp        TTLOG(INFO,13)<<"Created Risk Sender for Child order: market="<<risk_sender.market_id<<" account="<<risk_sender.account_id<<"lu"<<endl;
main.cpp             TTLOG(WARNING,13)<<oss.str()<<endl;
main.cpp         TTLOG(ERROR,13)<<"Failed to init PDS. url="<<pds_url<<endl;
main.cpp        TTLOG(ERROR,13)<<"Init retrieve SecurityExchanges from PDS failed"<<endl;
main.cpp        TTLOG(ERROR,13)<<"Algojob Load Balancer initialization failed"<<endl;
main.cpp                TTLOG(ERROR,13)<<"Developer feature [enable_expedited_ttus_download] is enabled on a chef-deployed machine!"<<endl;
main.cpp                TTLOG(ERROR,13)<<"Developer feature [enable_expedited_ttus_download] is enabled outside of internal environment!"<<endl;
main.cpp            TTLOG(INFO,13)<<"Developer feature [enable_expedited_ttus_download] enabled: Downloading specific TTUS objects!"<<endl;
main.cpp                TTLOG(ERROR,13)<<"TTUS_Web Connections download failed"<<endl;
main.cpp                TTLOG(ERROR,13)<<"TTUS_Web Accounts download failed"<<endl;
main.cpp                TTLOG(ERROR,13)<<"TTUS_Web Companies download failed"<<endl;
main.cpp                TTLOG(ERROR,13)<<"TTUS_Web Connections download failed"<<endl;
main.cpp                TTLOG(ERROR,13)<<"TTUS_Web Accounts download failed"<<endl;
main.cpp                TTLOG(ERROR,13)<<"TTUS_Web Companies download failed"<<endl;
main.cpp        TTLOG(INFO,13)<<"Testing for PDS maintenance. url="<<pds_url<<endl;
main.cpp                TTLOG(WARNING,13)<<"Not all PDS query succeed"<<endl;
main.cpp                TTLOG(INFO,13)<<"PDS query batch "<<++succeed_batches<<" succeed"<<endl;
main.cpp            TTLOG(ERROR,13)<<"PDS in maintenance. url="<<pds_url<<endl;
main.cpp            TTLOG(ERROR,13)<<"Ledger download failed"<<endl;
main.cpp        TTLOG(INFO,13)<<"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"<<endl;
main.cpp        TTLOG(INFO,13)<<"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Startup complete!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"<<endl;
main.cpp        TTLOG(INFO,13)<<"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"<<endl;
main.cpp            TTLOG(ERROR,13)<<"AlgoServer_ControllerMain failed error="<<ALGOSERVER_ERROR_STR[algoserver_error]<<endl;
main.cpp    TTLOG(INFO,13)<<"Shutting down. main_flags="<<std::bitset<num_bits_needed>(main_flags)<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: datacenter_name="<<datacenter_name<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: instance_name="<<instance_name<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: minLogLevel="<<static_cast<int>(minLogLevel)<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: algoserver__is_remote_env="<<algoserver__is_remote_env?"true":"false"<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: MAX_SSE_ALGOS_PER_USER ="<<algoserver__max_sse_algos_per_user<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: MAX_ADL_ALGOS_PER_USER ="<<algoserver__max_adl_algos_per_user<<endl;
main.cpp        TTLOG(INFO,13)<<"ConfigXml: INCLUDE_ALL_ALGO_STATUSES ="<<algoserver__include_all_algo_statuses<<endl;
main.cpp        TTLOG(ERROR,13)<<"Read AlgoServer config failed: "<<e.what()<<endl;
main.cpp        TTLOG(ERROR,13)<<" Problem opening file="<<file_path<<" to write server_instance_id="<<uuid_str<<endl;
main.cpp        TTLOG(ERROR,13)<<" Problem writing server_instance_id="<<uuid_str<<" to file="<<file_path<<", ferror="<<ferr<<endl;
main.cpp        TTLOG(INFO,13)<<" Using persisted algoserver__inst_id_string="<<algoserver__inst_id_string<<", algoserver__instance_identifier_name="<<algoserver__instance_identifier_name<<endl;
main.cpp    TTLOG(WARNING,13)<<" main: Generating new algoserver__inst_id_string="<<algoserver__inst_id_string<<", algoserver__instance_identifier_name="<<algoserver__instance_identifier_name<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<" lbm: UME store "<<ume_registration_ex->store_index<<": "<<ume_registration_ex->store<<" "<<function_string<<" success. RegID "<<ume_registration_ex->registration_id<<", Flags "<<ume_registration_ex->flags<<" "<<ume_registration_ex->flags&LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD?"+":"-"<<"OLD[SQN "<<ume_registration_ex->sequence_number<<"] "<<ume_registration_ex->flags&LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_NOACKS?"+":"-"<<"NOACKS Source "<<topic_name<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"lbm: Source "<<topic_name<<" connected to "<<static_cast<char*>(data)<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"lbm: Source "<<topic_name<<" disconnected from "<<static_cast<char*>(data)<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"lbm: Error registering source with UME store: "<<static_cast<char*>(data)<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"lbm: UME store registration success. RegID "<<ume_registration->registration_id<<" Source "<<topic_name<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"lbm: UME DEREGISTRATION IS COMPLETE_EX Source "<<topic_name<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"lbm: UME registration complete. SQN "<<ume_registration_complete->sequence_number<<". Flags "<<ume_registration_complete->flags<<" "<<ume_registration_complete->flags&LBM_SRC_EVENT_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM?"+":"-"<<"QUORUM Source "<<topic_name<<endl;
comm_lbm.cpp            TTLOG(WARNING,13)<<"lbm: UME store "<<ume_ack_ex_info->store_index<<": "<<ume_ack_ex_info->store<<" message NOT stable!! SQN "<<ume_ack_ex_info->sequence_number<<" (cd "<<msg_clientd<<"). Flags "<<ume_ack_ex_info->flags<<" "<<ume_ack_ex_info->flags&LBM_SRC_EVENT_UME_MESSAGE_NOT_STABLE_FLAG_LOSS?"+":"-"<<"LOSS "<<ume_ack_ex_info->flags&LBM_SRC_EVENT_UME_MESSAGE_NOT_STABLE_FLAG_TIMEOUT?"+":"-"<<"TIMEOUT Source "<<topic_name<<endl;
comm_lbm.cpp            TTLOG(WARNING,13)<<"lbm: UME message NOT stable!! SQN "<<ume_ack_ex_info->sequence_number<<" (cd "<<msg_clientd<<"). Flags "<<ume_ack_ex_info->flags<<" "<<ume_ack_ex_info->flags&LBM_SRC_EVENT_UME_MESSAGE_NOT_STABLE_FLAG_LOSS?"+":"-"<<"LOSS "<<ume_ack_ex_info->flags&LBM_SRC_EVENT_UME_MESSAGE_NOT_STABLE_FLAG_TIMEOUT?"+":"-"<<"TIMEOUT Source "<<topic_name<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"lbm: UME message reclaimed (ex) - sequence number "<<ume_ack_ex_info->sequence_number<<" (cd "<<msg_clientd<<"). Flags "<<ume_ack_ex_info->flags<<" Source "<<topic_name<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<"lbm: UME store: "<<static_cast<char*>(data)<<" Source "<<topic_name<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"lbm: Flight Size Notification. Type: "<<flight_size_notification_type<<". Inflight is "<<flight_size_notification_state<<" specified flight size Source "<<topic_name<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"using the following string "<<topic_name<<" to generate session id: 0x"<<std::showbase << std::hex<<session_id<<"16llX"<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<"lbm: Failed to set ume_session_id, topic: "<<topic_name<<" error="<<ex.what()<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<"Failed to create Source, topic: "<<topic_name<<" error="<<ex.what()<<endl;
comm_lbm.cpp            TTLOG(WARNING,13)<<"Timed out after waiting "<<(int)(UMP_REGISTRATION_TIMEOUT_NS/NANOSECONDS_PER_SECOND)<<" sec for UME_REGISTRATION_COMPLETE. Will rely on LBM_TRANSACTION_LOGGER to switch to LBM"<<endl;
comm_lbm.cpp            TTLOG(ERROR,13)<<"Timed out after waiting "<<(int)(UMP_REGISTRATION_TIMEOUT_NS/NANOSECONDS_PER_SECOND)<<" sec for UME_REGISTRATION_COMPLETE"<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<" LOST. topic="<<msg.TopicName()<<" source="<<msg.Source()<<" seq_num="<<msg.SequenceNumber()<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<" LOST BURST. topic="<<msg.TopicName()<<" source="<<msg.Source()<<" seq_num="<<msg.SequenceNumber()<<endl;
comm_lbm.cpp        TTLOG(DEBUG,13)<<"Beginning of transport session. Topic="<<msg.TopicName()<<" lbm_source="<<msg.Source()<<endl;
comm_lbm.cpp        TTLOG(DEBUG,13)<<"End of transport session. Topic="<<msg.TopicName()<<" lbm_source="<<msg.Source()<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<" No sources found for topic="<<msg.TopicName()<<"."<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<" UME registration error: "<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<" UME registration successful. topic="<<msg.TopicName()<<" source="<<msg.Source()<<" SrcRegID "<<reg->src_registration_id<<" RcvRegID "<<reg->rcv_registration_id<<"."<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<" UME registration successful. topic="<<msg.TopicName()<<" source="<<msg.Source()<<" store "<<reg->store_index<<": "<<reg->store<<" SrcRegID "<<reg->src_registration_id<<" RcvRegID "<<reg->rcv_registration_id<<" Flags "<<reg->flags<<". "<<sqn<<" "<<reg->flags&LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE?"+":"-"<<"NOCACHE "<<reg->flags&LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_RPP?"+":"-"<<"RPP "<<sid<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<" UME registration complete. topic="<<msg.TopicName()<<" source="<<msg.Source()<<" SQN "<<reg->sequence_number<<" Flags "<<reg->flags<<". "<<reg->flags&LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM?"+":"-"<<"QUORUM "<<reg->flags&LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_RXREQMAX?"+":"-"<<"RXREQMAX "<<sid<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<" UME deregistration successful. topic="<<msg.TopicName()<<" source="<<msg.Source()<<" store "<<dereg->store_index<<": "<<dereg->store<<" SrcRegID "<<dereg->src_registration_id<<" RcvRegID "<<dereg->rcv_registration_id<<" Flags "<<dereg->flags<<". "<<sqn<<" "<<dereg->flags&LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE?"+":"-"<<"NOCACHE "<<dereg->flags&LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_RPP?"+":"-"<<"RPP"<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<" UME deregistration complete. topic="<<msg.TopicName()<<" source="<<msg.Source()<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<" UME registration change. topic="<<msg.TopicName()<<" source="<<msg.Source()<<" data="<<msg.Data()<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"lbm_version "<<v<<endl;
comm_lbm.cpp            TTLOG(ERROR,13)<<"Clean up: side_channel_recver;"<<endl;
comm_lbm.cpp            TTLOG(ERROR,13)<<"Clean up: side_channel_sender;"<<endl;
comm_lbm.cpp            TTLOG(ERROR,13)<<"Clean up: recver;"<<endl;
comm_lbm.cpp            TTLOG(ERROR,13)<<"Clean up: edge_recver;"<<endl;
comm_lbm.cpp            TTLOG(ERROR,13)<<"Clean up: oc_recver;"<<endl;
comm_lbm.cpp            TTLOG(ERROR,13)<<"Clean up: bookie_sender;"<<endl;
comm_lbm.cpp            TTLOG(ERROR,13)<<"Clean up: s_algo_sender"<<endl;
comm_lbm.cpp            TTLOG(ERROR,13)<<"Clean up: user_group_sender;"<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<"Clean up: lbm_lbm_transaction_logger;"<<endl;
comm_lbm.cpp            TTLOG(ERROR,13)<<"Clean up: lbm_context;"<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"Creating LBM Context config_file="<<config_file<<" app_name="<<app_name<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"Creating receiver topic="<<topic_name<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"Creating side channel receiver topic="<<topic_name<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"Creating side channel sender topic="<<topic_name<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"Creating receiver EdgeServer topic="<<topic_name<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"Creating sender Bookie topic="<<bookie_topic_name<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"ConfigXml: use_lbm_transaction_logger="<<s_use_lbm_transaction_logger<<endl;
comm_lbm.cpp            TTLOG(INFO,13)<<"Creating LBM Transaction Logger dir_path="<<dir_path<<" ump_flight_size="<<ump_flight_size<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"ConfigXml: ump_ensemble="<<ump_ensemble<<endl;
comm_lbm.cpp            TTLOG(INFO,13)<<"Creating UMP sender topic="<<algo_sender_topic_name<<endl;
comm_lbm.cpp                TTLOG(ERROR,13)<<"Failed to create sender topic="<<algo_sender_topic_name<<endl;
comm_lbm.cpp                TTLOG(WARNING,13)<<"ConfigXml: inconsistent config. s_use_ump=false but use_lbm_transaction_logger=true. Setting use_lbm_transaction_logger=false"<<endl;
comm_lbm.cpp            TTLOG(INFO,13)<<"Creating LBM sender topic="<<algo_sender_topic_name<<endl;
comm_lbm.cpp                TTLOG(ERROR,13)<<"Failed to create sender topic="<<algo_sender_topic_name<<" error="<<ex.what()<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"Creating receiver OC topic="<<topic_name<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"Creating source for User Group topic="<<USER_GROUP_TOPIC_STRING<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"Creating Triage Action Topic="<<triage_action_topic_name<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"Creating Triage Action Topic="<<triage_action_topic_name<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"Creating Triage Action Topic="<<triage_action_topic_name<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"Creating Triage Action Topic="<<triage_action_topic_name<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"AlgoServer_ShutdownComm Started"<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"AlgoServer_ShutdownComm Ended"<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<"Error no algo channel sender for account_id="<<connection_id<<"lu"<<endl;
comm_lbm.cpp            TTLOG(WARNING,13)<<"AlgoServer_SendAlertExecutionReport: lbm_error="<<ex.what()<<" use_lbm_transaction_logger="<<s_use_lbm_transaction_logger<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<""<<logInfo<<": Cannot create algo sidechannel sender for account_id="<<account_id<<"lu"<<endl;
comm_lbm.cpp            TTLOG(WARNING,13)<<""<<logInfo<<": lbm_error="<<ex.what()<<" without channel="<<account_id<<"lu"<<endl;
comm_lbm.cpp            TTLOG(WARNING,13)<<""<<logInfo<<": lbm_error="<<ex.what()<<" channel="<<account_id<<endl;
comm_lbm.cpp        TTLOG(WARNING,13)<<" AlgoServer_SendAlert: Encode failed: "<<ALGOSERVER_ERROR_STR[algoserver_error]<<endl;
comm_lbm.cpp        TTLOG(WARNING,13)<<"SendExportValue: Encode failed: "<<ALGOSERVER_ERROR_STR[algoserver_error]<<" account_id="<<connection_id<<"lu"<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<" Encode failed for response="<<ALGO_RESPONSE_ID_STR[response->id]<<". algoserver_error="<<ALGOSERVER_ERROR_STR[algoserver_error]<<endl;
comm_lbm.cpp            TTLOG(ERROR,13)<<"Error no algo channel sender for account_id="<<response->connection_id<<"lu"<<endl;
comm_lbm.cpp            TTLOG(ERROR,13)<<"Skip lbm send, encoded_size=0"<<endl;
comm_lbm.cpp                TTLOG(WARNING,13)<<"Error sending response: : lbm_error="<<ex.what()<<" use_lbm_transaction_logger"<<endl;
comm_lbm.cpp        TTLOG(WARNING,13)<<"Error sending request, lbm_error="<<ex.what()<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"TransferAlgo: sending book download request for algoserver_id="<<algoserver_id<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"TransferAlgo response received on LBM thread"<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"Duplicate, book download response received, ignoring"<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"Book download response received"<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"Sending book download request"<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"DownloadOrderTagCallback: OTD ER received on LBM Thread!"<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"DownloadOrderTagCallback: Forwarded Order Tags to Server Main Thread: algo_inst_id="<<algo_inst_ttuuid<<endl;
comm_lbm.cpp        TTLOG(WARNING,13)<<"AlgoServer_SendOrderTagNewOrderSingle: Error sending OTD NOS: algo_inst_id is missing but OTD error is not fatal: algo_inst_id=MISSING"<<endl;
comm_lbm.cpp        TTLOG(WARNING,13)<<"AlgoServer_SendOrderTagNewOrderSingle: Error sending OTD NOS: Unable to find primary_market_id but OTD error is not fatal: algo_inst_id="<<algo_inst_id<<endl;
comm_lbm.cpp        TTLOG(WARNING,13)<<"AlgoServer_SendOrderTagNewOrderSingle: Error sending OTD NOS: Unable to find sender but OTD error is not fatal: algo_inst_id="<<algo_inst_id<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"AlgoServer_SendOrderTagNewOrderSingle: Sending OTD NOS: topic=OC.ORDERTAG."<<market_id<<" algo_inst_id="<<algo_inst_id<<endl;
comm_lbm.cpp        TTLOG(WARNING,13)<<"AlgoServer_SendOrderTagNewOrderSingle: Error sending OTD NOS: LBM send failed but OTD error is not fatal: algo_inst_id="<<algo_inst_id<<" lbm_exception="<<ex.what()<<endl;
comm_lbm.cpp        TTLOG(WARNING,13)<<"AlgoServer_SendOrderTagNewOrderSingle: Error sending OTD NOS: LBM Request Ptr is null but OTD error is not fatal: algo_inst_id="<<algo_inst_id<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"AlgoServer_SendOrderTagNewOrderSingle: Sent OTD NOS: algo_inst_id="<<algo_inst_id<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"AlgoServer_EmplaceOrderTagRequestPtr: Emplaced ptr: algo_inst_id="<<algo_inst_id<<" s_ordertag_requests.size()="<<s_ordertag_requests.size()<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"AlgoServer_EraseOrderTagRequestPtr: Erased ptr: algo_inst_id="<<algo_inst_id<<" s_ordertag_requests.size()="<<s_ordertag_requests.size()<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<"Error sending child cancel: Unable to find sender. order_id="<<order_id<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"Sending child cancel on market_id="<<market_id<<" account_id="<<params.account<<"lu"<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<"Error sending child cancel: LBM send failed. order_id="<<order_id<<" error="<<ex.what()<<endl;
comm_lbm.cpp            TTLOG(ERROR,13)<<"Error creating algo sender. account_id="<<account_id<<"lu error="<<ALGOUTIL_ERROR_STR[algoutil__error_create_lbm_channel_source]<<" "<<ex.what()<<" use_lbm_transaction_logger="<<s_use_lbm_transaction_logger<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"Created algo channel sender. account_id="<<account_id<<"lu use_lbm_transaction_logger="<<s_use_lbm_transaction_logger<<endl;
comm_lbm.cpp            TTLOG(ERROR,13)<<"Error creating algo sender. account_id="<<account_id<<"lu error="<<ALGOUTIL_ERROR_STR[algoutil__error_create_lbm_channel_source]<<" "<<ex.what()<<" useTransactionLogger="<<s_use_lbm_transaction_logger<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"Created algo channel sender. account_id="<<account_id<<"lu useTransactionLogger="<<s_use_lbm_transaction_logger<<endl;
comm_lbm.cpp            TTLOG(ERROR,13)<<"Failed to create Risk topic="<<topic_name<<". error="<<ex.what()<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<"Error creating child sender. market_id="<<mkt_id<<" account_id="<<account_id<<"lu error="<<ex.what()<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"Created child cancel channel sender. account_id="<<account_id<<"lu market="<<mkt_id<<endl;
comm_lbm.cpp        TTLOG(WARNING,13)<<"Error sending response: Lbm send failed. lbm_error="<<ex.what()<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"Creating sender OC Ordertag topic="<<oc_ordertag_sender_topic_name<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<"No Channel sender for user_group_id="<<user_group_id<<"lu"<<endl;
comm_lbm.cpp        TTLOG(INFO,13)<<"Send to "<<USER_GROUP_TOPIC_STRING<<" topic with channel sender for user_group_id="<<user_group_id<<"lu"<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<"Failed to send through channel sender for user_group_id="<<user_group_id<<"lu"<<endl;
comm_lbm.cpp        TTLOG(ERROR,13)<<"Cannot change the LbmSenderMode because use_lbm_transaction_logger="<<s_use_lbm_transaction_logger<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"SetLbmSenderMode to "<<useUMP?"UMP":"LBM"<<endl;
comm_lbm.cpp    TTLOG(INFO,13)<<"SetLbmSenderMode to "<<useUMP?"UMP":"LBM"<<" "<<newState<<endl;
order_passing_manager.cpp        TTLOG(ERROR,13)<<"[algo="<<algo->inst_id<<"] OrderPass::"<<request<<". Failed: "<<error<<endl;
order_passing_manager.cpp        TTLOG(ERROR,13)<<"[algo="<<algo->inst_id<<"] OrderPass::"<<request<<". Failed: "<<error<<endl;
order_passing_manager.cpp        TTLOG(ERROR,13)<<"[algo="<<algo->inst_id<<"] OrderPass::"<<request<<". Failed: "<<error<<endl;
order_passing_manager.cpp        TTLOG(ERROR,13)<<"[algo="<<algo->inst_id<<"] OrderPass::"<<request<<". Failed: "<<error<<endl;
order_passing_manager.cpp        TTLOG(ERROR,13)<<"[algo="<<algo->inst_id<<"] OrderPass::"<<request<<". Failed: "<<error<<endl;
order_passing_manager.cpp        TTLOG(ERROR,13)<<"[algo="<<algo->inst_id<<"] OrderPass::"<<request<<". Failed: "<<error<<endl;
order_passing_manager.cpp        TTLOG(ERROR,13)<<"[algo="<<algo->inst_id<<"] OrderPass::Init: Failed: "<<error<<endl;
order_passing_manager.cpp        TTLOG(INFO,13)<<"[algo="<<algo->inst_id<<"] OrderPass::Init: Setting original_group_id="<<order_pass.group_ids.current_group_id<<"lu"<<endl;
order_passing_manager.cpp        TTLOG(ERROR,13)<<"[algo="<<algo->inst_id<<"] OrderPass::Init: Failed: "<<error<<" before_transition_current_group_id="<<before_transition_group_ids.current_group_id<<"ll after_transition_current_group_id="<<order_pass.group_ids.current_group_id<<"ll"<<endl;
order_passing_manager.cpp    TTLOG(INFO,13)<<"[algo="<<algo->inst_id<<"] OrderPass::Init: Attempting transition: BEFORE: [state="<<OrderPassToString(before_transition_state)<<" "<<GroupIDsToString(before_transition_group_ids)<<" current_user_id="<<before_transition_current_user_id<<"lu] ORDER: ["<<GroupIDsToString(order_pass.group_ids)<<"] AFTER: [state="<<OrderPassToString(order_pass_init)<<" "<<GroupIDsToString(after_transition_group_ids)<<" current_user_id="<<order_pass.current_user_id<<"lu]"<<endl;
order_passing_manager.cpp        TTLOG(ERROR,13)<<"[algo="<<algo->inst_id<<"] OrderPass::Accept: Failed: "<<error<<endl;
order_passing_manager.cpp    TTLOG(INFO,13)<<"[algo="<<algo->inst_id<<"] OrderPass::Accept: Attempting transition: BEFORE: [state="<<OrderPassToString(before_transition_state)<<" "<<GroupIDsToString(before_transition_group_ids)<<" current_user_id="<<before_transition_current_user_id<<"lu] ORDER: ["<<GroupIDsToString(order_pass.group_ids)<<"] AFTER: [state="<<OrderPassToString(order_pass_accept)<<" "<<GroupIDsToString(after_transition_group_ids)<<" current_user_id="<<order_pass.current_user_id<<"lu]"<<endl;
order_passing_manager.cpp        TTLOG(ERROR,13)<<"[algo="<<algo->inst_id<<"] OrderPass::Reject: Failed: "<<error<<endl;
order_passing_manager.cpp    TTLOG(INFO,13)<<"[algo="<<algo->inst_id<<"] OrderPass::Reject: Attempting transition: BEFORE: [state="<<OrderPassToString(before_transition_state)<<" "<<GroupIDsToString(before_transition_group_ids)<<" current_user_id="<<before_transition_current_user_id<<"lu] ORDER: ["<<GroupIDsToString(order_pass.group_ids)<<"] AFTER: [state="<<OrderPassToString(order_pass_reject)<<" "<<GroupIDsToString(after_transition_group_ids)<<" current_user_id="<<order_pass.current_user_id<<"lu]"<<endl;
order_passing_manager.cpp        TTLOG(ERROR,13)<<"[algo="<<algo->inst_id<<"] OrderPass::Undo: Failed: "<<error<<endl;
order_passing_manager.cpp    TTLOG(INFO,13)<<"[algo="<<algo->inst_id<<"] OrderPass::Undo: Attempting transition: BEFORE: [state="<<OrderPassToString(before_transition_state)<<" "<<GroupIDsToString(before_transition_group_ids)<<" current_user_id="<<before_transition_current_user_id<<"lu] ORDER: ["<<GroupIDsToString(order_pass.group_ids)<<"] AFTER: [state="<<OrderPassToString(order_pass_undo)<<" "<<GroupIDsToString(after_transition_group_ids)<<" current_user_id="<<order_pass.current_user_id<<"lu]"<<endl;
order_passing_manager.cpp    TTLOG(INFO,13)<<"[algo="<<algo->inst_id<<"] OrderPass::SetChild: Successfully prepared request: state=set_child current_user_id="<<order_pass.current_user_id<<"lu "<<GroupIDsToString(order_pass.group_ids)<<" "<<endl;
order_passing_manager.cpp        TTLOG(ERROR,13)<<"[algo="<<algo->inst_id<<"] OrderPass::Handle: Can not handle request="<<OrderPassToString(order_pass.state)<<". Unrecognized OBP state"<<endl;
auth.cpp        TTLOG(INFO,13)<<"Problem reading HSM config file."<<endl;
auth.cpp        TTLOG(ERROR,13)<<"Invalid environment"<<endl;
auth.cpp            TTLOG(WARNING,13)<<"token_signer missing config name="<<name<<" error="<<ALGOUTIL_ERROR_STR[error]<<endl;
auth.cpp            TTLOG(INFO,13)<<"Bypassing HSM Proxy (no connection to HSM Proxy is needed) - will use internal private keys to renew tokens locally on algoserver."<<endl;
auth.cpp            TTLOG(WARNING,13)<<"token_signer missing config name="<<name<<" error="<<ALGOUTIL_ERROR_STR[error]<<endl;
auth.cpp            TTLOG(WARNING,13)<<"token_signer missing config name="<<name<<" error="<<ALGOUTIL_ERROR_STR[error]<<endl;
auth.cpp            TTLOG(WARNING,13)<<"token_signer missing config name="<<name<<" error="<<ALGOUTIL_ERROR_STR[error]<<endl;
auth.cpp            TTLOG(WARNING,13)<<"token_signer missing config name="<<name<<" error="<<ALGOUTIL_ERROR_STR[error]<<endl;
auth.cpp            TTLOG(WARNING,13)<<"token_signer missing config name="<<name<<" error="<<ALGOUTIL_ERROR_STR[error]<<endl;
auth.cpp            TTLOG(WARNING,13)<<"token_signer missing config name="<<name<<" error="<<ALGOUTIL_ERROR_STR[error]<<endl;
auth.cpp        TTLOG(ERROR,13)<<" Poll timed out or encountered an error while awaiting response from HSM proxy. error="<<strerror(errno)<<endl;
auth.cpp        TTLOG(ERROR,13)<<" Problem receiving JSON response from HSM proxy. error="<<ALGOUTIL_ERROR_STR[error]<<endl;
auth.cpp            TTLOG(ERROR,13)<<" Problem sending JSON request to HSM Proxy. request="<<request<<" error="<<ALGOUTIL_ERROR_STR[error]<<endl;
auth.cpp                TTLOG(ERROR,13)<<" Problem receiving JSON response from HSM Proxy. bad_response="<<bad_response<<" error="<<ALGOUTIL_ERROR_STR[error]<<endl;
auth.cpp            TTLOG(ERROR,13)<<"HSM Proxy rejected the sign request. error_msg="<<).as_string()<<", (response_json[errorMsg"<<endl;
auth.cpp        TTLOG(INFO,13)<<"HSM Proxy successfully signed request."<<endl;
auth.cpp        TTLOG(ERROR,13)<<"Exception was thrown. exception="<<ex.what()<<endl;
auth.cpp        TTLOG(ERROR,13)<<" AlgoServer_DeleteUserTokenOnDisk: Failed to delete user token on disk: user_id="<<user_id<<"lu errno="<<strerror(errno)<<" token_path="<<auth_token_file_path<<" "<<endl;
auth.cpp        TTLOG(INFO,13)<<"Sending curl request to AUTH server: "<<post_buffer<<endl;
auth.cpp        TTLOG(INFO,13)<<"Received curl response from AUTH server: "<<response_data.data.get(<<" ..... "<<64)<<endl;
auth.cpp        TTLOG(INFO,13)<<"Attempting TIER 1 method (Refresh Token) user_id="<<user_id<<"lu"<<endl;
auth.cpp            TTLOG(INFO,13)<<"Successfully renewed via TIER 1. user_id="<<user_id<<"lu"<<endl;
auth.cpp            TTLOG(DEBUG,13)<<"NewTkn="<<access_token<<endl;
auth.cpp        TTLOG(INFO,13)<<"Attempting TIER 2 method (token-download-request) user_id="<<user_id<<"lu"<<endl;
auth.cpp            TTLOG(INFO,13)<<"Successfully renewed via TIER 2. user_id="<<user_id<<"lu"<<endl;
auth.cpp            TTLOG(DEBUG,13)<<"NewTkn="<<access_token<<endl;
auth.cpp        TTLOG(INFO,13)<<"Attempting TIER 3 method (New Connection). user_id="<<user_id<<"lu"<<endl;
auth.cpp            TTLOG(INFO,13)<<"Successfully renewed via TIER 3. user_id="<<user_id<<"lu"<<endl;
auth.cpp            TTLOG(DEBUG,13)<<"NewTkn="<<access_token<<endl;
auth.cpp        TTLOG(ERROR,13)<<"Failed to re-sign token. user_id="<<user_id<<"lu old_token="<<Elide(access_token<<endl;
auth.cpp        TTLOG(ERROR,13)<<"Failed to re-sign token. user_id="<<user_id<<"lu error="<<e.what()<<endl;
auth.cpp        TTLOG(ERROR,13)<<"Failed to connect to HSM Proxy."<<endl;
auth.cpp    TTLOG(INFO,13)<<"Connected successfully to HSM Proxy."<<endl;
auth.cpp        TTLOG(INFO,13)<<"Destroyed HSM Proxy connection."<<endl;
auth.cpp        TTLOG(INFO,13)<<" Problem re-signing token. User="<<user_id<<"lu, Msg="<<ex.what()<<" OldTkn="<<access_token<<endl;
auth.cpp        TTLOG(INFO,13)<<" Unknown problem re-signing token. User="<<user_id<<"lu OldTkn="<<access_token<<endl;
main.cpp        TTLOG(ERROR,13)<<"!! Error !! TTSDKPriceUpdateCallback() Did not find PARENT!!!, user_data="<<user_data<<", "<<endl;
main.cpp        TTLOG(WARNING,13)<<"SSE received Price error="<<error<<", but no algo found. user_data="<<user_data<<endl;
main.cpp    TTLOG(INFO,13)<<"["<<parent->GetOrderIDString()<<"] CleanupParent"<<endl;
main.cpp    TTLOG(INFO,13)<<"now parentOrders.size()="<<parentOrders.size()<<endl;
main.cpp    TTLOG(INFO,13)<<"OnUnloadSO: Shutting down logging"<<endl;
main.cpp        TTLOG(ERROR,13)<<"[nullptr OnStart]: Failed to create SSE type from params. type="<<TTSDK_ORDER_SYNTHETIC_TYPE_STR[sse_type]<<endl;
main.cpp        TTLOG(ERROR,13)<<"["<<newParent->GetOrderIDString()<<" OnStart]: Failed to get SSE type from params "<<endl;
main.cpp        TTLOG(ERROR,13)<<"["<<newParent->GetOrderIDString()<<" OnStart]: Failed to get account_id from params "<<endl;
main.cpp        TTLOG(ERROR,13)<<"["<<GetAlgoName()<<" OnStart]: Failed permission check. order_id="<<newParent->GetOrderIDString()<<" error="<<TTSDK_ERROR_STR[error]<<" sse_type="<<TTSDK_ORDER_SYNTHETIC_TYPE_STR[sse_type]<<" account_id="<<account_id<<"lu"<<endl;
main.cpp        TTLOG(ERROR,13)<<"["<<GetAlgoName()<<" OnStart]: Failed to get instrument from params order_id="<<newParent->GetOrderIDString()<<" error="<<TTSDK_ERROR_STR[error]<<" "<<endl;
main.cpp        TTLOG(ERROR,13)<<"["<<GetAlgoName()<<" OnStart]: Failed to download instrument order_id="<<newParent->GetOrderIDString()<<" instr="<<instrId<<"lu error="<<TTSDK_ERROR_STR[error]<<endl;
main.cpp        TTLOG(ERROR,13)<<"["<<GetAlgoName()<<" OnStart]: order_id="<<newParent->GetOrderIDString()<<" Validation Failed: "<<errorMsg<<endl;
main.cpp            TTLOG(ERROR,13)<<"["<<GetAlgoName()<<" OnStart]: Failed to open price subscription order_id="<<newParent->GetOrderIDString()<<" instr="<<instrId<<"lu error="<<TTSDK_ERROR_STR[to_underlying(error)]<<endl;
main.cpp        TTLOG(ERROR,13)<<"["<<GetAlgoName()<<" OnStart]: OnStartAlgo returned failure, rejecting order. order_id="<<newParent->GetOrderIDString()<<" instr="<<instrId<<"lu"<<endl;
main.cpp    TTLOG(INFO,13)<<"["<<newParent->GetOrderIDString()<<" OnStart]: Succeed! sse_type="<<TTSDK_ORDER_SYNTHETIC_TYPE_STR[sse_type]<<" "<<endl;
main.cpp        TTLOG(ERROR,13)<<"["<<GetAlgoName()<<" OnRecoverAlgo]: Failed to get instrument from params order_id="<<newParent->GetOrderIDString()<<" error="<<TTSDK_ERROR_STR[error]<<endl;
main.cpp         TTLOG(ERROR,13)<<error_msg<<endl;
main.cpp             TTLOG(ERROR,13)<<error_msg<<endl;
main.cpp        TTLOG(INFO,13)<<"["<<GetAlgoName()<<" OnRecoverAlgo]: order_id="<<newParent->GetOrderIDString()<<" Insert newParent="<<newParent.get()<<endl;
main.cpp        TTLOG(WARNING,13)<<"["<<GetAlgoName()<<" OnRecoverAlgo]: order_id="<<newParent->GetOrderIDString()<<" Found existing order="<<existing<<endl;
main.cpp    TTLOG(WARNING,13)<<"["<<GetAlgoName()<<" OnUpdateAlgo]: order_id="<<order_id_str<<" Order not found"<<endl;
main.cpp        TTLOG(ERROR,13)<<"["<<GetAlgoName()<<" OnResumeAlgo]: Failed to get instrument from params order_id="<<newParent->GetOrderIDString()<<" error="<<TTSDK_ERROR_STR[error]<<endl;
main.cpp         TTLOG(ERROR,13)<<error_msg<<endl;
main.cpp             TTLOG(ERROR,13)<<error_msg<<endl;
main.cpp        TTLOG(INFO,13)<<"["<<GetAlgoName()<<" OnResumeAlgo]: order_id="<<newParent->GetOrderIDString()<<" Insert newParent="<<newParent.get()<<endl;
main.cpp        TTLOG(WARNING,13)<<"["<<GetAlgoName()<<" OnResumeAlgo]: order_id="<<newParent->GetOrderIDString()<<" Found existing order="<<existing<<endl;
main.cpp        TTLOG(INFO,13)<<"["<<GetAlgoName()<<" OnPauseAlgo]: Call to OnPauseAlgo returned "<<TTSDK_ERROR_STR[result]<<" order_id="<<object->GetOrderIDString()<<endl;
main.cpp    TTLOG(WARNING,13)<<"["<<GetAlgoName()<<" OnPauseAlgo]: order_id="<<order_id_str<<" Order not found"<<endl;
main.cpp        TTLOG(INFO,13)<<"["<<GetAlgoName()<<" OnStopAlgo]: Call to OnStopAlgo returned "<<TTSDK_ERROR_STR[result]<<" order_id="<<object->GetOrderIDString()<<endl;
main.cpp    TTLOG(WARNING,13)<<"["<<GetAlgoName()<<" OnStopAlgo]: order_id="<<order_id_str<<" Order not found"<<endl;
main.cpp        TTLOG(INFO,13)<<"["<<GetAlgoName()<<" RegisterUserData]: Found order_id="<<order_id_str<<" in parentOrders collection and set algo_user_data"<<endl;
main.cpp    TTLOG(ERROR,13)<<"["<<GetAlgoName()<<" RegisterUserData]: Failed to find order_id="<<order_id_str<<" in parentOrders collection!"<<endl;
icebergparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildAdd: order_id="<<childOrder->GetOrderIDString()<<" limitPrc="<<limitPrice<<".8f OQ="<<orderQuantity<<".8f WQ="<<workingQuantity<<".8f"<<endl;
icebergparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReplace: external="<<external<<" requestsPending="<<requestsPending<<" isChildOrderPassing="<<isChildOrderPassing<<" child=[order_id="<<childOrder->GetOrderIDString()<<" price="<<limitPrice<<".8f order_qty="<<orderQuantity<<".8f working_qty="<<workingQuantity<<".8f] parent=[cum_qty="<<parentCumQty<<".8f order_qty="<<parentOrdQty<<".8f] ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<" ActivityBlockedReason="<<ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]<<" "<<endl;
icebergparent.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReplace unrelated to parent change!"<<endl;
icebergparent.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReplace: Increased parent qty from "<<parentOrdQty<<".8f to "<<newQuantity<<".8f"<<endl;
icebergparent.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] OnChildCancel: order_id="<<childOrder->GetOrderIDString()<<" external="<<external<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
icebergparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildFill: order_id="<<child_order->GetOrderIDString()<<" limit_price="<<limit_price<<".8f order_qty="<<order_quantity<<".8f working_qty="<<working_quantity<<".8f fill_qty="<<fill_quantity<<".8f fill_price="<<fill_price<<".8f fill_type="<<FILL_TYPE_STR[to_underlying(fill_type)]<<endl;
icebergparent.cpp    TTLOG(ERROR,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] OnChildRequestFailure: order_id="<<childOrder->GetOrderIDString()<<" requests_pending="<<requests_pending<<" status_flags=["<<OrderStatusFlagsString(status_flags)<<"] timeout="<<timeout<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
icebergparent.cpp    TTLOG(ERROR,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] OnChildReject: order_id="<<childOrder->GetOrderIDString()<<" external="<<external<<" requests_pending="<<requestsPending<<" message="<<message<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
icebergparent.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ParentOrderTestHarness: StartWorking: Scheduling custom event: event_type="<<GetTestHarness()->m_eventToScheduleInStartWorking<<endl;
icebergparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] StartWorking: Failed to calculate child price:"<<error_str<<endl;
icebergparent.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] StartWorking: Failed to add child order. error="<<TTSDK_ORDER_ERR_STR[error]<<endl;
icebergparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate: result="<<TTSDK_ERROR_STR[result]<<endl;
icebergparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate: old_disclosed_type="<<VALUE_TYPE_STR[to_underlying(GetDisclosedValueType())]<<" new_disclosed_value="<<VALUE_TYPE_STR[to_underlying(requestDiscValType)]<<" "<<endl;
icebergparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate: old_disclosed_value="<<GetDisclosedValue()<<".8f new_disclosed_value="<<disclosedVal<<".8f "<<endl;
icebergparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate: new display_qty="<<display_qty<<".8f "<<endl;
icebergparent.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] No child changes required"<<endl;
icebergparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate: Failed to change order. error="<<TTSDK_ORDER_ERR_STR[order_error]<<endl;
icebergparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleActionFinished: Activity blocked prevented slice from being added. reason="<<ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]<<endl;
icebergparent.cpp                 TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleActionFinished: Placing new slice."<<endl;
icebergparent.cpp                TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleActionFinished: No new slice needed, working_qty=0 but ASE child still active"<<endl;
icebergparent.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleActionFinished: No new slice needed. working_qty="<<childWrkQty<<".8f"<<endl;
icebergparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: order_qty="<<GetOrderQuantity()<<".8f limit_prc="<<GetLimitPrice()<<".8f trg_prc="<<GetTriggerPrice()<<".8f synth_status="<<GetSynthStatus()<<" cum_filled_qty="<<GetCumFillQuantity()<<".8f ladder_display="<<GetLadderDisplay()<<" order_type="<<TTSDK_OrderTypeToString(GetType())<<" "<<endl;
icebergparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Child Info: order_ptr="<<static_cast<void*>(childOrder.get())<<" order_id="<<childOrder->GetOrderIDString()<<" order_type="<<TTSDK_OrderTypeToString(childOrder->GetType())<<" order_side="<<childOrder->GetSide()<<" order_qty="<<childOrder->GetOrderQty()<<".8f filled_qty="<<childOrder->GetFilledQty()<<".8f order_working_qty="<<childOrder->GetWorkingQty()<<".8f order_prc="<<childOrder->GetLimitPrice()<<".8f order_trg_prc="<<childOrder->GetTriggerPrice()<<".8f time_sent="<<childOrder->GetTimeSent()<<"lu "<<endl;
icebergparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Child is "<<fp_gt(childOrder->GetWorkingQty()<<"! order_id="<<0.0)?"stillworking":"notworking"<<" order_working_qty="<<childOrder->GetOrderIDString()<<".8f childOrders_size="<<childOrder->GetWorkingQty()<<"u"<<endl;
icebergparent.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Iceberg order recovery failed. No child order!"<<endl;
icebergparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: mostRecentChild="<<mostRecentChild->GetOrderIDString()<<endl;
icebergparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: No working orders so sending new slice."<<endl;
icebergparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Primary order is still working, so no need to send a new slice."<<endl;
icebergparent.cpp                        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] SendNextSlice: m_childOrders is non-empty, so changing an existing SomChildOrder."<<endl;
icebergparent.cpp                    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] SendNextSlice: m_childOrders is empty, so adding a new SomChildOrder."<<endl;
icebergparent.cpp                    TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] SendNextSlice Failed: new_child_qty="<<slice_qty<<".8f child_prc="<<price<<".8f error="<<TTSDK_ORDER_ERR_STR[error]<<endl;
icebergparent.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] SendNextSlice: Failed to calculate child price:"<<price_error<<endl;
icebergparent.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] SendNextSlice: Not sending next slice. Either a UserAction is in progress or there is an ActivityBlockedReason. ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<" ActivityBlockedReason="<<ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]<<endl;
icebergparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: cause="<<GenerateSliceScheduleCauseAsString[cause]<<". About to clear current_schedule="<<GetSliceSummary()<<endl;
icebergparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] cause="<<GenerateSliceScheduleCauseAsString[cause]<<" No remaining qty to generate slice schedule"<<endl;
icebergparent.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] cause="<<GenerateSliceScheduleCauseAsString[cause]<<" GenerateSliceSchedule failed! remaining_qty="<<remaining_qty<<".0f disc_qty="<<disc_qty<<endl;
icebergparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] cause="<<GenerateSliceScheduleCauseAsString[cause]<<" GenerateSliceSchedule: new="<<GetSliceSummary()<<endl;
icebergparent.cpp    TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GetPlacedQuantity "<<placedQty<<".8f"<<endl;
autohedger.cpp        TTLOG(WARNING,13)<<"[AutoHedger:"<<GetOrderIDString()<<"] Unsubscribing from options service in destructor"<<endl;
autohedger.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildAdd: limitPrc="<<limitPrice<<".8f OQ="<<orderQuantity<<".8f WQ="<<workingQuantity<<".8f"<<endl;
autohedger.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReplace: order_id="<<childOrder->GetOrderIDString()<<" limitPrc="<<limitPrice<<".8f OQ="<<orderQuantity<<".8f WQ="<<workingQuantity<<".8f external="<<external<<" requestsPending="<<requestsPending<<endl;
autohedger.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: order_id="<<childOrder->GetOrderIDString()<<" external="<<external<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
autohedger.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: Dropping. m_optionsOrder=nullptr."<<endl;
autohedger.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: Dropping Hedge callback."<<endl;
autohedger.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildFill: order_id="<<child_order->GetOrderIDString()<<" limitPrc="<<limit_price<<".8f OQ="<<order_quantity<<".8f WQ="<<working_quantity<<".8f FQ="<<fill_quantity<<".8f FlPrc="<<fill_price<<".8f fill_type="<<FILL_TYPE_STR[to_underlying(fill_type)]<<endl;
autohedger.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildFill: Dropping callback - m_optionsOrder was unexpectedly a nullptr."<<endl;
autohedger.cpp    TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildRequestFailure: requests_pending="<<requests_pending<<" status_flags=["<<OrderStatusFlagsString(status_flags)<<"] timeout="<<timeout<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
autohedger.cpp    TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReject: order_id="<<childOrder->GetOrderIDString()<<" external="<<external<<" requests_pending="<<requestsPending<<" message="<<message<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
autohedger.cpp    TTLOG(DEBUG,13)<<"[AutoHedger:"<<GetOrderIDString()<<"] OnPositionReserveAdd instrument_id="<<instr_id<<"lu m_futuresInstrumentId="<<m_futuresInstrumentId<<"lu"<<endl;
autohedger.cpp                    TTLOG(ERROR,13)<<"[AutoHedger:"<<subscriberID<<"] delta callback with incorrect orderId; subscriptionID=("<<std::get<0>(subscriptionID)<<"lu, "<<std::get<1>(subscriptionID)<<") futures_instrument_id="<<futures_instrument_id<<"lu delta="<<delta<<".4f"<<endl;
autohedger.cpp                TTLOG(INFO,13)<<"[AutoHedger:"<<subscriberID<<"] futures_instrument_id="<<futures_instrument_id<<"lu delta="<<delta<<".4f"<<endl;
autohedger.cpp                TTLOG(DEBUG,13)<<"[AutoHedger:"<<subscriberID<<"], options-delta Callback on deleted order_id"<<endl;
autohedger.cpp                    TTLOG(ERROR,13)<<"[AutoHedger:"<<subscriberID<<"] delta callback with incorrect orderId; subscriptionID=("<<std::get<0>(subscriptionID)<<"lu, "<<std::get<1>(subscriptionID)<<") response_code="<<eventCode<<" message="<<message<<endl;
autohedger.cpp                TTLOG(INFO,13)<<"[AutoHedger:"<<subscriberID<<"] response_code="<<eventCode<<" message="<<message<<endl;
autohedger.cpp    TTLOG(INFO,13)<<"[AutoHedger:"<<GetOrderIDString()<<"] futures_instrument_id="<<futures_instrument_id<<"lu delta="<<delta<<".4f"<<endl;
autohedger.cpp    TTLOG(INFO,13)<<"[AutoHedger:"<<GetOrderIDString()<<"]:CheckAutoHedgerInitializationComplete .. m_autoHedgerInitFlags=0x"<<m_autoHedgerInitFlags<<", m_futuresInstrumentId="<<m_futuresInstrumentId<<"lu, m_optionsOrder="<<m_optionsOrder?1:0<<", m_hedgePROrder="<<m_hedgePROrder?1:0<<" m_hedgePROrder->IsWorking()="<<(m_hedgePROrder&&m_hedgePROrder->IsWorking())?1:0<<endl;
autohedger.cpp            TTLOG(ERROR,13)<<"[AutoHedger:"<<GetOrderIDString()<<"]:CheckAutoHedgerInitializationComplete: Failed to download underlying instrument m_futuresInstrumentId="<<m_futuresInstrumentId<<"lu error="<<TTSDK_ERROR_STR[download_error]<<endl;
autohedger.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: m_autoHedgerInitFlags=0x"<<m_autoHedgerInitFlags<<endl;
autohedger.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: Placing Position Reserve; hedgeInstrument_id="<<m_futuresInstrumentId<<"lu hedgeInstrumentName="<<TTSDK_GetInstrName(m_futures_instr)<<" pr_qty="<<prQty<<".8f"<<endl;
autohedger.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: Hedge Position Reserve failed. pr_qty="<<prQty<<".8f"<<endl;
autohedger.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] StartWorking: Failed to calculate child price:"<<error<<endl;
autohedger.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Add m_optionsOrder="<<(void*)m_optionsOrder.get()<<endl;
autohedger.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] INIT_HEDGE_PR"<<endl;
autohedger.cpp    TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate should not be called"<<endl;
autohedger.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Printing algo params: order_qty="<<GetOrderQuantity()<<"8f limit_prc="<<GetLimitPrice()<<".8f synth_status="<<TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]<<" order_type="<<TTSDK_OrderTypeToString(GetType())<<endl;
autohedger.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Iterating through attached SomChildOrders, hedging each fill in a piece-meal fashion."<<endl;
autohedger.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Order Info: order_ptr="<<static_cast<void*>(childOrder.get())<<" order_id="<<childOrder->GetOrderIDString()<<" order_type="<<TTSDK_OrderTypeToString(childOrder->GetType())<<" order_side="<<childOrder->GetSide()<<" order_qty="<<childOrder->GetOrderQty()<<".8f order_working_qty="<<childOrder->GetWorkingQty()<<".8f order_prc="<<childOrder->GetLimitPrice()<<".8f order_trg_prc="<<childOrder->GetTriggerPrice()<<".8f "<<endl;
autohedger.cpp                TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Duplicate m_optionsOrder detected - the recovery process will fail."<<endl;
autohedger.cpp                TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: m_optionsOrder="<<(void*)m_optionsOrder.get()<<endl;
autohedger.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Fills while algo was down do not send hedge. detected_fill_qty="<<cumFillQty<<".8f, m_cumFillQty="<<m_cumFillQty<<".8f"<<endl;
autohedger.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: AutoHedger order recovery failed due to an unexpected scenario: failureOccurred="<<failureOccurred?"true":"false"<<" m_optionsOrder="<<m_optionsOrder==nullptr?"nullptr":"Notworking"<<endl;
autohedger.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HedgePrimaryFill: No action, No futures instrument_id or delta"<<endl;
autohedger.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: Hedge order fillQty="<<fill_quantity<<".8f hedgeQty="<<hedgeQty<<".8f, m_unhedgedQty="<<m_unhedgedQty<<".8f"<<endl;
autohedger.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Add hedgeOrder="<<(void*)hedgeOrder.get()<<endl;
autohedger.cpp            TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] SendSuspendStatus on disconnect syn_status="<<TTSDK_SYNTH_STATUS_STR[status]<<endl;
autohedger.cpp                TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] SendSuspendStatus on disconnect m_autoHedgerOrderType="<<m_autoHedgerOptionOrderType<<"; NativeStopTriggered=false"<<endl;
autohedger.cpp                TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandlePriceError: Disconnect Ignored m_autoHedgerOrderType="<<m_autoHedgerOptionOrderType<<"; m_optionsOrder="<<m_optionsOrder?"Exist":"Notexist"<<"; NativeStopTriggered="<<m_optionsOrder?std::to_string(m_optionsOrder->NativeStopTriggered()):"N/A"<<endl;
autohedger.cpp            TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandlePriceError: Disconnect Ignored syn_status="<<TTSDK_SYNTH_STATUS_STR[status]<<endl;
singlechildparent.cpp        TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] StartWorking: Publishing trigger report: last_trg_qty="<<GetLastTrgQty()<<".8f trg_prc="<<GetTriggerPrice()<<".8f"<<endl;
singlechildparent.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandleUpdate: synth_status="<<TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]<<" childOrdersSize="<<this->m_childOrders.size()<<"d childPRExists="<<m_childPR?std::string("true"):std::string("false")<<endl;
singlechildparent.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandleUpdate: Sending requests with the following (note: some fields may be invalid depending on the sequence): pending_change_subtasks="<<std::to_string(m_pending_change_subtasks)<<" target_price="<<m_targetNewPrice<<".8f target_qty="<<m_targetNewQty<<".8f target_pr_qty="<<m_targetPRQty<<".8f"<<endl;
singlechildparent.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandleUpdate: ProcessPendingChangeTasks returned error="<<TTSDK_ERROR_STR[error]<<endl;
singlechildparent.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] OnChildAdd: order_id="<<childOrder->GetOrderIDString()<<" limitPrc="<<limitPrice<<".8f OQ="<<orderQuantity<<".8f WQ="<<workingQuantity<<".8f"<<endl;
singlechildparent.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] OnChildReplace: order_id="<<childOrder->GetOrderIDString()<<" price="<<limitPrice<<".8f order_qty="<<orderQuantity<<".8f working_qty="<<workingQuantity<<".8f external="<<external<<" requests_pending="<<requestsPending<<endl;
singlechildparent.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] OnChildCancel: order_id="<<childOrder->GetOrderIDString()<<" external="<<external<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
singlechildparent.cpp    TTLOG(ERROR,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] OnChildRequestFailure: order_id="<<childOrder->GetOrderIDString()<<" requests_pending="<<requests_pending<<" status_flags=["<<OrderStatusFlagsString(status_flags)<<"] timeout="<<timeout<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
singlechildparent.cpp    TTLOG(ERROR,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] OnChildReject: order_id="<<childOrder->GetOrderIDString()<<" external="<<external<<" requests_pending="<<requestsPending<<" message="<<message<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
singlechildparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: order_qty="<<GetOrderQuantity()<<".8f limit_prc="<<GetLimitPrice()<<".8f trg_prc="<<GetTriggerPrice()<<".8f synth_status="<<GetSynthStatus()<<" cum_filled_qty="<<GetCumFillQuantity()<<".8f ladder_display="<<GetLadderDisplay()<<" order_type="<<TTSDK_OrderTypeToString(GetType())<<" children_size="<<children_size<<endl;
singlechildparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Child Info: order_ptr="<<static_cast<void*>(childOrder.get())<<" order_id="<<childOrder->GetOrderIDString()<<" order_type="<<TTSDK_OrderTypeToString(childOrder->GetType())<<" order_side="<<childOrder->GetSide()<<" order_qty="<<childOrder->GetOrderQty()<<".8f filled_qty="<<childOrder->GetFilledQty()<<".8f order_working_qty="<<childOrder->GetWorkingQty()<<".8f order_prc="<<childOrder->GetLimitPrice()<<".8f order_trg_prc="<<childOrder->GetTriggerPrice()<<".8f time_sent="<<childOrder->GetTimeSent()<<"lu "<<endl;
singlechildparent.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: no triggered_child found."<<endl;
singlechildparent.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: triggered_child not working"<<endl;
timeduration.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Invalid Child TIF child_tif="<<child_tif<<endl;
timeduration.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] End time is in the past. now="<<now.time_since_epoch().count()<<"ld end_time="<<m_endTime.time_since_epoch().count()<<"ld"<<endl;
timeduration.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Start time updated to current time. old_start="<<m_startTime.time_since_epoch().count()<<"ld new_start="<<now.time_since_epoch().count()<<"ld end_time="<<m_endTime.time_since_epoch().count()<<"ld"<<endl;
timeduration.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] StartWorking. start_time="<<m_startTime.time_since_epoch().count()<<"ld end_time="<<m_endTime.time_since_epoch().count()<<"ld duration="<<m_duration.count()<<"ld"<<endl;
timeduration.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Failed to arm timer. start_time="<<t<<"lu"<<endl;
timeduration.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] StartWaiting failed to create timer. error="<<ex.what()<<endl;
timeduration.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ActuallyStartWorking failed to create timer. error="<<ex.what()<<endl;
timeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleTimeSliceEvent: Ready to send next slice. timeslice_revision="<<timeSliceRevision<<"u schedule_revision="<<curTimeSliceRevision<<"u slice_state_info="<<std::to_string(isInSlicingMode)<<endl;
timeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleTimeSliceEvent determined that the next slice can't be honored due to an invalid state. timeslice_revision="<<timeSliceRevision<<"u schedule_revision="<<curTimeSliceRevision<<"u slice_state_info="<<std::to_string(isInSlicingMode)<<endl;
timeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleTimeSliceEvent: Skipping half life event timeslice_revision="<<timeSliceRevision<<"u schedule_revision="<<curTimeSliceRevision<<"u slice_state_info="<<std::to_string(isInSlicingMode)<<endl;
timeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleHalfLifeEvent applying leftover action at half life"<<endl;
timeduration.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleHalfLifeEvent triggered without leftover action time == half life"<<endl;
timeduration.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReplace: completed and now requires a new schedule. Generating now. is_external="<<is_external<<" is_request_pending="<<is_request_pending<<" slice_state_info="<<std::to_string(isInSlicingMode)<<" WQ="<<working_qty<<".8f prev_working_qty="<<child->GetPrevOrderInfo().working_quantity<<".8f"<<endl;
timeduration.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReplace: determined that generating and slicing was not applicable. is_external="<<is_external<<" is_request_pending="<<is_request_pending<<" slice_state_info="<<std::to_string(isInSlicingMode)<<" WQ="<<working_qty<<".8f prev_working_qty="<<child->GetPrevOrderInfo().working_quantity<<".8f"<<endl;
timeduration.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: completed and now requires a new schedule. Generating now. is_external="<<is_external<<" slice_state_info="<<std::to_string(isInSlicingMode)<<endl;
timeduration.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: determined that generating and slicing was not applicable. is_external="<<is_external<<" slice_state_info="<<std::to_string(isInSlicingMode)<<endl;
timeduration.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandlePostDurationChange: All children have been detected as cancelled and running duration has ended. Tearing down algo. duration="<<m_duration.count()<<"ld"<<endl;
timeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandlePostDurationChange: Adjusting Parent Order Qty. old_order_qty="<<orderQty<<".8f new_order_qty="<<placedQty<<".8f"<<endl;
timeduration.cpp            TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ValidateUpdate: Encountered an attempt to change order quantity after duration lapsed. duration="<<calc_duration.count()<<".8f requested_order_qty="<<requested_ord_qty<<".8f current_order_qty="<<current_ord_qty<<".8f"<<endl;
timeduration.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ValidateUpdate: is_duration_based="<<is_duration_based<<" has_request_dur="<<has_request_dur<<" has_request_dur_unit="<<has_request_dur_unit<<" request_dur="<<request_dur<<"d request_dur_unit="<<request_dur_unit<<" has_request_start_ms="<<has_request_start_ms<<" has_request_end_ms="<<has_request_end_ms<<" request_start_ms="<<request_start_ms<<"d request_end_ms="<<request_end_ms<<"d "<<endl;
timeduration.cpp            TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ValidateUpdate: Cannot change the duration type from \Duration\ to \Start/End\"<<endl;
timeduration.cpp            TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ValidateUpdate: Cannot change the duration type from \Start/End\ to \Duration\"<<endl;
timeduration.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ValidateUpdate: start_ms="<<start_ms<<"d end_ms="<<end_ms<<"d dur_unit="<<dur_unit<<" dur="<<dur<<"d interval="<<interval<<" disc_qty="<<disc_qty<<".8f value_type="<<value_type<<" is_duration_based="<<is_duration_based<<" request_start_ms="<<request_start_ms<<"d request_end_ms="<<request_end_ms<<"d request_dur_unit="<<request_dur_unit<<" request_dur="<<request_dur<<"d request_interval="<<request_interval<<" request_disc_qty="<<request_disc_qty<<".8f request_value_type="<<(int)request_value_type<<" "<<endl;
timeduration.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ValidateUpdate: Cannot change the interval from "<<interval<<" to "<<request_interval<<endl;
timeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ValidateUpdate: Ensuring that new_end is in the future: now="<<now.time_since_epoch()<<"ld old_end="<<m_endTime.time_since_epoch()<<"ld new_end="<<new_end.time_since_epoch()<<"ld"<<endl;
timeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate: completed and now requires a new schedule. Generating now. result="<<TTSDK_ERROR_STR[result]<<" slice_state_info="<<std::to_string(isInSlicingMode)<<" OldWQ="<<old_qty<<".8f WQ="<<new_qty<<".8f has_timing_changed="<<has_timing_changed<<endl;
timeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate: determined that generating and slicing was not applicable. result="<<TTSDK_ERROR_STR[result]<<" slice_state_info="<<std::to_string(isInSlicingMode)<<" OldWQ="<<old_qty<<".8f WQ="<<new_qty<<".8f has_timing_changed="<<has_timing_changed<<endl;
timeduration.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleActionFinished(UserAction::Change): Change completed which requires a new schedule. Generating now. slice_state_info="<<std::to_string(isInSlicingMode)<<endl;
timeduration.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleActionFinished(UserAction::Change): determined that generating and slicing was not applicable. slice_state_info="<<std::to_string(isInSlicingMode)<<" was_action_successful="<<wasActionSuccessful?"true":"false"<<endl;
timeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnStopAlgo: Stop slice timer"<<endl;
timeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnStopAlgo: Stop half life timer"<<endl;
timeduration.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateAndStartSlicing: No remaining qty to generate slice schedule."<<endl;
timeduration.cpp                TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] SliceAndScheduleTimer: Failed to arm half life timer. interval="<<slice_time<<"lu"<<endl;
timeduration.cpp                TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] SliceAndScheduleTimer: Failed to arm slice timer. interval="<<slice_time<<"lu"<<endl;
timeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] SliceAndScheduleTimer: determine that the timer doesn't need to be reset."<<endl;
timeduration.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: order_qty="<<order_qty<<".8f placed_qty="<<placed_qty<<".8f recalculate="<<recalculate<<endl;
timeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: No remaining qty to generate slice schedule. schedule_revision="<<newRevision<<"u remaining_qty="<<remaining_qty<<".8f"<<endl;
timeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: Duration reduced. duration="<<m_duration.count()<<"ld schedule_revision="<<newRevision<<"u"<<endl;
timeduration.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: Unable to generate slice schedule. disc_value="<<GetDisclosedValue()<<".8f disc_value_type="<<VALUE_TYPE_STR[to_underlying(GetDisclosedValueType())]<<" interval="<<m_interval.count()<<"ld schedule_revision="<<newRevision<<"u"<<endl;
timeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: Generated new slice schedule. schedule_revision="<<newRevision<<"u "<<GetSliceSummary()<<endl;
timeduration.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] UpdateTimeDurationParamsForSyncChange: Comparing now vs. generic_start_time for update to Duration Start Time: now="<<now.time_since_epoch()<<"ld generic_start_time="<<generic_start_time.time_since_epoch()<<"ld"<<endl;
timeduration.cpp            TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] UpdateTimeDurationParamsForSyncChange: We are PAST the Generic Start Time!"<<endl;
timeduration.cpp            TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] UpdateTimeDurationParamsForSyncChange: We are BEFORE the Generic Start Time!"<<endl;
timeduration.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] UpdateTimeDurationParamsForSyncChange: Comparing now vs. generic_start_time for update to Duration End Time: now="<<now.time_since_epoch()<<"ld generic_start_time="<<generic_start_time.time_since_epoch()<<"ld"<<endl;
timeduration.cpp            TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] UpdateTimeDurationParamsForSyncChange: We are PAST the Generic Start Time!"<<endl;
timeduration.cpp            TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] UpdateTimeDurationParamsForSyncChange: We are BEFORE the Generic Start Time!"<<endl;
timeduration.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] UpdateTimeDurationParamsForSyncChange: Failed to compute new End Time using new Duration and/or new Duration Base Unit! This is unexpected and the user change will be ignored!"<<endl;
timeduration.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] UpdateTimeDurationParamsForSyncChange: Updated params: [Params for when DurationType=StartEnd: request_start_ms="<<request_start_ms<<"lu request_end_ms="<<request_end_ms<<"lu] [Params for when DurationType=Duration: request_dur_unit="<<static_cast<int>(request_dur_unit)<<" request_dur="<<request_dur<<"] [Params for when SliceType=Interval: request_interval="<<request_interval<<"] [Params for when SliceType=Disclosed: request_disc_qty="<<request_disc_qty<<" request_value_type="<<static_cast<int>(request_value_type)<<"] [General Params (in ms): now="<<now.time_since_epoch()<<"ld m_startTime="<<m_startTime.time_since_epoch()<<"ld m_endTime="<<m_endTime.time_since_epoch()<<"ld m_duration="<<m_duration.count()<<"ld]"<<endl;
timeduration.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ComputeNewEndTime: m_endTime was uninitialized!"<<endl;
timeduration.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ComputeNewEndTime: [old_duration_raw="<<old_duration_raw<<"ld old_duration_unit="<<static_cast<int>(old_duration_unit)<<" old_duration_ms="<<old_duration_ms.count()<<"ld] [new_duration_raw="<<new_duration_raw<<"ld new_duration_unit="<<static_cast<int>(new_duration_unit)<<" new_duration_ms="<<new_duration_ms.count()<<"ld] [old_end_time="<<old_end_time.time_since_epoch()<<"ld new_end_time="<<new_end_time.time_since_epoch()<<"ld]"<<endl;
timeduration.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: EndTime has passed so new schedule is not applicable. Skipping. duration="<<m_duration.count()<<"ld schedule_revision="<<newRevision<<"u"<<endl;
timeduration.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: Interval is greater than the duration. Generating a single slice. interval="<<m_interval.count()<<"ld num_slices="<<num_slices<<"ld existing_slices="<<existing_slices<<"ld duration="<<m_duration.count()<<"ld required_qty="<<required_qty<<".8f schedule_revision="<<newRevision<<"u"<<endl;
timeduration.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: Executing GenerateIntervalBasedSlices. required_qty="<<required_qty<<".8f num_slices="<<num_slices<<"u existing_slices="<<existing_slices<<"ld variance="<<variance<<" min_qty="<<min_qty<<".8f seed="<<m_seed<<" schedule_seed="<<GetScheduleSeed()<<" schedule_revision="<<newRevision<<"u"<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"[Factory]: Create Parent: order_id="<<m_order_id_str<<" algo="<<m_name<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: Destruction! And will UnSubscribePrice"<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: OnPositionReserveAdd: order_id="<<m_childPR->GetOrderIDString()<<" OQ="<<m_childPR->GetInflightOrderQty()<<".8f ActivityBlockedReason="<<ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<" "<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: CheckInitializationProgress flags="<<m_initFlags<<endl;
parentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: CheckInitializationProgress: Setting exec_restatement_reason to: ORDER_ACCEPTED"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Exempt from check given the algo type: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Exempt from check since instrument is synthetic: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: GetEnableAlgoRiskChecks Failed: account_id="<<GetAccountID()<<"lu error="<<error_msg<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Exempt from check since Algo Risk Check is disabled: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Outright OneMinTicks param not set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Failed to retrieve Outright OneMinTicks param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Outright OneMinPercent param not set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Failed to retrieve Outright OneMinPercent param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Outright ThreeMinTicks param not set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Failed to retrieve Outright ThreeMinTicks param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Outright ThreeMinPercent param not set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Failed to retrieve Outright ThreeMinPercent param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Outright LifetimeTicks param not set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Failed to retrieve Outright LifetimeTicks param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Outright LifetimePercent param not set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Failed to retrieve Outright LifetimePercent param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Spread OneMinTicks param not set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Failed to retrieve Spread OneMinTicks param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Spread OneMinPercent param not set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Failed to retrieve Spread OneMinPercent param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Spread ThreeMinTicks param not set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Failed to retrieve Spread ThreeMinTicks param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Spread ThreeMinPercent param not set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Failed to retrieve Spread ThreeMinPercent param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Spread LifetimeTicks param not set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Failed to retrieve Spread LifetimeTicks param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Spread LifetimePercent param not set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Failed to retrieve Spread LifetimePercent param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: [is_spread_or_strategy] param not set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Failed to retrieve [is_spread_or_strategy] param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules: Exempt from check since no limits are set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetPriceDriftCheckRules (zero means not set): pdci_one_min_ticks="<<risk_limits.pdci_one_min_ticks<<" pdci_one_min_pct="<<risk_limits.pdci_one_min_pct<<" pdci_three_min_ticks="<<risk_limits.pdci_three_min_ticks<<" pdci_three_min_pct="<<risk_limits.pdci_three_min_pct<<" pdci_lifetime_ticks="<<risk_limits.pdci_lifetime_ticks<<" pdci_lifetime_pct="<<risk_limits.pdci_lifetime_pct<<" spdci_one_min_ticks="<<risk_limits.spdci_one_min_ticks<<" spdci_one_min_pct="<<risk_limits.spdci_one_min_pct<<" spdci_three_min_ticks="<<risk_limits.spdci_three_min_ticks<<" spdci_three_min_pct="<<risk_limits.spdci_three_min_pct<<" spdci_lifetime_ticks="<<risk_limits.spdci_lifetime_ticks<<" spdci_lifetime_pct="<<risk_limits.spdci_lifetime_pct<<" is_spread_or_strategy="<<risk_limits.is_spread_or_strategy<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetAverageTradeSizeChecker: Exempt from check since instrument is synthetic: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetAverageTradeSizeChecker: GetEnableAlgoRiskChecks Failed: error="<<error_msg<<" account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetAverageTradeSizeChecker: Exempt from check since Algo Risk Check is disabled: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetAverageTradeSizeChecker: Failed to retrieve MaxChildSliceSize param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetAverageTradeSizeChecker: Exempt from check since Max Child Slice Percentage is not set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetAverageTradeSizeChecker: account_id="<<GetAccountID()<<"lu max_child_slice_size="<<risk_limits.max_child_slice_size<<"u"<<endl;
parentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetAverageTradeSizeChecker: Failed to retrieve AverageTradeSize param during recovery: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetAverageTradeSizeChecker: Retrieved AverageTradeSize from params during recovery: account_id="<<GetAccountID()<<"lu average_trade_size="<<average_trade_size<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetAverageTradeSizeChecker: Spawning one-off worker thread to perform HDS download: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetMaxOrderRateChecker: Exempt from check since instrument is synthetic: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetMaxOrderRateChecker: GetEnableAlgoRiskChecks Failed: account_id="<<GetAccountID()<<"lu error="<<error_msg<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetMaxOrderRateChecker: Exempt from check since Algo Risk Check is disabled: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetMaxOrderRateChecker: Failed to retrieve MaxNumberOfCancels param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetMaxOrderRateChecker: Failed to retrieve MaxNumberOfUpdates param: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetMaxOrderRateChecker: Exempt from check since both Max Number Of Cancels and Max Number Of Updates are not set: account_id="<<GetAccountID()<<"lu"<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SetMaxOrderRateChecker: m_account_id="<<GetAccountID()<<"lu m_max_number_of_updates="<<risk_limits.max_number_of_updates<<" m_max_number_of_cancels="<<risk_limits.max_number_of_cancels<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: OnStartAlgo: Starting algo"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] marking PR initialized: enabled="<<env::instance().is_sse_pr_enabled()<<" supported="<<SupportsPR()<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] marking Price subscribed:"<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: OnStartAlgo: Finished. success="<<success<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: Placing Position Reserve. pr_qty="<<pr_qty<<".8f"<<endl;
parentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: Placing Position Reserve failed. pr_qty="<<pr_qty<<".8f"<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: OnRecoverAlgo: Recovering algo. error_code="<<TTSDK_ERROR_STR[error_code]<<" error_msg="<<error_msg<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: Parent marking PR initialized. enabled="<<env::instance().is_sse_pr_enabled()<<" supported="<<SupportsPR()<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: OnResumeAlgo: Resuming algo. error_code="<<TTSDK_ERROR_STR[error_code]<<" error_msg="<<error_msg<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: Parent marking PR initialized. enabled="<<env::instance().is_sse_pr_enabled()<<" supported="<<SupportsPR()<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: OnScheduledEvent: StopAlgo"<<endl;
parentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: OnScheduledEvent(HDSDownloadResponse): Failing algo because HDS download response arrived at an unexpected algo state: activity_blocked_reason="<<ACTIVITY_BLOCK_STR[static_cast<unsignedchar>(activity_blocked_reason)]<<endl;
parentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: OnScheduledEvent(HDSDownloadResponse): Failing algo because HDS download failed"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: OnScheduledEvent(HDSDownloadResponse): HDS download successful: average_trade_size="<<hds_response->average_trade_size<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: OnScheduledEvent: FailAlgo"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: UpdateParamsForStop: Full fill. fill_qty="<<fill_qty<<".8f fill_price="<<fill_price<<".8f cum_qty="<<m_cum_fill_qty<<".8f OQ="<<GetOrderQuantity()<<".8f"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: UpdateParamsForStop: Cancelled. cum_qty="<<m_cum_fill_qty<<".8f OQ="<<GetOrderQuantity()<<".8f"<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: Stop Requested."<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: CompleteAction: working_qty="<<working_qty<<".8f display_qty="<<display_qty<<".8f ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<" "<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CompleteAction: Failed to promote FIX params for accept response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" IGNORE this warning if FIX is not involved!"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CompleteAction: Promoted FIX params for accept response"<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CompleteAction: Failed to promote cl_ord_id params: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" "<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CompleteAction: Promoted cl_ord_id params: cl_ord_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu"<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: CompleteEndTimeAction: working_qty="<<working_qty<<".8f display_qty="<<display_qty<<".8f ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<" "<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: CompleteDelete: ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: CompletePause: ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CompletePause: Failed to promote cl_ord_id params: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" "<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CompletePause: Promoted cl_ord_id params: cl_ord_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu"<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: RejectAction: ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<" reason="<<message<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"[ParentOrder:"<<GetOrderIDString()<<"]: UpdateParamsForSyncChange: requested_qty="<<new_order_qty<<".8f requested_prc="<<new_order_prc<<".8f requested_working_qty="<<working_qty<<".8f new_qty="<<GetOrderQuantity()<<".8f new_prc="<<GetLimitPrice()<<".8f new_working_qty="<<GetWorkingQuantity()<<".8f"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SendFill sending update to account for overfill. cum_fill_qty="<<m_cum_fill_qty<<".8f fill_qty="<<fill_qty<<".8f OQ="<<GetOrderQuantity()<<".8f new_ord_qty="<<new_ord_qty<<".8f"<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SendFill. fill_qty="<<fill_qty<<".8f fill_price="<<fill_price<<".8f cum_qty="<<m_cum_fill_qty<<".8f OQ="<<GetOrderQuantity()<<".8f child_fill=[order_id="<<child_id<<", order_sequence="<<order_sequence<<"lu, trade_date="<<trade_date<<"lu, ] fills_grp_size="<<out_params->fills_grp.fills_grp_size<<"u serialized_size="<<out_params->fills_grp.struct_size<<"u "<<endl;
parentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SendFill: Suppressed scheduling a (redundant) stop since algo is already stopping. action_in_progress="<<USER_ACTION_STR[to_underlying(action_in_progress)]<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: SendUpdate. force_send="<<force_send<<" wq="<<working_qty<<".8f disp_qty="<<display_qty<<".8f oq="<<GetOrderQuantity()<<".8f ot="<<TTSDK_OrderTypeToString((ttsdk_order_type)GetType())<<" tif="<<TTSDK_TIFToString((ttsdk_time_in_force)GetTIF())<<" synth_status="<<TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]<<" last_wq="<<m_lastUpdate.working_quantity<<".8f last_disp_qty="<<m_lastUpdate.display_quantity<<".8f last_oq="<<m_lastUpdate.order_quantity<<".8f last_ot="<<TTSDK_OrderTypeToString((ttsdk_order_type)m_lastUpdate.orderType)<<" last_tif="<<TTSDK_TIFToString((ttsdk_time_in_force)m_lastUpdate.time_in_force)<<" last_synth_status="<<TTSDK_SYNTH_STATUS_STR[m_lastUpdate.synth_status]<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] RequestFail. reason="<<msg<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnError. error="<<error<<" current_action="<<ACTIVITY_BLOCK_STR[static_cast<unsignedchar>(m_activityBlockedReason)]<<" synth_status="<<TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]<<endl;
parentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ignore tick_size_change. synth_status="<<TTSDK_SYNTH_STATUS_STR[current_synth_status]<<"."<<endl;
parentorder.cpp                TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Handle tick_size_change: Re-Download instrument. synth_status="<<TTSDK_SYNTH_STATUS_STR[current_synth_status]<<" tick_table_id="<<before_tick_table_id<<"lu new_tick_table_id="<<(reinterpret_cast<ttsdk_instr_data*>(m_instr))->tick_table_id<<"lu count="<<before_count<<" new_count="<<m_instr_snap->tick_table.count<<" tick_size="<<before_tick_size<<"f new_tick_size="<<m_instr_snap->tick_size<<"f"<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] SetActivityBlockedReason. old="<<ACTIVITY_BLOCK_STR[static_cast<unsignedchar>(m_activityBlockedReason)]<<" new="<<ACTIVITY_BLOCK_STR[static_cast<unsignedchar>(reason)]<<endl;
parentorder.cpp     TTLOG(INFO,13)<<ss.str()<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] SetActionInProgress. old="<<USER_ACTION_STR[to_underlying(m_action_in_progress)]<<" new="<<USER_ACTION_STR[to_underlying(action)]<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ClearActionInProgress. last_action="<<USER_ACTION_STR[to_underlying(last)]<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Clear ChangeSubTask current="<<CHANGE_SUBTASK_STR[to_underlying(m_change_subtask)]<<" "<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Set ChangeSubTask current="<<CHANGE_SUBTASK_STR[to_underlying(m_change_subtask)]<<" new="<<CHANGE_SUBTASK_STR[to_underlying(task)]<<" "<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Clear DeletionSubTask current="<<DELETION_SUBTASK_STR[to_underlying(m_deletion_sub_task)]<<" "<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Set DeletionSubTask current="<<DELETION_SUBTASK_STR[to_underlying(m_deletion_sub_task)]<<" new="<<DELETION_SUBTASK_STR[to_underlying(task)]<<" "<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Clear PauseSubTask current="<<PAUSE_SUBTASK_STR[to_underlying(m_pause_sub_task)]<<" "<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Set PauseSubTask current="<<PAUSE_SUBTASK_STR[to_underlying(m_pause_sub_task)]<<" new="<<PAUSE_SUBTASK_STR[to_underlying(task)]<<" "<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Clear ETAGoToMarketSubTask. current="<<ETA_GOTOMARKET_SUBTASK_STR[to_underlying(m_eta_gotomarket_sub_task)]<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Set ETAGoToMarketSubTask. current="<<ETA_GOTOMARKET_SUBTASK_STR[to_underlying(m_eta_gotomarket_sub_task)]<<" new="<<ETA_GOTOMARKET_SUBTASK_STR[to_underlying(task)]<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] RecoverySubTask current="<<RECOVERY_SUBTASK_STR[to_underlying(m_recovery_subtask)]<<" new="<<RECOVERY_SUBTASK_STR[to_underlying(task)]<<" "<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeSubTask current="<<RESUME_SUBTASK_STR[to_underlying(m_resume_subtask)]<<" new="<<RESUME_SUBTASK_STR[to_underlying(task)]<<" "<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] SetForfeitRecovery: new_val="<<new_val<<" reason="<<reason<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] SetForfeitResume: new_val="<<new_val<<" reason="<<reason<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckOTTIF encountered a synthetic instrument. instrument_id="<<GetInstrID()<<"lu name="<<instr_data->name<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckOTTIF encountered instrument with no product! instrument_id="<<GetInstrID()<<"lu product_id="<<instr_data->instr_snap.product_id<<"lu name="<<instr_data->name<<endl;
parentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckOTTIF failed to find OTTIF but SSE will start anyway! product_id="<<instr_data->instr_snap.product_id<<"lu required_ottif="<<required_ottif_str<<endl;
parentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckOTTIF check passed. required_ottif="<<required_ottif_str<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckOTTIF check failed. product_id="<<instr_data->instr_snap.product_id<<"lu symbol="<<instr_data->product->symbol<<" supported_ottif=["<<tt::algoutil::print::ToString(instr_data->product->ottif.entries)<<"] required_ottif="<<required_ottif_str<<endl;
parentorder.cpp    TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildResurrected: Child order (order_id="<<childOrder->GetOrderIDString()<<") resurrected unexpectedly! Failing algo!"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildOrderEvent: Receive Xfer Full Fill"<<endl;
parentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ProcessPendingChangeTasks: Empty"<<endl;
parentorder.cpp            TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ProcessPendingChangeTasks: task=None"<<endl;
parentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ProcessPendingChangeTasks: task=ChangeChildren"<<endl;
parentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ProcessPendingChangeTasks: task=ChangePositionReserve"<<endl;
parentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ChangePositionReserve: m_childPR=nullptr"<<endl;
parentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate:SetChangeSubTasks: [currentPrc="<<currentPrice<<".8f requestPrc="<<requestPrice<<".8f] [currentQty="<<currentQty<<".8f requstQty="<<requestQty<<".8f] pending_changes="<<std::to_string(m_pending_change_subtasks)<<" "<<endl;
parentorder.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckAverageTradeSize: Exempt!"<<endl;
parentorder.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] UpdateAndCheckMaxOrderRate: Exempt!"<<endl;
parentorder.cpp    TTLOG(INFO,13)<<""<<ss.str()<<endl;
slicerparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnScheduledEvent: CompleteSlicerActionAsDelete fired"<<endl;
slicerparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildAdd. limitPrc="<<limitPrice<<".8f OQ="<<orderQuantity<<".8f WQ="<<workingQuantity<<".8f"<<endl;
slicerparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReplace. limitPrc="<<limitPrice<<".8f OQ="<<orderQuantity<<".8f WQ="<<workingQuantity<<".8f external="<<external<<" requestsPending="<<requestsPending<<endl;
slicerparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel. order_id="<<childOrder->GetOrderIDString()<<" external="<<external<<" GetActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<" any_child_inflight="<<isAnyChildInflight<<endl;
slicerparent.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel. Setting change to stop when completed. req_ord_qty="<<new_ord_qty<<".8f cum_filled_qty="<<cum_filled<<".8f"<<endl;
slicerparent.cpp    TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildRequestFailure. requests_pending="<<requests_pending<<" status_flags=["<<status_flags&ttsdk_external_order_event?"external_order_event|":""<<""<<status_flags&ttsdk_risk_reject_event?"risk_reject_event|":""<<""<<status_flags&ttsdk_max_order_rate_reject_event?"max_order_rate_reject_event|":""<<""<<status_flags&ttsdk_order_download_failed_event?"order_download_failed_event|":""<<"] timeout="<<timeout<<" action_in_progress="<<GetActionInProgress()<<endl;
slicerparent.cpp    TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReject. external="<<external<<" requests_pending="<<requestsPending<<" message="<<(message!=nullptr)?std::string(message):""<<" action_in_progress="<<GetActionInProgress()<<endl;
slicerparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate. result="<<TTSDK_ERROR_STR[result]<<endl;
slicerparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleActionFinished. perform_pending="<<performPending<<" last_action="<<USER_ACTION_STR[to_underlying(lastAction)]<<" was_action_successful="<<wasActionSuccessful?"true":"false"<<endl;
slicerparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] SendQtySafeUpdate: Increased parent qty. old_qty="<<orderQty<<".8f new_qty="<<newOrderQty<<".8f placed_qty="<<placedQty<<".8f"<<endl;
slicerparent.cpp                TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] MergeLeftoverAction: No quantity for next slice, nothing to merge to."<<endl;
slicerparent.cpp                TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] MergeLeftoverAction: Failed to change order. error="<<TTSDK_ORDER_ERR_STR[error]<<endl;
slicerparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] PayUpLeftoverAction: called for child orders size="<<m_childOrders.size()<<"u"<<endl;
slicerparent.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] PayUpLeftoverAction: child failed to apply leftover. error="<<TTSDK_ORDER_ERR_STR[error]<<endl;
slicerparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GoToMarketLeftoverAction: called for child orders size="<<m_childOrders.size()<<"u"<<endl;
slicerparent.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GoToMarketLeftoverAction: child failed to apply leftover. error="<<TTSDK_ORDER_ERR_STR[error]<<endl;
slicerparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] LeaveLeftoverAction: called for child orders size="<<m_childOrders.size()<<"u"<<endl;
slicerparent.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] LeaveLeftoverAction: child failed to apply leftover. error="<<TTSDK_ORDER_ERR_STR[error]<<endl;
slicerparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ApplyLeftoverAction: UserAction::Change in progress, skip adding slice"<<endl;
slicerparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ApplyLeftoverAction: UserAction::Delete in progress, skip adding slice"<<endl;
slicerparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ApplyLeftoverAction: UserAction::Pause in progress, skip adding slice"<<endl;
slicerparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ApplyLeftoverAction. action="<<LEFT_OVER_ACTION_STR[to_underlying(action)]<<" child_order_count="<<m_childOrders.size()<<"u"<<endl;
slicerparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ScheduleCompleteActionAsDelete"<<endl;
slicerparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Child Info: order_ptr="<<static_cast<void*>(childOrder.get())<<" order_id="<<childOrder->GetOrderIDString()<<" order_type="<<TTSDK_OrderTypeToString(childOrder->GetType())<<" order_side="<<childOrder->GetSide()<<" order_qty="<<childOrder->GetOrderQty()<<".8f filled_qty="<<childOrder->GetFilledQty()<<".8f order_working_qty="<<childOrder->GetWorkingQty()<<".8f order_prc="<<childOrder->GetLimitPrice()<<".8f order_trg_prc="<<childOrder->GetTriggerPrice()<<".8f time_sent="<<childOrder->GetTimeSent()<<"lu curr_childOrders_size="<<m_childOrders.size()<<"u "<<endl;
slicerparent.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking Completed. order_qty="<<GetOrderQuantity()<<".8f orig_order_qty="<<orig_order_qty<<".8f limit_prc="<<GetLimitPrice()<<".8f trg_prc="<<GetTriggerPrice()<<".8f synth_status="<<GetSynthStatus()<<" cum_filled_qty="<<GetCumFillQuantity()<<".8f orig_cum_filled_qty="<<orig_cum_fill_qty<<".8f ladder_display="<<GetLadderDisplay()<<" order_type="<<TTSDK_OrderTypeToString(GetType())<<" total_order_qty="<<totalOrderQty<<".8f total_cum_fill_qty="<<totalCumFillQty<<".8f total_placed_qty="<<GetPlacedQuantity()<<".8f childOrders_size="<<m_childOrders.size()<<"u"<<endl;
slicerparent.cpp                        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ReduceQuantity: DeleteOrder failed. error="<<TTSDK_ORDER_ERR_STR[delete_error]<<endl;
slicerparent.cpp                        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ReduceQuantity: Failed to Change/Delete child order. error="<<TTSDK_ORDER_ERR_STR[error]<<endl;
slicerparent.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] PlaceSliceOrder: encountered a zero slice. Skipping."<<endl;
slicerparent.cpp                TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] PlaceSliceOrder: Failed to place slice order! error=\"<<error_str<<"\ reason=\"<<failure_reason<<"\ order_type="<<TTSDK_OrderTypeToString(order_type)<<endl;
slicerparent.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] PlaceSliceOrder. order_type="<<TTSDK_OrderTypeToString(order_type)<<" limitPrc="<<price<<".8f child_OQ="<<new_qty<<".8f"<<endl;
slicerparent.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] PlaceSliceOrder: Failed to add order order_type="<<TTSDK_OrderTypeToString(order_type)<<" limitPrc="<<price<<".8f child_OQ="<<new_qty<<".8f error="<<error_str<<endl;
options_delta_service.cpp        TTLOG(ERROR,13)<<"OptionsDeltaService: not able to start without greeks_obv_url, options_delta_polling_miliseconds and chef_environment"<<endl;
options_delta_service.cpp        TTLOG(ERROR,13)<<" OptionsDeltaService: Subscription not allowed in current state for "<<subscriberID<<" for options_instrument_id="<<std::get<0>(subscriptionID)<<"lu use_id="<<std::get<1>(subscriptionID)<<"lu"<<endl;
options_delta_service.cpp    TTLOG(INFO,13)<<"OptionsDeltaService: Received subscription for client_id="<<subscriberID<<", options_instrument_id="<<std::get<0>(subscriptionID)<<"lu user_id="<<std::get<1>(subscriptionID)<<"lu"<<endl;
options_delta_service.cpp    TTLOG(INFO,13)<<"OptionsDeltaService: Starting"<<endl;
options_delta_service.cpp    TTLOG(INFO,13)<<"OptionsDeltaService: Stopped"<<endl;
options_delta_service.cpp            TTLOG(INFO,13)<<"OptionsDeltaService: Ending subscription for client_id="<<subscriberID<<", options_instrument_id="<<std::get<0>(subscriptionID)<<"lu use_id="<<std::get<1>(subscriptionID)<<"lu"<<endl;
options_delta_service.cpp    TTLOG(ERROR,13)<<"OptionsDeltaService: Could not find subscription for client_id="<<subscriberID<<", options_instrument_id="<<std::get<0>(subscriptionID)<<"lu use_id="<<std::get<1>(subscriptionID)<<"lu"<<endl;
options_delta_service.cpp    TTLOG(INFO,13)<<"OptionsDeltaService: Stoping with "<<m_taskQueue->size()<<"lu items in queue."<<endl;
options_delta_service.cpp        TTLOG(WARNING,13)<<"OptionsDeltaService: count="<<m_optionsDeltaSubscriptions.size()<<"u delta-webrequests and fanout total_duration="<<(end_time-start_time)<<"u"<<endl;
options_delta_service.cpp            TTLOG(WARNING,13)<<"OptionsDeltaService: zero delta for: url='"<<url.to_std()<<"' response="<<response<<endl;
options_delta_service.cpp            TTLOG(WARNING,13)<<"OptionsDeltaService: failed to get data for url='"<<url<<"' http_code="<<deltaObserver.http_code<<"d response='"<<deltaObserver.response<<"' failure_reason='"<<deltaObserver.failure_reason<<"'"<<endl;
options_delta_service.cpp        TTLOG(ERROR,13)<<"OptionsDeltaService: request failed: Exception caught. url="<<url<<" error="<<errorMsg<<endl;
options_delta_service.cpp        TTLOG(ERROR,13)<<"OptionsDeltaService: request failed: Unknown exception caught. url="<<url<<endl;
obvparent.cpp        TTLOG(ERROR,13)<<"[OBV:"<<GetOrderIDString()<<"]:ValidateStart: invalid Vol="<<volatility<<endl;
obvparent.cpp        TTLOG(ERROR,13)<<"[OBV:"<<GetOrderIDString()<<"]:ValidateStart: Market type="<<TTSDK_OrderTypeToString(GetType())<<" not supported by OBV"<<endl;
obvparent.cpp        TTLOG(ERROR,13)<<"[OBV:"<<GetOrderIDString()<<"]:ValidateStart: No underlying instrument instr="<<instr_data->name<<"["<<instr_data->alias<<"]"<<endl;
obvparent.cpp        TTLOG(ERROR,13)<<"[OBV:"<<GetOrderIDString()<<"]:ValidateStart: Failed to download underlying instrument underlying_instr_id="<<instr_data->instr_snap.underlying_instr_id<<"lu error="<<TTSDK_ERROR_STR[download_error]<<endl;
obvparent.cpp    TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"]:ValidateStart: volatility="<<m_volatility<<", underlying_instr_id="<<instr_data->instr_snap.underlying_instr_id<<"lu underlying_tick="<<m_underlying_tick<<".8f "<<endl;
obvparent.cpp    TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"] OnChildAdd: order_id="<<childOrder->GetOrderIDString()<<" limitPrc="<<limitPrice<<".8f OQ="<<orderQuantity<<".8f WQ="<<workingQuantity<<".8f"<<endl;
obvparent.cpp    TTLOG(DEBUG,13)<<"[OBV:"<<GetOrderIDString()<<"] OnChildReplace: child: order_id="<<childOrder->GetOrderIDString()<<" LimitPrc="<<limitPrice<<".8f OQ="<<orderQuantity<<".8f WQ="<<workingQuantity<<".8f external="<<external<<" requestsPending="<<requestsPending<<" Parent: CumQty="<<parentCumQty<<".8f OQ="<<parentOrdQty<<".8f"<<endl;
obvparent.cpp            TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"] OnChildReplace: Increased parent qty from "<<parentOrdQty<<".8f to "<<newQuantity<<".8f"<<endl;
obvparent.cpp            TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"] OnChildReplace: Unexpected: external="<<external<<", requestsPending="<<requestsPending<<", parentOrdQty="<<parentOrdQty<<".8f, workingQuantity="<<workingQuantity<<".8f"<<endl;
obvparent.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] OnChildCancel: order_id="<<childOrder->GetOrderIDString()<<" external="<<external<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
obvparent.cpp    TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"] OnChildFill: order_id="<<child_order->GetOrderIDString()<<" limitPrc="<<limit_price<<".8f OQ="<<order_quantity<<".8f WQ="<<working_quantity<<".8f FQ="<<fill_quantity<<".8f FlPrc="<<fill_price<<".8f fill_type="<<FILL_TYPE_STR[to_underlying(fill_type)]<<endl;
obvparent.cpp    TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"] OnChildRequestFailure: order_id="<<childOrder->GetOrderIDString()<<", timeout="<<timeout<<endl;
obvparent.cpp    TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"] OnChildReject: order_id="<<childOrder->GetOrderIDString()<<", external="<<external<<" requestsPending="<<requestsPending<<" message="<<message<<" "<<endl;
obvparent.cpp        TTLOG(ERROR,13)<<"[OBV:"<<GetOrderIDString()<<"] OnPriceUpdate: price_snap=nullptr, price_sub="<<price_sub<<"lu, underlying="<<underlying_instr->instr_snap.alias<<", underlying_id="<<underlying_instr->instr_snap.instr_id<<"lu"<<endl;
obvparent.cpp            TTLOG(ERROR,13)<<"[OBV:"<<GetOrderIDString()<<"]OnPriceUpdate: FuturePx=NaN"<<endl;
obvparent.cpp        TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"]OnPriceUpdate: Scheduled first Greek request. lo="<<lo<<".8f hi="<<hi<<".8f"<<endl;
obvparent.cpp            TTLOG(DEBUG,13)<<" [OBV:"<<GetOrderIDString()<<"] Buy/Call bid="<<reference<<".3f"<<endl;
obvparent.cpp            TTLOG(DEBUG,13)<<" [OBV:"<<GetOrderIDString()<<"] Sell/Call ask="<<reference<<".3f"<<endl;
obvparent.cpp            TTLOG(DEBUG,13)<<" [OBV:"<<GetOrderIDString()<<"] Buy/Put ask="<<reference<<".3f"<<endl;
obvparent.cpp            TTLOG(DEBUG,13)<<" [OBV:"<<GetOrderIDString()<<"] Sell/Put bid="<<reference<<".3f"<<endl;
obvparent.cpp        TTLOG(DEBUG,13)<<"[OBV:"<<GetOrderIDString()<<"] no Theo map yet"<<endl;
obvparent.cpp        TTLOG(ERROR,13)<<"[OBV:"<<GetOrderIDString()<<"]EvaluateChildOrder: FuturePx=NaN"<<endl;
obvparent.cpp    TTLOG(DEBUG,13)<<"[OBV:"<<GetOrderIDString()<<"]EvaluateChildOrder: futurePx="<<futurePx);ttsdk_instr_data*option_instr=reinterpret_cast<ttsdk_instr_data*>(GetInstr()<<endl;
obvparent.cpp            TTLOG(ERROR,13)<<"[OBV:"<<GetOrderIDString()<<"]EvaluateChildOrder: Failed to get Theo with futurePx="<<futurePx<<".3f"<<endl;
obvparent.cpp        TTLOG(DEBUG,13)<<"[OBV:"<<GetOrderIDString()<<"]futurePx="<<futurePx<<".3f, theo="<<theoIter->second<<".3f, vol="<<m_volatility<<".3f"<<endl;
obvparent.cpp            TTLOG(ERROR,13)<<"[OBV:"<<GetOrderIDString()<<"]EvaluateChildOrder: m_currTheo=NaN"<<endl;
obvparent.cpp                    TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"]Add Order option="<<option_instr->alias<<" option_id="<<option_instr->instr_snap.instr_id<<"lu future="<<future_instr->alias<<" future_id="<<future_instr->instr_snap.instr_id<<"lu futurePx="<<futurePx<<".3f volatility="<<m_volatility<<".3f Add [qty="<<GetOrderQuantity()<<".3f @ theo="<<m_currTheo<<".3f]"<<endl;
obvparent.cpp                    TTLOG(ERROR,13)<<"[OBV:"<<GetOrderIDString()<<"] Failed to add order, error="<<TTSDK_ORDER_ERR_STR[add_error]<<endl;
obvparent.cpp                        TTLOG(ERROR,13)<<"[OBV:"<<GetOrderIDString()<<"] Failed to change child, error="<<TTSDK_ORDER_ERR_STR[change_error]<<endl;
obvparent.cpp                        TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"]ChangeOrder option="<<option_instr->alias<<" option_id="<<option_instr->instr_snap.instr_id<<"lu future="<<future_instr->alias<<" future_id="<<future_instr->instr_snap.instr_id<<"lu futurePx="<<futurePx<<".3f volatility="<<m_volatility<<".3f Chg [qty="<<GetOrderQuantity()<<".3f @ current_theo="<<m_currTheo<<".3f prev_theo="<<m_prevTheo<<".3f]"<<endl;
obvparent.cpp                    TTLOG(DEBUG,13)<<"[OBV:"<<GetOrderIDString()<<"]NOOP. Theo did not change. m_currTheo="<<m_currTheo<<".3f"<<endl;
obvparent.cpp        TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"] ["<<iter.first<<".3f] = "<<iter.second<<".3f"<<endl;
obvparent.cpp    TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"] Theo Map updated: size="<<m_mapTheos.size()<<", Lo="<<m_mapPriceLo<<".3f, hi="<<m_mapPriceHi<<".3f"<<endl;
obvparent.cpp    TTLOG(ERROR,13)<<"[OBV:"<<GetOrderIDString()<<"] OnGreekErrorCB: error="<<error<<endl;
obvparent.cpp        TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"]: StartWorking about to subscribe Future: instr_id="<<underlying_instr->instr_snap.instr_id<<"lu"<<endl;
obvparent.cpp        TTLOG(ERROR,13)<<"[OBV:"<<GetOrderIDString()<<"]: StartWorking Failed to open price subscription instr="<<underlying_instr->instr_snap.instr_id<<"lu error="<<TTSDK_ERROR_STR[error_code]<<" "<<endl;
obvparent.cpp        TTLOG(WARNING,13)<<"[OBV:"<<GetOrderIDString()<<"] HandleUpdate: Ignore price change"<<endl;
obvparent.cpp        TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"] HandleUpdate: No qty change"<<endl;
obvparent.cpp        TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"] HandleUpdate: requstQty="<<requestQty<<".8f Qty="<<GetOrderQuantity()<<".8f, but no child order yet"<<endl;
obvparent.cpp    TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"] HandleUpdate: requstQty="<<requestQty<<".8f Qty="<<GetOrderQuantity()<<".8f"<<endl;
obvparent.cpp        TTLOG(ERROR,13)<<"[OBV:"<<GetOrderIDString()<<"] HandleUpdate failed to change order. error="<<TTSDK_ORDER_ERR_STR[order_error]<<endl;
obvparent.cpp            TTLOG(DEBUG,13)<<"[OBV:"<<GetOrderIDString()<<"] Current bounds ["<<m_mapPriceLo<<".3f, "<<reference<<".3f, "<<m_mapPriceHi<<".3f], NOT Fetching. lo_bound="<<lo_bound<<".3f, hi_bound="<<hi_bound<<".3f"<<endl;
obvparent.cpp        TTLOG(WARNING,13)<<"[OBV:"<<GetOrderIDString()<<"] Current bounds ["<<m_mapPriceLo<<".3f, "<<reference<<".3f, "<<m_mapPriceHi<<".3f], Can not Fetch ["<<futLo<<".3f, "<<futHi<<".3f]"<<endl;
obvparent.cpp    TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"] Current bounds ["<<m_mapPriceLo<<".3f, "<<reference<<".3f, "<<m_mapPriceHi<<".3f], Now schedule Greek request ["<<futLo<<".3f, "<<futHi<<".3f]"<<endl;
obvparent.cpp    TTLOG(INFO,13)<<"[OBV:"<<GetOrderIDString()<<"] does not care about option price error="<<error<<endl;
average_trade_size_checker.cpp    TTLOG(INFO,13)<<"AverageTradeSizeChecker: ComputeMaxParticipationRate: inst_id="<<m_algo_inst_id<<": average_trade_size="<<average_trade_size<<" m_max_child_slice_size="<<m_max_child_slice_size<<" m_max_participation_rate="<<m_max_participation_rate<<endl;
average_trade_size_checker.cpp        TTLOG(DEBUG,13)<<"AverageTradeSizeChecker: Check: inst_id="<<m_algo_inst_id<<": Skipping since m_max_participation_rate is zero"<<endl;
average_trade_size_checker.cpp    TTLOG(INFO,13)<<"AverageTradeSizeChecker: Check: inst_id="<<m_algo_inst_id<<": order_qty="<<order_qty<<" m_max_participation_rate="<<m_max_participation_rate<<" qty_acceptable="<<qty_acceptable?"true":"false"<<endl;
average_trade_size_checker.cpp    TTLOG(INFO,13)<<"DownloadAverageTradeSize: inst_id="<<algo_instance_id<<": Starting average trade size download: uri="<<uri.str()<<endl;
average_trade_size_checker.cpp        TTLOG(ERROR,13)<<"DownloadAverageTradeSize: inst_id="<<algo_instance_id<<": Average trade size download failed: exception="<<e.what()<<endl;
average_trade_size_checker.cpp    TTLOG(INFO,13)<<"DownloadAverageTradeSize: inst_id="<<algo_instance_id<<": Average trade size download succeeded: response="<<response<<endl;
average_trade_size_checker.cpp            TTLOG(ERROR,13)<<"ParseAverageTradeSize: inst_id="<<algo_instance_id<<": [result][status] missing!"<<endl;
average_trade_size_checker.cpp            TTLOG(ERROR,13)<<"ParseAverageTradeSize: inst_id="<<algo_instance_id<<": [result][status][stat] missing!"<<endl;
average_trade_size_checker.cpp            TTLOG(ERROR,13)<<"ParseAverageTradeSize: inst_id="<<algo_instance_id<<": [result][status][stat]="<<stat<<"!"<<endl;
average_trade_size_checker.cpp            TTLOG(ERROR,13)<<"ParseAverageTradeSize: inst_id="<<algo_instance_id<<": [result][pd] missing!"<<endl;
average_trade_size_checker.cpp            TTLOG(ERROR,13)<<"ParseAverageTradeSize: inst_id="<<algo_instance_id<<": [result][pd][pi] missing!"<<endl;
average_trade_size_checker.cpp            TTLOG(ERROR,13)<<"ParseAverageTradeSize: inst_id="<<algo_instance_id<<": [result][pd][pi] was empty!"<<endl;
average_trade_size_checker.cpp                TTLOG(INFO,13)<<"ParseAverageTradeSize: inst_id="<<algo_instance_id<<": No trades during the lookback period, disabling check: average_trade_size_string="<<average_trade_size_string<<" average_trade_size="<<average_trade_size<<endl;
average_trade_size_checker.cpp            TTLOG(INFO,13)<<"ParseAverageTradeSize: inst_id="<<algo_instance_id<<": Setting average trade size: average_trade_size_string="<<average_trade_size_string<<" average_trade_size="<<average_trade_size<<endl;
average_trade_size_checker.cpp        TTLOG(ERROR,13)<<"ParseAverageTradeSize: inst_id="<<algo_instance_id<<": Exception=["<<e.what()<<"] thrown during parse!"<<endl;
average_trade_size_checker.cpp    TTLOG(INFO,13)<<"ParseAverageTradeSize: inst_id="<<algo_instance_id<<": Average trade size parse succeeded: average_trade_size="<<average_trade_size<<endl;
timeslicer.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Invalid Child TIF child_tif="<<child_tif<<endl;
timeslicer.cpp            TTLOG(INFO,13)<<"[TimeSlicer]OnScheduleEvent - ScheduleSliceTimer"<<endl;
timeslicer.cpp    TTLOG(INFO,13)<<"[TimerSlicer]OnScheduledEvent "<<id<<endl;
timeslicer.cpp            TTLOG(INFO,13)<<"[TimeSlicer]OnChildCancel ScheduleTimer"<<endl;
timeslicer.cpp        TTLOG(DEBUG,13)<<" [TimeSlicer:"<<GetOrderIDString()<<"] StartWorking failed to create timer error="<<e.what()<<endl;
timeslicer.cpp        TTLOG(INFO,13)<<"[TimeSlicer:"<<GetOrderIDString()<<"] HandleUpdate: Qty increased and no timer armed, adding slice child_OQ="<<new_qty<<" "<<endl;
timeslicer.cpp            TTLOG(WARNING,13)<<" [TimeSlicer:"<<GetOrderIDString()<<"] ScheduleSliceTimer: Failed to arm timer interval="<<interval_ms<<endl;
timeslicer.cpp            TTLOG(DEBUG,13)<<" [TimeSlicer:"<<GetOrderIDString()<<"] ScheduleSliceTimer: Timer armed interval_ms="<<interval_ms<<" "<<endl;
timeslicer.cpp            TTLOG(WARNING,13)<<" [HalfLifeTimer:"<<GetOrderIDString()<<"] ScheduleHalfLifeTimer: Failed to arm half life timer interval="<<interval_ms<<endl;
timeslicer.cpp            TTLOG(DEBUG,13)<<" [HalfLifeTimer:"<<GetOrderIDString()<<"] ScheduleHalfLifeTimer: Half life timer armed interval_ms="<<interval_ms<<" "<<endl;
timeslicer.cpp    TTLOG(DEBUG,13)<<" [TimeSlicer:"<<GetOrderIDString()<<"] OnStopAlgo: Stop SliceTimer"<<endl;
timeslicer.cpp            TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] SendSuspendStatus on disconnect syn_status="<<TTSDK_SYNTH_STATUS_STR[status]<<endl;
timeslicer.cpp                        TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] SendSuspendStatus on disconnect WAT=true and WAT trigger=false"<<endl;
timeslicer.cpp                TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandlePriceError: Disconnect Ignored All children WAT applied"<<endl;
timeslicer.cpp                TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandlePriceError: Disconnect Ignored HasWAT="<<hasWat<<"; hasChild="<<hasChild<<endl;
timeslicer.cpp            TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandlePriceError: Disconnect Ignored syn_status="<<TTSDK_SYNTH_STATUS_STR[status]<<endl;
timeslicer.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] No remaining qty to generate slice schedule"<<endl;
timeslicer.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Unable to generate slice schedule. remaining_qty="<<remaining_qty<<".0f disc_qty="<<disc_qty<<".0f"<<endl;
timeslicer.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Generated new slice schedule. "<<GetSliceSummary()<<endl;
timeslicer.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ShouldContinueSlicing: Suppressing the sending of next slice and rearming slice timer because: synth_status="<<TTSDK_SYNTH_STATUS_STR[synth_status]<<" activity_blocked_reason="<<ACTIVITY_BLOCK_STR[to_underlying(activity_blocked_reason)]<<endl;
timeslicer.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ShouldContinueSlicing: Suppressing the sending of next slice and rearming slice timer because: action_in_progress="<<USER_ACTION_STR[to_underlying(action_in_progress)]<<endl;
tlparent.cpp        TTLOG(INFO,13)<<"[TLParent:"<<GetOrderIDString()<<"]: OnWorkingPriceUpdate: New lastTrailBasePrice price limit_price="<<limitPrice<<".8f m_trailingTriggerBase="<<m_trailingTriggerBase<<".8f pre_trail_base_price="<<prevTrailBase<<".8f trailsUp="<<trailsUp<<" error="<<TTSDK_ORDER_ERR_STR[order_error]<<endl;
tlparent.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: StartWorking: m_trailingTriggerBase="<<m_trailingTriggerBase<<".8f trailsUp="<<trailsUp<<" "<<endl;
tlparent.cpp        TTLOG(ERROR,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] SetChangeSubTasks: Failed to update Base Trailing Price! Target Price will not be updated: error="<<error<<" m_targetNewPrice="<<m_targetNewPrice<<" (unchanged)"<<endl;
tlparent.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandleUpdate: synth_status="<<TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]<<" childOrdersSize="<<m_childOrders.size()<<"d childPRExists="<<m_childPR?std::string("true"):std::string("false")<<endl;
tlparent.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandleUpdate: Sending requests with the following (note: some fields may be invalid depending on the sequence): pending_change_subtasks=["<<std::to_string(m_pending_change_subtasks)<<"] target_price="<<m_targetNewPrice<<".8f target_qty="<<m_targetNewQty<<".8f target_pr_qty="<<m_targetPRQty<<".8f"<<endl;
tlparent.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandleUpdate: ProcessPendingChangeTasks returned error="<<TTSDK_ERROR_STR[error]<<endl;
tlparent.cpp            TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandleUpdate: Updating LimitTicksAway currentLimitTicksAway="<<GetLimitTicksAway()<<" requestLimitTicksAway="<<GetLimitTicksAway(request_params)<<" "<<endl;
tlparent.cpp        TTLOG(INFO,13)<<"[TLParent:"<<GetOrderIDString()<<"] HandleActionFinished: Simulating price update for missed price"<<endl;
tlparent.cpp            TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] SendSuspendStatus on disconnect syn_status="<<TTSDK_SYNTH_STATUS_STR[status]<<endl;
tlparent.cpp            TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandlePriceError: Disconnect Ignored syn_status="<<TTSDK_SYNTH_STATUS_STR[status]<<endl;
price_drift_checker.cpp                 TTLOG(WARNING,13)<<"[parent:"<<existing_child->GetParentOrderIDString()<<"] order_id="<<existing_child->GetOrderIDString()<<" has no original time sent!"<<endl;
price_drift_checker.cpp                         TTLOG(WARNING,13)<<"[parent:"<<existing_child->GetParentOrderIDString()<<"] order_id="<<existing_child->GetOrderIDString()<<" has no limit price and can not be used for price drift check"<<endl;
price_drift_checker.cpp         TTLOG(INFO,13)<<"[parent:"<<existing_children.front()->GetParentOrderIDString()<<"] No referencable order rule="<<m_name<<" "<<endl;
price_drift_checker.cpp         TTLOG(ERROR,13)<<"[parent:"<<reference_order->GetParentOrderIDString()<<"] Failed Price Drift check rule="<<m_name<<" reference_order="<<reference_order->GetOrderIDString()<<" reference_price="<<reference_order->GetLimitPrice()<<".8f new_price="<<new_price<<".8f compare_details=["<<details.str()<<"]"<<endl;
price_drift_checker.cpp         TTLOG(INFO,13)<<"[parent:"<<reference_order->GetParentOrderIDString()<<"] Pass Price Drift check rule="<<m_name<<" reference_order="<<reference_order->GetOrderIDString()<<" reference_price="<<reference_order->GetLimitPrice()<<".8f new_price="<<new_price<<".8f compare_details=["<<details.str()<<"]"<<endl;
max_order_rate_checker.cpp        TTLOG(ERROR,13)<<"[parent:"<<m_algo_inst_id<<"] UpdateCheckDetails: check pointer was unexpectedly a nullptr, skipping!"<<endl;
max_order_rate_checker.cpp        TTLOG(DEBUG,13)<<"[parent:"<<m_algo_inst_id<<"] UpdateCheckDetails: "<<CheckTypeToString(check->m_check_type)<<" is not enabled, skipping!"<<endl;
max_order_rate_checker.cpp    TTLOG(DEBUG,13)<<"[parent:"<<m_algo_inst_id<<"] UpdateCheckDetails: Start - dump check details: "<<DebugDumpCheckDetails(*check)<<endl;
max_order_rate_checker.cpp    TTLOG(DEBUG,13)<<"[parent:"<<m_algo_inst_id<<"] UpdateCheckDetails: Diff between [current] - [oldest]: current_time_ns="<<current_time_ns<<"lu oldest_time_ns="<<oldest_time_ns<<"lu diff="<<current_time_ns-oldest_time_ns<<"lu"<<endl;
max_order_rate_checker.cpp        TTLOG(DEBUG,13)<<"[parent:"<<m_algo_inst_id<<"] UpdateCheckDetails: Passed check! Diff is greater than 1ms!"<<endl;
max_order_rate_checker.cpp        TTLOG(DEBUG,13)<<"[parent:"<<m_algo_inst_id<<"] UpdateCheckDetails: End - dump check details: "<<DebugDumpCheckDetails(*check)<<endl;
max_order_rate_checker.cpp    TTLOG(DEBUG,13)<<"[parent:"<<m_algo_inst_id<<"] UpdateCheckDetails: Failed check! Diff is less than 1ms!"<<endl;
max_order_rate_checker.cpp    TTLOG(DEBUG,13)<<"[parent:"<<m_algo_inst_id<<"] UpdateCheckDetails: End - dump check details: "<<DebugDumpCheckDetails(*check)<<endl;
max_order_rate_checker.cpp        TTLOG(ERROR,13)<<"[parent:"<<m_algo_inst_id<<"] Failed "<<CheckTypeToString(check_type)<<" because: m_max_request_rate_violated="<<m_max_request_check.m_max_rate_violated?"true":"false"<<" m_max_unsolicited_cancel_rate_violated="<<m_max_unsolicited_cancel_check.m_max_rate_violated?"true":"false"<<endl;
somparentorder.cpp                TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ValidateStart failed to find OTTIF. Assuming that market orders are suppored product_id="<<instr_data->instr_snap.product_id<<"lu"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"EndTimeAction="<<GetEndTimeAction()<<", startTime="<<startTime<<"lu endTime="<<endTime<<"lu"<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] TrailingTrigger is Set"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ValidateStart: currentQty="<<GetOrderQuantity()<<".8f currentPrice="<<GetLimitPrice()<<".8f orderType="<<orderType<<" "<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckForValidConfiguration: Validating requested config. requested_config="<<std::to_string(config)<<" invalid_configs="<<s_invalid_configs<<endl;
somparentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CleanupChildrenAndFail. error_msg="<<error_msg<<". should_cleanup_pr_child="<<should_cleanup_pr_child<<" should_cleanup_normal_children="<<should_cleanup_normal_children<<" send_cleanup_for=\"<<cleanup_pr_only?"PRChildOnly":"AllChildren"<<"\"<<endl;
somparentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CleanupChildrenAndFail Leaving child orders. error_msg="<<error_msg<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] TryResumeWorking: synth_status="<<TTSDK_SYNTH_STATUS_STR[synth_status]<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] TryResumeWorking: Forfeiting recovery and stopping algo because the user requested stop, or there was a price subscription error. should_forfeit_recovery="<<GetForfeitRecovery()?std::string("true"):std::string("false")<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] TryResumeWorking: Forfeiting resuming process and stopping algo because the user requested stop, or there was a price subscription error. should_forfeit_resume="<<GetForfeitResume()?std::string("true"):std::string("false")<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] TryResumeWorking: Blocked by activity. reason="<<ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] TryResumeWorking: Market is open, so calling ResumeWorking."<<endl;
somparentorder.cpp                TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] TryResumeWorking: Failed to un-suspend children - failing algo"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] TryResumeWorking: Market is NOT open, so setting flag to retry on next price update."<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] UnSuspendChildren: Skipping PR order: child="<<(void*)childOrder.get()<<" order_id="<<childOrder->GetOrderIDString()<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] UnSuspendChildren: Skipping non-working order: child="<<(void*)childOrder.get()<<" order_id="<<childOrder->GetOrderIDString()<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] UnSuspendChildren: Skipping order being deleted: child="<<(void*)childOrder.get()<<" order_id="<<childOrder->GetOrderIDString()<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] UnSuspendChildren: Failed to un-suspend this order: child="<<(void*)childOrder.get()<<" order_id="<<childOrder->GetOrderIDString()<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] UnSuspendChildren: Un-suspended this order: child="<<(void*)childOrder.get()<<" order_id="<<childOrder->GetOrderIDString()<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] UnSuspendChildren: Iterated through "<<m_childOrders.size()<<"u children"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] RecoverChildren: Downloading children to attempt recovery / resume: synth_status="<<TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] RecoverChildren: will attempt to delete PR child order (if any) because: is_sse_pr_enabled: "<<env::instance().is_sse_pr_enabled()?"true":"false"<<" SupportsPR: "<<SupportsPR()?"true":"false"<<endl;
somparentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnRecoveredChildrenDownloaded: Neither Recovering nor Resuming - unexpected!"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CompleteActionAndStop: Completing a Change as a Stop because there are no more child orders working."<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckEndTimeActionProgress: Inflights still in progress. child="<<(void*)child.get()<<" order_id="<<child->GetOrderIDString()<<" status="<<child->InflightStatus()<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckEndTimeActionProgress: ETAGoToMarketSubTask is NONE, which is unexpected"<<endl;
somparentorder.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ParentOrderTestHarness: OnActionFinished: Sleeping for 15 seconds..."<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnActionFinished. pending_action="<<PendingActionToStr(GetPendingAction())<<" last_action="<<USER_ACTION_STR[to_underlying(lastAction)]<<" was_action_successful="<<wasActionSuccessful?"true":"false"<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandleActionFinished: Conducting latent trigger check (suppressed earlier while action was in progress)."<<endl;
somparentorder.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ParentOrderTestHarness: OnUpdateAlgo: Scheduling custom event: event_type="<<GetTestHarness()->m_eventToScheduleInOnUpdateAlgo<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnUpdateAlgo: Update request received currentQty="<<GetOrderQuantity()<<".8f newQty="<<newQty<<".8f currentPrice="<<GetLimitPrice()<<".8f newPrice="<<newPrice<<".8f requestTriggerTicksAway="<<requestTriggerTicksAway==INVALID_TICKS?"unchanged":std::to_string(requestTriggerTicksAway)<<" requestTriggerPrice="<<std::isnan(requestTriggerPrice)?"unchanged":std::to_string(requestTriggerPrice)<<" requestTriggerQty="<<fp_eq(requestTriggerQty<<" requestPayup="<<ParentOrder::INVALID_QTY)?"unchanged":std::to_string(requestTriggerQty)<<" requestLimitTicksAway="<<requestPayup==INVALID_TICKS?"unchanged":std::to_string(requestPayup)<<" requestWithATick="<<requestLimitTicksAway==INVALID_TICKS?"unchanged":std::to_string(requestLimitTicksAway)<<" orderType="<<fp_eq(requestWithATick<<" originalOrderType="<<ParentOrder::INVALID_QTY)?"unchanged":std::to_string(requestWithATick)<<" requestDisclosedQty="<<(requestOrderType==(ttsdk_order_type)0||requestOrderType==originalOrderType)?"unchanged":std::to_string((int)requestOrderType)<<" originalLeftoverAction="<<originalOrderType<<" requestLeftoverAction="<<fp_eq(requestDisclosedQty<<" originalLeftoverTicks="<<INVALID_QTY)?"unchanged":std::to_string(requestDisclosedQty)<<" requestLeftoverTicks="<<originalLeftoverAction<<" originalLimitPriceType="<<requestLeftoverAction<<" requestLimitPriceType="<<originalLeftoverTicks<<" status="<<requestLeftoverTicks<<" child_pr="<<originalLimitPriceType<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnUpdateAlgo: Activity blocked. activity_blocked="<<ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]<<" "<<endl;
somparentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnUpdateAlgo: Validation failed. error="<<error<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnUpdateAlgo: Scheduling price update because WithATickValue changed"<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnUpdateAlgo: Scheduling price update because some trigger-related param changed"<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnUpdateAlgo: Updating LimitTicksAway originalLimitTicksAway="<<GetLimitTicksAway()<<" requestLimitTicksAway="<<requestLimitTicksAway<<" "<<endl;
somparentorder.cpp            TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnUpdateAlgo: Failed to promote FIX params for accept response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" IGNORE this warning if FIX is not involved!"<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnUpdateAlgo: Promoted FIX params for accept response"<<endl;
somparentorder.cpp            TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnUpdateAlgo: Failed to promote cl_ord_id params for accept response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" "<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnUpdateAlgo: Promoted cl_ord_id params for accept response cl_ord_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] market_state "<<TTSDK_MarketStateSTR[old_market_state]<<"->"<<TTSDK_MarketStateSTR[new_market_state]<<"."<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Checking AutoResubmit logic. synth_status="<<TTSDK_SYNTH_STATUS_STR[synth_status]<<" child_order_count="<<m_childOrders.size()<<"u"<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AutoResubmit skipped due to invalid synthetic state. synth_status="<<TTSDK_SYNTH_STATUS_STR[synth_status]<<" child_order_count="<<m_childOrders.size()<<"u"<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Stopping since parent TIF is DAY."<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ParentOrderTestHarness: OnPriceUpdate: Simulating market state change: "<<TTSDK_MarketStateSTR[m_currentMarketState]<<"->"<<TTSDK_MarketStateSTR[GetTestHarness()->m_marketStateToSimulate]<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnScheduledEvent: StartTime fired "<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnScheduledEvent: EndTime fired ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<" ActivityBlockedReason="<<ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]<<" end_action="<<END_ACTION_STR[to_underlying(GetEndTimeAction())]<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnScheduledEvent: SimulatedPriceUpdate ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<" ActivityBlockedReason="<<ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]<<" "<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnStopAlgo: ActivityBlockedReason="<<ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]<<" "<<endl;
somparentorder.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ParentOrderTestHarness: OnStopAlgo: Scheduling custom event: event_type="<<GetTestHarness()->m_eventToScheduleInOnStopAlgo<<endl;
somparentorder.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ParentOrderTestHarness: OnStopAlgo: Sleeping for 15 seconds..."<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnStopAlgo: stops m_startTimer"<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnStopAlgo: stops endTimer"<<endl;
somparentorder.cpp            TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnStopAlgo: Skipping PR deletion due to zero qty. The PR order must have been rejected. pr_inflight_pending="<<m_childPR->GetInflightPending()<<" pr_working_qty="<<m_childPR->GetWorkingQty()<<".8f"<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnStopAlgo: Deleting Position Reserve Order. pr_inflight_pending="<<m_childPR->GetInflightPending()<<" pr_working_qty="<<m_childPR->GetWorkingQty()<<".8f"<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnStopAlgo: No working/inflight, but childOrders not empty. DetachChildren directly! child_count="<<szChildren<<"u detach_result="<<TTSDK_ERROR_STR[result]<<endl;
somparentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnStopAlgo: Failed to promote FIX params for accept response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" IGNORE this warning if FIX is not involved!"<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnStopAlgo: Promoted FIX params for accept response"<<endl;
somparentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnStopAlgo: Failed to promote cl_ord_id params for accept response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" "<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnStopAlgo: Promoted cl_ord_id params for accept response cl_ord_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnPauseAlgo: ActivityBlockedReason="<<ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]<<" "<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnPauseAlgo: Activity blocked. activity_blocked="<<ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]<<" "<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnPauseAlgo: Setting pre-pause synthetic status to: "<<TTSDK_SYNTH_STATUS_STR[status]<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnPauseAlgo: stops m_startTimer"<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnPauseAlgo: stops endTimer"<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnPauseAlgo: Skipping suspension of this order because it's a PR order: child="<<(void*)child.get()<<" order_id="<<child->GetOrderIDString()<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnPauseAlgo: Skipping suspension of this order because it's no longer working: child="<<(void*)child.get()<<" order_id="<<child->GetOrderIDString()<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnPauseAlgo: No working/inflight, but childOrders not empty. DetachChildren directly! child_count="<<szChildren<<"u detach_result="<<TTSDK_ERROR_STR[result]<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnStopStagedAlgo. activity_blocked="<<ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]<<" message="<<message<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CalcStartingPrice: base_price="<<base_price<<".8f offset_price="<<limit_price<<".8f offset_ticks="<<offset_ticks<<" offset_ticks_with_direction="<<offset_ticks_with_direction<<" is_payup="<<is_payup?std::string("true"):std::string("false")<<" GetLimitPriceType="<<PRICE_TYPE_STR[static_cast<int>(GetLimitPriceType())]<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ProcessWaitingOption: will wait for market_state="<<WAITING_OPTION_STR[to_underlying(GetWaitingOption())]<<endl;
somparentorder.cpp                TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnStartTimeTimer."<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ScheduleStartTime: failed to arm timer. scheduled_time="<<start_time_ms<<"lu ["<<MiliSecondsToDateString(start_time_ms)<<"]"<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ScheduleStartTime: scheduled_time="<<start_time_ms<<"lu ["<<MiliSecondsToDateString(start_time_ms)<<"] (send_ahead_interval_ms="<<send_ahead_interval_ms<<"u)"<<endl;
somparentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ScheduleStartTime: failed to create timer. scheduled_time="<<start_time_ms<<"lu ["<<MiliSecondsToDateString(start_time_ms)<<"] error="<<e.what()<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<" ["<<m_name<<":"<<GetOrderIDString()<<"] PerformEndTimeAction. action="<<END_ACTION_STR[(int)GetEndTimeAction()]<<endl;
somparentorder.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ParentOrderTestHarness: PerformETAGoToMarket: Scheduling custom event: event_type="<<GetTestHarness()->m_eventToScheduleInPerformETAGoToMarket<<endl;
somparentorder.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ParentOrderTestHarness: PerformETAGoToMarket: Sleeping for 15 seconds..."<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] PerformETAGoToMarket: Starting. childOrders_size="<<m_childOrders.size()<<"u deleted_children="<<std::to_string(deleted_children)<<" skipped_children="<<std::to_string(skipped_children)<<endl;
somparentorder.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ParentOrderTestHarness: GoToMarket: Sleeping for 15 seconds..."<<endl;
somparentorder.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ParentOrderTestHarness: GoToMarket: Scheduling custom event: event_type="<<GetTestHarness()->m_eventToScheduleInGoToMarket<<endl;
somparentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GoToMarket called while not in that blocked state. cum_fill_qty="<<cumFillQty<<".8f order_qty="<<orderQty<<".8f non_deletable_child_working_qty="<<childWorkingQty<<".8f market_order_qty="<<marketOrderQty<<".8f ActivityBlockedReason="<<blockedReasonStr<<" "<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GoToMarket: Executing. cum_fill_qty="<<cumFillQty<<".8f order_qty="<<orderQty<<".8f non_deletable_child_working_qty="<<childWorkingQty<<".8f market_order_qty="<<marketOrderQty<<".8f "<<endl;
somparentorder.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ParentOrderTestHarness: GoToMarket: Overriding GoToMarket base price: override_base_price="<<GetTestHarness()->m_overrideEndTimeActionGoToMarketBasePriceValue<<endl;
somparentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GoToMarket: Failed to determine best price for gtm limit order. error="<<error_str<<endl;
somparentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GoToMarket: Failed to add child gtm limit order for remaining qty. child_OQ="<<marketOrderQty<<".8f error="<<error_str<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GoToMarket: Adding child gtm limit order for remaining qty. child_OQ="<<marketOrderQty<<".8f market_prc="<<current_price<<".8f market_prc_ticks="<<offset<<" result_prc="<<adjusted_price<<".8f eta_gtm_ticks="<<eta_gtm_ticks<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] StartPendingTrigger called. synth_status="<<TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]<<" trigger_price="<<GetOrCalcTriggerPrice(m_first_trigger)<<"f"<<endl;
somparentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ScheduleEndTime failed. endTime="<<endTime<<"lu ["<<MiliSecondsToDateString(endTime)<<"] now="<<now_in_mili<<"lu ["<<MiliSecondsToDateString(now_in_mili)<<"]"<<endl;
somparentorder.cpp                TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnEndTimeTimer."<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ScheduleEndTime: failed to arm timer. endTime="<<endTime<<"lu ["<<MiliSecondsToDateString(endTime)<<"]"<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ScheduleEndTime: scheduled_time="<<endTime<<"lu ["<<MiliSecondsToDateString(endTime)<<"]"<<endl;
somparentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ScheduleEndTime: failed to create timer. endTime="<<endTime<<"lu ["<<MiliSecondsToDateString(endTime)<<"] now_in_mili="<<now_in_mili<<"lu ["<<MiliSecondsToDateString(now_in_mili)<<"] error="<<e.what()<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] RecoverEndTime, End time has passed. endTime="<<endTime<<"lu ["<<MiliSecondsToDateString(endTime)<<"] now="<<now_in_mili<<"lu ["<<MiliSecondsToDateString(now_in_mili)<<"] endTimeAction="<<END_ACTION_STR[to_underlying(GetEndTimeAction())]<<" "<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: UpdateTrailingTriggerPrice: New trigger price. trigger_price="<<newTrigger<<".8f base_price="<<m_first_trigger.trailingTriggerBase<<".8f trails_up="<<triggerTrailsUp<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Suppressed trigger check due to an inflight PR order request."<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Triggered upon "<<TriggeringType_ToString(triggering)<<"! No price trigger set. "<<endl;
somparentorder.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] NOT Triggered "<<TriggeringType_ToString(triggering)<<"! T"<<PRICE_TYPE_STR[(int)trigger.price_type]<<" "<<trigger_price<<", T"<<PRICE_TYPE_STR[(int)trigger.price_type]<<" Qty "<<COMPARATOR_TYPE_STR[to_underlying(trigger.qty_compare)]<<", M"<<trigger_qty<<" "<<PRICE_TYPE_STR[(int)trigger.price_type]<<" M"<<current.price<<" Qty "<<PRICE_TYPE_STR[(int)trigger.price_type]<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Price At Trigger hit but market state is unreliable. error="<<error<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Triggered upon "<<TriggeringType_ToString(triggering)<<"! Price worse than TriggerPrice!! Ignore Qty checking! side="<<GetSide()==ttsdk_side_sell?"Sell":"Buy"<<" trigger_type="<<TRIGGER_TYPE_STR[(int)trigger.trigger_type]<<" trigger_price="<<trigger_price<<"f current_price="<<current.price<<"f"<<endl;
somparentorder.cpp            TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] NOT Triggered(QTY) "<<TriggeringType_ToString(triggering)<<"! T"<<PRICE_TYPE_STR[(int)trigger.price_type]<<" "<<trigger_price<<", T"<<PRICE_TYPE_STR[(int)trigger.price_type]<<" Qty "<<COMPARATOR_TYPE_STR[to_underlying(trigger.qty_compare)]<<", M"<<trigger_qty<<" "<<PRICE_TYPE_STR[(int)trigger.price_type]<<" M"<<current.price<<" Qty "<<PRICE_TYPE_STR[(int)trigger.price_type]<<endl;
somparentorder.cpp     TTLOG(INFO,13)<<ss.str()<<endl;
somparentorder.cpp     TTLOG(DEBUG,13)<<audit_ss.str()<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] PrepAndStart: Start Working. setPriceAtStart="<<setPriceAtStart<<" limitPrice="<<limitPrice<<".8f "<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildAdd: limitPrc="<<limitPrice<<".8f OQ="<<orderQuantity<<".8f WQ="<<workingQuantity<<".8f"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: ActionInProgress="<<USER_ACTION_STR[(int)GetActionInProgress()]<<" ActivityBlockedReason="<<ACTIVITY_BLOCK_STR[(int)GetActivityBlockedReason()]<<" external="<<external<<" "<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildFill: ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<" "<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReject: external="<<external<<" requestsPending="<<requestsPending<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<" message="<<message<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildRequestFailure. requests_pending="<<requests_pending<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<" timeout="<<timeout<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildAttachFailure: requests_pending="<<requests_pending<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<" timeout="<<timeout<<" synth_status="<<TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]<<endl;
somparentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildAttachFailure: Neither Recovering nor Resuming - unexpected!"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildDetach. child_id="<<child->GetOrderIDString()<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildAttach. child_id="<<child->GetOrderIDString()<<" synth_status="<<TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]<<endl;
somparentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildAttach: Neither Recovering nor Resuming - unexpected!"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] OnPositionReserveReplace: order_id="<<m_childPR->GetOrderIDString()<<" OQ="<<m_childPR->GetInflightOrderQty()<<".8f ActionInProgress="<<USER_ACTION_STR[to_underlying(m_action_in_progress)]<<" "<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] OnPositionReserveCancel: order_id="<<m_childPR->GetOrderIDString()<<" OQ="<<m_childPR->GetInflightOrderQty()<<".8f ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<" ActivityBlockedReason="<<ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]<<" "<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] OnPositionReserveCancel: Happened unexpectedly during pause process! Calling CheckPauseProgress anyway!"<<endl;
somparentorder.cpp    TTLOG(ERROR,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] OnPositionReserveReject: order_id="<<m_childPR->GetOrderIDString()<<" OQ="<<m_childPR->GetInflightOrderQty()<<".8f reject_details="<<msg<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<" ActivityBlockedReason="<<ACTIVITY_BLOCK_STR[to_underlying(GetActivityBlockedReason())]<<" "<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] OnPositionReserveReject: Happened unexpectedly during pause process! Calling CheckPauseProgress anyway!"<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"[ParentOrder:"<<GetOrderIDString()<<"]: Position reserve rejected during initialization. order_id="<<m_childPR->GetOrderIDString()<<" flags="<<m_initFlags<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckDeleteProgress: Inflights still in progress. Child="<<(void*)child.get()<<" order_id="<<child->GetOrderIDString()<<" status="<<child->InflightStatus()<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckDeleteProgress: Position Reserve inflights still in progress"<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckDeleteProgress: DeletionSubTask is NONE, which is unexpected"<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckPauseProgress: Inflights still in progress. Child="<<(void*)child.get()<<" order_id="<<child->GetOrderIDString()<<" status="<<child->InflightStatus()<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckPauseProgress: PauseSubTask is NONE, which is unexpected"<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] DetachChildren: Detach PR Order synchronously."<<endl;
somparentorder.cpp                TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ParentOrderTestHarness: DetachChildren: Sending a change request behind detach request: order_id="<<(*child)->GetOrderIDString()<<endl;
somparentorder.cpp                    TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ParentOrderTestHarness: DetachChildren: Failed to send change request: order_id="<<(*child)->GetOrderIDString()<<" error="<<TTSDK_ORDER_ERR_STR[harness_error]<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] DetachChildren: order_id="<<(*child)->GetOrderIDString()<<" DetachOrder synchronously."<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AssessETAGoToMarketResult: GoToMarket was successful! last_order="<<std::to_string(last_order)<<endl;
somparentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AssessETAGoToMarketResult: GoToMarket was not successful! last_order="<<std::to_string(last_order)<<" reject_unknown_order="<<last_order?last_order->GetIsRejectUnknownOrder():false<<" working_qty="<<last_order?last_order->GetWorkingQty():0.0f<<".8f leave_on_cancel="<<((last_order?last_order->GetLeaveOn():0)&ttsdk_leave_on_cancel)?std::string("true"):std::string("false")<<endl;
somparentorder.cpp            TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AssessChildrenDeleteResult: Failed to delete child order during algo cancellation childOrders_size="<<m_childOrders.size()<<"u"<<endl;
somparentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AssessChildrenDeleteResult: Failed to delete position reserve order during algo cancellation"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AssessChildrenDeleteResult: All child orders (except leave_on=cancel) were successfully deleted during algo cancellation. expect_pr="<<expectPRDeleted<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AssessChildrenSuspendResult: This order was exempted because it's a PR order: child="<<(void*)child.get()<<" order_id="<<child->GetOrderIDString()<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AssessChildrenSuspendResult: This order was exempted because it's no longer working: child="<<(void*)child.get()<<" order_id="<<child->GetOrderIDString()<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AssessChildrenSuspendResult: This order's suspension attempt was rejected because the order was most likely fully filled in flight - this is not a problem: child="<<(void*)child.get()<<" order_id="<<child->GetOrderIDString()<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AssessChildrenSuspendResult: Failed to suspend child order during algo pausing procedure: problematicChild="<<(void*)(child.get())<<" problematicChildOrderId="<<child->GetOrderIDString()<<" problematicChildLastStatus="<<TTSDK_OrderStatusToString(child->GetOrderStatus())<<" childOrders_size="<<m_childOrders.size()<<"u"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AssessChildrenSuspendResult: All child orders (except PR order) were successfully suspended during algo pausing procedure: childOrders_size="<<m_childOrders.size()<<"u"<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AssessChildrenDetachResult: Failed to detach PR order during algo cancellation/pausing process: pr_order_id="<<m_childPR->GetOrderIDString()<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AssessChildrenDetachResult: Failed to detach this child order during algo cancellation process: order_id="<<child->GetOrderIDString()<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AssessChildrenDetachResult: All child orders were successfully detached during algo cancellation/pausing: m_childOrders.size()="<<m_childOrders.size()<<"u expectPRDetach="<<expectPRDetach<<endl;
somparentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckRecoveryProgress: RecoverySubTask is NONE, which is unexpected"<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckRecoveryProgress: Forfeiting recovery and stopping algo because the user requested stop, or, there was a price subscription error"<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckRecoveryProgress: Forfeiting recovery and stopping algo because children could not be recovered"<<endl;
somparentorder.cpp                TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckRecoveryProgress: No Attaching in flight. error="<<TTSDK_ERROR_STR[error]<<endl;
somparentorder.cpp                TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckRecoveryProgress. attaching_inflight="<<m_attached_children_count<<" error="<<TTSDK_ERROR_STR[error]<<endl;
somparentorder.cpp                TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckRecoveryProgress: Inflight attach requests still in progress for order_id="<<child->GetOrderIDString()<<" status="<<child->InflightStatus()<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckRecoveryProgress: Forfeiting recovery and stopping algo during subtask. subtask_type="<<RECOVERY_SUBTASK_STR[to_underlying(GetRecoverySubTask())]<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckRecoveryProgress: Forfeiting recovery and stopping algo because children could not be attached"<<endl;
somparentorder.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckResumeProgress: ResumeSubTask is NONE, which is unexpected"<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckResumeProgress: Forfeiting resuming and stopping algo because the user requested stop, or, there was a price subscription error"<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckResumeProgress: Forfeiting resume and stopping algo because children could not be recovered"<<endl;
somparentorder.cpp                TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckResumeProgress: Forfeiting resume and stopping algo because there was an error during AttachChildren (no inflight attachments): error="<<TTSDK_ERROR_STR[error]<<endl;
somparentorder.cpp                TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckResumeProgress: Setting forfeit flag to forfeit at the next opportunity because there was an error during AttachChildren (but some inflight attachments): attaching_inflight="<<m_attached_children_count<<" error="<<TTSDK_ERROR_STR[error]<<endl;
somparentorder.cpp                TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckResumeProgress: Inflight attach requests still in progress for order_id="<<child->GetOrderIDString()<<" status="<<child->InflightStatus()<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckResumeProgress: Forfeiting resume and stopping algo during subtask. subtask_type="<<RESUME_SUBTASK_STR[to_underlying(GetResumeSubTask())]<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckResumeProgress: Forfeiting resume and stopping algo because children could not be attached"<<endl;
somparentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] SetPrOrder: pr_instrument_id="<<GetInstrID()<<"ld not same as instr_id="<<somChildOrder->GetInstrID()<<"ld"<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AttachChildren: No children to be attached"<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AttachChildren: Params for a recovered child was unexpectedly a nullptr. index="<<i<<"u recovered_child_size="<<m_recoveredChildrenSize<<"u"<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AttachChildren: Missing order_id for a child order"<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AttachChildren: Missing account_id. order_id="<<order_id<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AttachChildren: Missing instr_id. order_id="<<order_id<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AttachChildren: Missing order_type. order_id="<<order_id<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AttachChildren: Missing tif. order_id="<<order_id<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AttachChildren: Missing side. order_id="<<order_id<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AttachChildren: Missing working_qty. order_id="<<order_id<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AttachChildren: Missing last exec type. order_id="<<order_id<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AttachChildren: InitFromParams failed. order_id="<<order_id<<endl;
somparentorder.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AttachChildren: AttachOrder failed: order_id="<<order_id<<endl;
somparentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] AttachChildren: Expected PR child order but it is absent!"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] ForfeitRecovery moving recovered to childOrders for clean up m_recoveredChildren_size="<<m_recoveredChildren.size()<<"u childOrders_size="<<m_childOrders.size()<<"u "<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] process_extraction_complete_event: This is a special resume->cancel request to resume first and then cancel immediately afterwards"<<endl;
somparentorder.cpp            TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CompleteResume: Failed to promote cl_ord_id params for accept response: error="<<TTSDK_ERROR_STR[ttsdk_error]<<" "<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CompleteResume: Promoted cl_ord_id params for accept response cl_ord_id="<<cl_ord_id<<"lu orig_cl_ord_id="<<orig_cl_ord_id<<"lu"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] ForfeitResume moving recovered to childOrders for clean up m_recoveredChildren_size="<<m_recoveredChildren.size()<<"u childOrders_size="<<m_childOrders.size()<<"u "<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] SendSuspendStatus on disconnect syn_status="<<TTSDK_SYNTH_STATUS_STR[status]<<endl;
somparentorder.cpp                TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] SendSuspendStatus on disconnect WAT=true and WAT trigger=false"<<endl;
somparentorder.cpp                TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandlePriceError: Disconnect Ignored HasWAT="<<hasWat<<"; childOrderWithATick="<<childOrderWithATick?"Exist":"Notexist"<<"; WithATickApplied="<<childOrderWithATick?std::to_string(childOrderWithATick->WithATickApplied()):"N/A"<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandlePriceError: Disconnect Ignored syn_status="<<TTSDK_SYNTH_STATUS_STR[status]<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: Child expired and will resubmit"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: Child expired and will schedule stop."<<endl;
somparentorder.cpp            TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] RequestStopWithLeaveChildren: This child order will be marked as Leave-On-Cancel: childOrderID="<<child->GetOrderIDString()<<" m_workingQty="<<child->GetWorkingQty()<<".8f isLeaveOnCancel="<<(child->GetLeaveOn()&ttsdk_leave_on_cancel)?std::string("true"):std::string("false")<<" childOrders_size="<<m_childOrders.size()<<"u"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] Concluding change action as a success. completeActionAndStop="<<m_completeActionAndStop<<" requested_qty="<<requestedQty<<".8f requested_prc="<<requested_price<<".8f"<<endl;
somparentorder.cpp    TTLOG(ERROR,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] Concluding change action as a failure, the algo instance will be put into a Failed state."<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] CheckUserChangeProgress: current_task="<<CHANGE_SUBTASK_STR[to_underlying(current_task)]<<" inflights still in progress"<<endl;
somparentorder.cpp        TTLOG(ERROR,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] CheckUserChangeProgress: current_task="<<CHANGE_SUBTASK_STR[to_underlying(current_task)]<<" failed the algo instance will be put into a Failed state."<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] CheckUserChangeProgress: Next current_task="<<CHANGE_SUBTASK_STR[to_underlying(current_task)]<<" pending"<<endl;
somparentorder.cpp        TTLOG(ERROR,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] CheckUserChangeProgress: Next current_task="<<CHANGE_SUBTASK_STR[to_underlying(current_task)]<<" failed"<<endl;
somparentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Qty changed while offline. change parent qty from "<<GetOrderQuantity()<<".8f to "<<qty_from_recovered_children<<".8f "<<endl;
somparentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Fill missed: recovered_child.FillQty="<<filled_qty<<".8f parent.FillQty="<<cum_fill<<".8f "<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] FollowExternalChildPrice: child_price="<<child_price<<".8f parent_price="<<GetLimitPrice()<<".8f in_progress_price="<<GetLimitPrice(GetInProgressRequest())<<".8f is_absolute="<<is_absolute<<endl;
somparentorder.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] CheckPriceDrift: Exempt!"<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] No remaining qty to generate slice schedule"<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Adding preview slices to slice schedule"<<endl;
somparentorder.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Unable to generate slice schedule. remaining_qty="<<remaining_qty<<".0f disc_qty="<<disc_qty<<".0f"<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Generated new slice schedule. "<<GetSliceSummary()<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Will check for any preview slices required_qty="<<required_qty<<".0f placed_qty="<<placed_qty<<".0f"<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] No preview slices to use"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] "<<ss.str()<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] incorrect preview qty as it is greater than required + placed so preview slices won't be used."<<endl;
somparentorder.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] No volume placed so far will use preview slices"<<endl;
somparentorder.cpp                TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Some volume has already been placed and can be reconciled so will use preview slices"<<endl;
somparentorder.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Some volume has already been placed and can't be reconciled so will not use preview slices"<<endl;
somparentorder.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Custom Slice Schedule:"<<sliceStr<<endl;
oco.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildAdd: order_id="<<childOrder->GetOrderIDString()<<" limitPrc="<<limitPrice<<".8f OQ="<<orderQuantity<<".8f WQ="<<workingQuantity<<".8f "<<endl;
oco.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildAdd: Dropping callback: m_primaryOrder or m_secondaryOrder was unexpectedly a nullptr."<<endl;
oco.cpp    TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleTTStopRestatement: Received child TT Stop restatement: synth_status="<<TTSDK_SYNTH_STATUS_STR[ttStopOrder->GetSynthStatus()]<<endl;
oco.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleTTStopRestatement: Child TT Stop paused - setting last exec_type to EXEC_TYPE_SUSPENDED"<<endl;
oco.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleTTStopRestatement: Child TT Stop failed, stopping TT OCO instance!"<<endl;
oco.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReplace: order_id="<<childOrder->GetOrderIDString()<<" limitPrc="<<limitPrice<<".8f OQ="<<orderQuantity<<".8f WQ="<<workingQuantity<<".8f external="<<external<<" requestsPending="<<requestsPending<<endl;
oco.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReplace: Dropping callback: m_primaryOrder or m_secondaryOrder was unexpectedly a nullptr."<<endl;
oco.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] 2nd child order_id="<<childOrder->GetOrderIDString()<<" triggered, Delete primary child order_id="<<m_primaryOrder->GetOrderIDString()<<endl;
oco.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] OnChildCancel: order_id="<<childOrder->GetOrderIDString()<<" external="<<external<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
oco.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: Dropping callback: m_primaryOrder or m_secondaryOrder was unexpectedly a nullptr."<<endl;
oco.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: ShouldStopParent returned TRUE, therefore, stopping algo."<<endl;
oco.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: ShouldStopParent: otherOrder->isPrimary="<<otherOrder.get()==m_primaryOrder.get()?"true":"false"<<" otherOrder->workingQty="<<otherOrder->GetWorkingQty()<<".8f otherOrder->inflightPending="<<otherOrder->GetInflightPending()?"true":"false"<<" otherOrder->orderType="<<TTSDK_OrderTypeToString(otherOrder->GetType())<<endl;
oco.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: ShouldStopParent: Other child order is no longer working, so cancel OCO algo instance."<<endl;
oco.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: ShouldStopParent: Other child order (Primary) is working/pending, so cancel OCO algo instance (redundant stop requests are swallowed)."<<endl;
oco.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: ShouldStopParent: Other child order (Secondary) is triggered and working/pending, so continue OCO algo instance."<<endl;
oco.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: ShouldStopParent: Other child order (Secondary) is un-triggered/pending, so cancel OCO algo instance (redundant stop requests are swallowed)."<<endl;
oco.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildFill: order_id="<<child_order->GetOrderIDString()<<" limitPrc="<<limit_price<<".8f OQ="<<order_quantity<<".8f WQ="<<working_quantity<<".8f FQ="<<fill_quantity<<".8f FlPrc="<<fill_price<<".8f fill_type="<<FILL_TYPE_STR[to_underlying(fill_type)]<<endl;
oco.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildFill: Dropping callback: m_primaryOrder or m_secondaryOrder was unexpectedly a nullptr."<<endl;
oco.cpp    TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildRequestFailure: order_id="<<childOrder->GetOrderIDString()<<" requests_pending="<<requests_pending<<" status_flags=["<<OrderStatusFlagsString(status_flags)<<"] timeout="<<timeout<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
oco.cpp    TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReject: order_id="<<childOrder->GetOrderIDString()<<" external="<<external<<" requests_pending="<<requestsPending<<" message="<<message<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
oco.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] StartWorking: Failed to calculate child price:"<<error<<endl;
oco.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Requesting Secondary TT STOP Order with quantity="<<GetOrderQuantity()<<".8f price="<<price<<".8f trigger_price="<<trigger<<".8f"<<endl;
oco.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate: synth_status="<<TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]<<" m_primaryOrderExists="<<m_primaryOrder?std::string("true"):std::string("false")<<" m_secondaryOrderExists="<<m_secondaryOrder?std::string("true"):std::string("false")<<" m_childPRExists="<<m_childPR?std::string("true"):std::string("false")<<endl;
oco.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate: Sending requests with the following (note: some fields may be invalid depending on the sequence): pending_change_subtasks="<<std::to_string(m_pending_change_subtasks)<<" target_primary_qty="<<m_targetPrimaryQty<<".8f target_secondary_qty="<<m_targetSecondaryQty<<".8f target_pr_qty="<<m_targetPRQty<<".8f"<<endl;
oco.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate: ProcessPendingChangeTasks returned error="<<TTSDK_ERROR_STR[error]<<endl;
oco.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Printing algo params: order_qty="<<GetOrderQuantity()<<".8f limit_prc="<<GetLimitPrice()<<".8f trg_prc="<<GetTriggerPrice()<<".8f synth_status="<<TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]<<" ladder_display="<<GetLadderDisplay()<<" order_type="<<TTSDK_OrderTypeToString(GetType())<<" "<<endl;
oco.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Primary order was deleted by the algo instance (prior to recovery) due to Stop order being triggered."<<endl;
oco.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Order Info: order_ptr="<<static_cast<void*>(childOrder.get())<<" order_id="<<childOrder->GetOrderIDString()<<" order_type="<<TTSDK_OrderTypeToString(childOrder->GetType())<<" order_side="<<childOrder->GetSide()<<" order_qty="<<childOrder->GetOrderQty()<<".8f order_working_qty="<<childOrder->GetWorkingQty()<<".8f order_prc="<<childOrder->GetLimitPrice()<<".8f order_trg_prc="<<childOrder->GetTriggerPrice()<<".8f "<<endl;
oco.cpp                    TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Duplicate m_secondaryOrder detected - the recovery process will fail."<<endl;
oco.cpp                    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: This is the m_secondaryOrder."<<endl;
oco.cpp                        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Duplicate m_primaryOrder detected - the recovery process will fail."<<endl;
oco.cpp                        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Encountered two primary (limit) orders, assuming one is the triggered stop: m_primaryOrder="<<(void*)(m_primaryOrder.get())<<" m_primaryOrder->price="<<m_primaryOrder->GetLimitPrice()<<".8f m_primaryOrderID="<<m_primaryOrder->GetOrderIDString()<<" m_secondaryOrder="<<(void*)(m_secondaryOrder.get())<<" m_secondaryOrderID="<<m_secondaryOrder->GetOrderIDString()<<" m_secondaryOrder->price="<<m_secondaryOrder->GetLimitPrice()<<".8f "<<endl;
oco.cpp                        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: This is the m_secondaryOrder, there should be no m_primaryOrder detected."<<endl;
oco.cpp                        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: This is the m_primaryOrder."<<endl;
oco.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Unexpected scenario where the parent order is aware of more fills than the child orders' fills. cumFillQty="<<cumFilledQty<<".8f m_cum_fill_qty="<<GetCumFillQuantity()<<".8f"<<endl;
oco.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: OCO order recovery failed due to an unexpected scenario: failureOccurred="<<failureOccurred?"true":"false"<<" primaryOrderDeleted="<<primaryOrderDeleted?"true":"false"<<" m_primaryOrder="<<m_primaryOrder==nullptr?"nullptr":"valid"<<" m_secondaryOrder="<<m_secondaryOrder==nullptr?"nullptr":"valid"<<" "<<endl;
oco.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: m_primaryOrder was un-set, so setting it to a dummy order to be safe."<<endl;
oco.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: m_secondaryOrder was un-set, so setting it to a dummy order to be safe."<<endl;
oco.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Secondary (Stop) Order was triggered while offline - deleting Primary Order and matching Secondary Order's working qty to match parent order working qty."<<endl;
oco.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] TryStopAlgo: Stop action could not be scheduled due to: error="<<TTSDK_ERROR_STR[error]<<endl;
volumeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnWorkingPriceUpdate User action is progress, marking price update pending"<<endl;
volumeduration.cpp    TTLOG(INFO,13)<<" ["<<m_name<<":"<<GetOrderIDString()<<"] StartWorking: Restarted tracking current_ttq="<<snapshot->volume<<".8f calc_interval="<<calc_interval<<endl;
volumeduration.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate: Qty reduced below placed quantity, halted slicing order_qty="<<new_qty<<".0f"<<endl;
volumeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleActionFinished User action is complete, processing pending price update"<<endl;
volumeduration.cpp        TTLOG(INFO,13)<<" ["<<m_name<<":"<<GetOrderIDString()<<"] RegenerateSchedule: Updated volume tracking calc_interval="<<calc_interval<<endl;
volumeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: No remaining quantity to generate slice schedule."<<endl;
volumeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: No remaining duration to generate slice schedule."<<endl;
volumeduration.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule FAILED : Remaining number of slices are greater than Remaining Durations. remaining_number_of_slices="<<remaining_number_of_slices<<" remaining_duration="<<remaining_duration<<" "<<endl;
volumeduration.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: Generating new schedule. usePreviewSlices="<<usePreviewSlices?"true":"false"<<" remaining_qty="<<remaining_qty<<".0f remaining_duration="<<remaining_duration<<" interval="<<interval<<" disclosed_qty="<<disc_qty<<".0f revision="<<newRevision<<"u"<<endl;
volumeduration.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: No remaining quantity to generate slice schedule after applying preview slices."<<endl;
volumeduration.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: Calling GenerateIntervalBasedSlices with: remaining_qty="<<remaining_qty<<".0f num_non_preview_slices="<<num_non_preview_slices<<" variance="<<GetVariance()<<" min_qty="<<GetMinimumQuantity()<<".0f"<<endl;
volumeduration.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: Unable to generate slice schedule. disc_value="<<GetDisclosedValue()<<".0f disc_value_type="<<VALUE_TYPE_STR[to_underlying(GetDisclosedValueType())]<<" interval="<<interval<<" schedule_revision="<<newRevision<<"u"<<endl;
volumeduration.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] GenerateSliceSchedule: Generated new slice schedule. schedule_revision="<<newRevision<<"u "<<GetSliceSummary()<<endl;
volume_tracker.cpp        TTLOG(ERROR,13)<<"Interval must be greater than 0, interval="<<m_interval<<endl;
somchildorder.cpp    TTLOG(WARNING,13)<<"[SomChildOrder] Destructor: parent_order_id="<<m_parentOrderIdString<<" order_id="<<m_orderIdString<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<"AccountOverride="<<account_override<<endl;
somchildorder.cpp    TTLOG(INFO,13)<<"[SomChildOrder] AddOrder: order="<<(void*)m_order<<" order_id="<<m_orderIdString<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" account_id="<<m_accountId<<"lu broker_id="<<broker_id<<"lu algo_compliance_id="<<m_parentOrder->GetAlgoComplianceID()<<"lu type="<<TTSDK_OrderTypeToString(m_type)<<" tif="<<m_tif<<" price="<<price<<".8f quantity="<<quantity<<".8f cancel_pending_on_full_fill="<<cancel_pending_on_full_fill<<" error="<<TTSDK_ORDER_ERR_STR[error]<<" request_id="<<request_id<<" original_time_sent="<<m_original_time_sent<<"lu "<<endl;
somchildorder.cpp        TTLOG(WARNING,13)<<"[SomChildOrder] ChangeOrder IGNORED: order=nullptr"<<endl;
somchildorder.cpp        TTLOG(WARNING,13)<<"[SomChildOrder] ChangeOrder triggered Average Trade Size Check violation, but cancel requests are exempt from the check: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<m_orderIdString<<endl;
somchildorder.cpp        TTLOG(WARNING,13)<<"[SomChildOrder] ChangeOrder triggered Max Order Rate violation, but cancel requests are exempt from the check: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<m_orderIdString<<endl;
somchildorder.cpp        TTLOG(ERROR,13)<<"[SomChildOrder] ChangeOrder FAILED: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<m_orderIdString<<" price="<<price<<".8f quantity="<<quantity<<".8f m_order_status="<<TTSDK_OrderStatusToString(m_order_status)<<" override_flags="<<(unsignedlonglong)override_flags<<"lu error="<<TTSDK_ORDER_ERR_STR[error]<<endl;
somchildorder.cpp    TTLOG(INFO,13)<<"[SomChildOrder] ChangeOrder: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<m_orderIdString<<" price="<<price<<".8f quantity="<<quantity<<".8f request_id="<<request_id<<endl;
somchildorder.cpp        TTLOG(ERROR,13)<<"[SomChildOrder] AttachOrder FAILED: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<order_id_str<<" error="<<TTSDK_ERROR_STR[error]<<endl;
somchildorder.cpp    TTLOG(INFO,13)<<"[SomChildOrder] AttachOrder: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<order_id_str<<" request_id="<<request_id<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<"SomChildOrder] GoToMarket using market order order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" quantity="<<m_goToMarketQuantity<<".8f"<<endl;
somchildorder.cpp            TTLOG(ERROR,13)<<"[SomChildOrder] GoToMarket: Failed to delete the order for gtm leftover action order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" error="<<TTSDK_ERROR_STR[delete_error_code]<<endl;
somchildorder.cpp            TTLOG(ERROR,13)<<"[SomChildOrder] GoToMarket: Failed to determine best price for synthetic market order order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" error="<<error_str<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<"SomChildOrder] GoToMarket using synthetic market order order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" price="<<adjusted_price<<".8f quantity="<<m_goToMarketQuantity<<".8f"<<endl;
somchildorder.cpp            TTLOG(ERROR,13)<<"[SomChildOrder] GoToMarket: Failed to change the order for the synthetic market order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" error="<<TTSDK_ERROR_STR[change_error_code]<<endl;
somchildorder.cpp        TTLOG(WARNING,13)<<"[SomChildOrder] DeleteOrder IGNORED: order=nullptr"<<endl;
somchildorder.cpp        TTLOG(ERROR,13)<<"[SomChildOrder] DeleteOrder FAILED: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<m_orderIdString<<" order_type="<<TTSDK_OrderTypeToString(GetType())<<" m_order_status="<<TTSDK_OrderStatusToString(m_order_status)<<" error="<<TTSDK_ORDER_ERR_STR[error]<<endl;
somchildorder.cpp    TTLOG(INFO,13)<<"[SomChildOrder] DeleteOrder: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<m_orderIdString<<" request_id="<<request_id<<" order_type="<<TTSDK_OrderTypeToString(GetType())<<" m_order_status="<<TTSDK_OrderStatusToString(m_order_status)<<endl;
somchildorder.cpp        TTLOG(WARNING,13)<<"[SomChildOrder] SuspendOrder IGNORED: order=nullptr"<<endl;
somchildorder.cpp        TTLOG(ERROR,13)<<"[SomChildOrder] SuspendOrder FAILED: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<m_orderIdString<<" order_type="<<TTSDK_OrderTypeToString(GetType())<<" m_order_status="<<TTSDK_OrderStatusToString(m_order_status)<<" error="<<TTSDK_ORDER_ERR_STR[error]<<endl;
somchildorder.cpp    TTLOG(INFO,13)<<"[SomChildOrder] SuspendOrder: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<m_orderIdString<<" request_id="<<request_id<<" order_type="<<TTSDK_OrderTypeToString(GetType())<<" m_order_status="<<TTSDK_OrderStatusToString(m_order_status)<<endl;
somchildorder.cpp        TTLOG(WARNING,13)<<"[SomChildOrder] UnSuspendOrder IGNORED: order=nullptr"<<endl;
somchildorder.cpp        TTLOG(ERROR,13)<<"[SomChildOrder] UnSuspendOrder FAILED: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<m_orderIdString<<" order_type="<<TTSDK_OrderTypeToString(GetType())<<" m_order_status="<<TTSDK_OrderStatusToString(m_order_status)<<" error="<<TTSDK_ORDER_ERR_STR[error]<<endl;
somchildorder.cpp    TTLOG(INFO,13)<<"[SomChildOrder] UnSuspendOrder: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<m_orderIdString<<" request_id="<<request_id<<" order_type="<<TTSDK_OrderTypeToString(GetType())<<" m_order_status="<<TTSDK_OrderStatusToString(m_order_status)<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<" [SomChildOrder] ApplyLeftoverAction: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<m_orderIdString<<" action="<<LEFT_OVER_ACTION_STR[to_underlying(action)]<<" ticks="<<ticks<<" "<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<"[SomChildOrder] ApplyLeftoverAction: NO ORDER"<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<"["<<m_parentOrder->GetName()<<":"<<m_parentOrder->GetOrderIDString()<<"] ApplyWithATick: No market on opposite side. opposite_inside_price is NAN "<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<"["<<m_parentOrder->GetName()<<":"<<m_parentOrder->GetOrderIDString()<<"] ApplyWithATick: Our price is not directly next to the opposite side inside market. m_orderPrice="<<m_orderPrice<<".8f opposite_next_tick="<<opposite_next_tick<<".8f opposite_inside_price="<<opposite_inside_price<<".8f"<<endl;
somchildorder.cpp            TTLOG(INFO,13)<<"["<<m_parentOrder->GetName()<<":"<<m_parentOrder->GetOrderIDString()<<"] ApplyWithATick: opposite_qty < threshold_qty opposite_qty="<<opposite_qty<<".8f threshold_qty="<<(double)value<<".8f"<<endl;
somchildorder.cpp            TTLOG(INFO,13)<<"["<<m_parentOrder->GetName()<<":"<<m_parentOrder->GetOrderIDString()<<"] ApplyWithATick: opposite_qty < threshold_percent opposite_qty="<<opposite_qty<<".8f threshold_percent="<<(double)value<<".8f"<<endl;
somchildorder.cpp        TTLOG(WARNING,13)<<"[SomChildOrder] DetachOrder IGNORED: order=nullptr"<<endl;
somchildorder.cpp        TTLOG(WARNING,13)<<"[SomChildOrder] order="<<(void*)m_order<<" Already detaching or detached"<<endl;
somchildorder.cpp        TTLOG(ERROR,13)<<"[SomChildOrder] DetachOrder FAILED: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<m_orderIdString<<" m_order_status="<<TTSDK_OrderStatusToString(m_order_status)<<" error="<<TTSDK_ERROR_STR[error]<<endl;
somchildorder.cpp    TTLOG(INFO,13)<<"[SomChildOrder] DetachOrder: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<m_orderIdString<<" request_id="<<request_id<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<"[SomChildOrder] OnOrderEvent on deleted parent= + m_parentOrderIdString + order_id="<<endl;
somchildorder.cpp        TTLOG(DEBUG,13)<<"["<<m_parentOrder->GetName()<<":"<<m_parentOrder->GetOrderIDString()<<"] SomChildOrder::OnOrderEvent: Dropping grand child order response!"<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<"[SomChildOrder] ParentOrderTestHarness: OnOrderEvent: Simulating expiration: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<order_id_str<<endl;
somchildorder.cpp    TTLOG(INFO,13)<<"[SomChildOrder] OnOrderEvent: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<order_id_str<<" last_status="<<TTSDK_OrderStatusToString(order_snap->last_status)<<" external="<<(order_snap->last_status_flags&ttsdk_external_order_event)<<" last_status_flags=0x"<<order_snap->last_status_flags<<" user_request_id="<<user_request_id<<" last_request_id="<<m_lastRequestId<<" message="<<message<<" is_reject_unknown_order="<<m_is_reject_unknown_order<<" "<<log_info.str()<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<"[SomChildOrder] ParentOrderTestHarness: OnOrderEvent: Simulating reject: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<order_id_str<<endl;
somchildorder.cpp                TTLOG(INFO,13)<<"[SomChildOrder] OnOrderEvent (NO-OP response for PR): No pending actions remain, converting this NO-OP response into "<<fp_zero(m_workingQty)?"OnChildCancel":"OnChildReplace"<<" order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<order_id_str<<" "<<endl;
somchildorder.cpp            TTLOG(DEBUG,13)<<"[SomChildOrder] OnOrderEvent: Dropping unhandled PR order status type: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<order_id_str<<" "<<endl;
somchildorder.cpp                TTLOG(INFO,13)<<"[SomChildOrder] OnOrderEvent: Partial fill reducing go to market quantity: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<order_id_str<<" go to market qty="<<m_goToMarketQuantity<<endl;
somchildorder.cpp                TTLOG(INFO,13)<<"[SomChildOrder] OnOrderEvent: Full fill interrupted go to market action: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<order_id_str<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<"[SomChildOrder] OnOrderEvent: last_status="<<TTSDK_OrderStatusToString(order_snap->last_status)<<" last_status_flags="<<order_snap->last_status_flags<<"8x order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<order_id_str<<endl;
somchildorder.cpp                TTLOG(INFO,13)<<"[SomChildOrder] OnOrderEvent (unsolicited cancel): Violated max unsolicited cancel rate! Algo instance will continue running but its next child order add / change request will get rejected, (most likely) causing the instance to fail: last_status="<<TTSDK_OrderStatusToString(order_snap->last_status)<<" order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<order_id_str<<endl;
somchildorder.cpp            TTLOG(INFO,13)<<" [SomChildOrder] OnOrderEvent (noop): No pending actions remain, deliver "<<fp_zero(m_workingQty)?"OnChildCancel":"OnChildReplace"<<" order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<order_id_str<<" "<<endl;
somchildorder.cpp    TTLOG(INFO,13)<<"[SomChildOrder] OnDetach: order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<m_orderIdString<<" incoming_request_id="<<user_request_id<<" last_sent_request_id="<<m_lastRequestId<<" last_confirmed_request_id="<<m_confirmedRequestId<<endl;
somchildorder.cpp        TTLOG(ERROR,13)<<"[SomChildOrder] InitFromParams: Incoming params was a nullptr"<<endl;
somchildorder.cpp        TTLOG(ERROR,13)<<" [SomChildOrder] InitFromParams: SSE algo instance unexpectedly attached to a child order that it did not create: order_id="<<order_id_str<<" algo_inst_id="<<m_parentOrder->GetOrderIDString()<<" "<<endl;
somchildorder.cpp    TTLOG(INFO,13)<<" [SomChildOrder] InitFromParams: Successfully initialized using params: order_ptr="<<(void*)this<<" ttsdk_order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<order_id_str<<" order_type="<<TTSDK_OrderTypeToString(ord_type)<<" price="<<price<<".8f trg_price="<<trg_price<<".8f order_qty="<<quantity<<".8f working_qty="<<working_quantity<<".8f cum_qty="<<cum_quantity<<".8f last_fill_prc="<<last_fill_price<<".8f last_fill_qty="<<last_fill_quantity<<".8f last_request_id="<<m_lastRequestId<<" last_exec_type="<<ord_exec_type<<" last_message="<<message<<" synth_status="<<TTSDK_SYNTH_STATUS_STR[m_synth_status]<<" algo_instr_id="<<algo_instr_id<<"lu m_original_time_sent="<<m_original_time_sent<<"lu("<<original_date_sent_string<<")"<<endl;
somchildorder.cpp    TTLOG(INFO,13)<<"[SomChildOrder] OnAttach: Successfully downloaded latest order snapshot from ledger - initializing SomChildOrder using the order snapshot: order="<<(void*)m_order<<" order_snapshot="<<order_snap.get()<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" user_request_id="<<user_request_id<<" order_status="<<TTSDK_OrderStatusToString(order_snap->last_status)<<endl;
somchildorder.cpp        TTLOG(ERROR,13)<<"[SomChildOrder] OnAttach: Initialization failed: order="<<(void*)m_order<<" order_snapshot="<<order_snap.get()<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" user_request_id="<<user_request_id<<endl;
somchildorder.cpp    TTLOG(INFO,13)<<"[SomChildOrder] OnOrderRequestFailed: event="<<TTSDK_OrderEventToString(event)<<" order="<<(void*)m_order<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" order_id="<<m_orderIdString<<" request_id="<<user_request_id<<" last_request_id="<<m_lastRequestId<<" failure_status_flagss=0x"<<failure_status_flags<<" m_order_status="<<TTSDK_OrderStatusToString(m_order_status)<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<" [SomChildOrder] order_id="<<m_orderIdString<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" PayUp!! ticks="<<ticks<<", new_price="<<new_price<<".8f"<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<"Order suspended: order_id="<<m_orderIdString<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" m_workingQty="<<m_workingQty<<".8f m_orderQty="<<m_orderQty<<".8f m_orderPrice="<<m_orderPrice<<".8f"<<endl;
somchildorder.cpp            TTLOG(INFO,13)<<"Order Expired and will be resubmit order_id="<<m_orderIdString<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" m_workingQty="<<m_workingQty<<".8f m_orderQty="<<m_orderQty<<".8f m_orderPrice="<<m_orderPrice<<".8f "<<endl;
somchildorder.cpp    TTLOG(INFO,13)<<"[SomChildOrder] RemoveInflightPending parent_order_id="<<m_parentOrder->GetOrderIDString()<<" m_confirmedRequestId="<<m_confirmedRequestId<<" m_lastRequestId="<<m_lastRequestId<<" "<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<"No need to resubmit order_id="<<m_orderIdString<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" m_order_status="<<TTSDK_OrderStatusToString(m_order_status)<<" "<<endl;
somchildorder.cpp    TTLOG(INFO,13)<<"Resubmit [order_id="<<m_orderIdString<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" m_order_status="<<TTSDK_OrderStatusToString(m_order_status)<<"] ChangeOrder to m_orderQty="<<m_orderQty<<".8f m_orderPrice="<<m_orderPrice<<".8f m_triggerPrice="<<m_triggerPrice<<".8f "<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<"[SomChildOrder] GTM delete ok received; sending market order order_id="<<m_orderIdString<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" quantity="<<m_goToMarketQuantity<<".8f"<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<"[SomChildOrder] GTM add ok received; gtm complete order_id="<<m_orderIdString<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" quantity="<<m_goToMarketQuantity<<".8f"<<endl;
somchildorder.cpp        TTLOG(INFO,13)<<"[SomChildOrder] GTM change ok received; gtm complete order_id="<<m_orderIdString<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" quantity="<<m_goToMarketQuantity<<".8f"<<endl;
somchildorder.cpp        TTLOG(ERROR,13)<<"[SomChildOrder] GTM reject received; gtm failed order_id="<<m_orderIdString<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" quantity="<<m_goToMarketQuantity<<".8f"<<endl;
somchildorder.cpp        TTLOG(WARNING,13)<<"[SomChildOrder] Unknown GTM event received order_id="<<m_orderIdString<<" parent_order_id="<<m_parentOrder->GetOrderIDString()<<" event="<<event<<endl;
withatick.cpp             TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandlePriceError: Disconnect Ignored No Child order."<<endl;
withatick.cpp                TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandlePriceError: Disconnect Ignored WithATickApplied."<<endl;
withatick.cpp                TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] SendSuspendStatus on disconnect WAT=true and WAT trigger=false"<<endl;
bracket.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildAdd: limitPrc="<<limitPrice<<".8f OQ="<<orderQuantity<<".8f WQ="<<workingQuantity<<".8f"<<endl;
bracket.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReplace: order_id="<<childOrder->GetOrderIDString()<<" limitPrc="<<limitPrice<<".8f OQ="<<orderQuantity<<".8f WQ="<<workingQuantity<<".8f external="<<external<<" requestsPending="<<requestsPending<<endl;
bracket.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: order_id="<<childOrder->GetOrderIDString()<<" external="<<external<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
bracket.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: Dropping. m_primaryOrder=nullptr."<<endl;
bracket.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildCancel: Dropping OCO callback."<<endl;
bracket.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildFill: limitPrc="<<limit_price<<".8f OQ="<<order_quantity<<".8f WQ="<<working_quantity<<".8f FQ="<<fill_quantity<<".8f FlPrc="<<fill_price<<".8f fill_type="<<FILL_TYPE_STR[to_underlying(fill_type)]<<endl;
bracket.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildFill: Dropping callback - m_primaryOrder was unexpectedly a nullptr."<<endl;
bracket.cpp        TTLOG(DEBUG,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildFill: Dropping OCO callback."<<endl;
bracket.cpp    TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildRequestFailure: requests_pending="<<requests_pending<<" status_flags=["<<OrderStatusFlagsString(status_flags)<<"] timeout="<<timeout<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
bracket.cpp    TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReject: order_id="<<childOrder->GetOrderIDString()<<" external="<<external<<" requests_pending="<<requestsPending<<" message="<<message<<" ActionInProgress="<<USER_ACTION_STR[to_underlying(GetActionInProgress())]<<endl;
bracket.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] StartWorking: Failed to calculate child price:"<<error<<endl;
bracket.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Add m_primaryOrder="<<(void*)m_primaryOrder.get()<<endl;
bracket.cpp    TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate should not be called"<<endl;
bracket.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Printing algo params: order_qty="<<GetOrderQuantity()<<".8f filled_qty="<<GetCumFillQuantity()<<".8f working_qty="<<GetWorkingQuantity()<<".8f limit_prc="<<GetLimitPrice()<<".8f trg_prc="<<GetTriggerPrice()<<".8f synth_status="<<TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]<<" ladder_display="<<GetLadderDisplay()<<" order_type="<<TTSDK_OrderTypeToString(GetType())<<endl;
bracket.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Iterating through attached SomChildOrders, hedging each fill in a piece-meal fashion."<<endl;
bracket.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Order Info: order_ptr="<<static_cast<void*>(childOrder.get())<<" order_id="<<childOrder->GetOrderIDString()<<" order_type="<<TTSDK_OrderTypeToString(childOrder->GetType())<<" order_side="<<childOrder->GetSide()<<" order_qty="<<childOrder->GetOrderQty()<<".8f order_working_qty="<<childOrder->GetWorkingQty()<<".8f order_prc="<<childOrder->GetLimitPrice()<<".8f order_trg_prc="<<childOrder->GetTriggerPrice()<<".8f "<<endl;
bracket.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: OCO order_id="<<childOrder->GetOrderIDString()<<endl;
bracket.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Collected filled qty from the child order ("<<(void*)m_primaryOrder.get()<<"): child_filled_qty="<<childOrder->GetFilledQty()<<".8f filled_qty_collected_from_children="<<cumFillQty<<".8f"<<endl;
bracket.cpp                    TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Duplicate m_primaryOrder detected - the recovery process will fail."<<endl;
bracket.cpp                    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: This is the m_primaryOrder."<<endl;
bracket.cpp                TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Recover m_primaryOrder="<<(void*)m_primaryOrder.get()<<endl;
bracket.cpp                TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Primary is fully filled or cancelled. order_id="<<childOrder->GetOrderIDString()<<endl;
bracket.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Hedging offline filled qty: parent_filled_qty="<<currCumFillQty<<".8f filled_qty_collected_from_children="<<cumFillQty<<".8f offline_filled_qty="<<offlineFilledQty<<".8f"<<endl;
bracket.cpp            TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Bracket order recovery failed due to an unexpected scenario: failureOccurred="<<failureOccurred?"true":"false"<<" m_primaryOrder="<<m_primaryOrder==nullptr?"nullptr":"valid"<<endl;
bracket.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: m_profitTargetTicks="<<m_profitTargetTicks<<", profitPrice="<<profitPrice<<", m_stopTargetTicks="<<m_stopTargetTicks<<", triggerPrice="<<triggerPrice<<", fill_price="<<fill_price<<endl;
bracket.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Add ocoOrder="<<(void*)ocoOrder.get()<<endl;
bracket.cpp            TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] SendSuspendStatus on disconnect syn_status="<<TTSDK_SYNTH_STATUS_STR[status]<<endl;
bracket.cpp                TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] SendSuspendStatus on disconnect m_bracketOrderType="<<m_bracketOrderType<<"; NativeStopTriggered=false"<<endl;
bracket.cpp                TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandlePriceError: Disconnect Ignored m_bracketOrderType="<<m_bracketOrderType<<"; m_primaryOrder="<<m_primaryOrder?"Exist":"Notexist"<<"; NativeStopTriggered="<<m_primaryOrder?std::to_string(m_primaryOrder->NativeStopTriggered()):"N/A"<<endl;
bracket.cpp            TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandlePriceError: Disconnect Ignored syn_status="<<TTSDK_SYNTH_STATUS_STR[status]<<endl;
volumeslicer.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnWorkingPriceUpdate User action is progress, marking price update pending"<<endl;
volumeslicer.cpp    TTLOG(INFO,13)<<" ["<<m_name<<":"<<GetOrderIDString()<<"] StartWorking: current_ttq="<<snapshot->volume<<".8f "<<endl;
volumeslicer.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate: Qty reduced, halted slicing order_qty="<<new_qty<<".0f"<<endl;
volumeslicer.cpp        TTLOG(INFO,13)<<" ["<<m_name<<":"<<GetOrderIDString()<<"] Restarting slicing: current_ttq="<<snapshot->volume<<".8f "<<endl;
volumeslicer.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] No remaining qty to generate slice schedule"<<endl;
volumeslicer.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Unable to generate slice schedule. remaining_qty="<<remaining_qty<<".0f disc_qty="<<disc_qty<<".0f"<<endl;
volumeslicer.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] Generated new slice schedule. "<<GetSliceSummary()<<endl;
retry.cpp        TTLOG(ERROR,13)<<"[Retry="<<GetOrderIDString()<<"] missing RetryCount parameter"<<endl;
retry.cpp        TTLOG(ERROR,13)<<"[Retry="<<GetOrderIDString()<<"] missing RetryInterval parameter"<<endl;
retry.cpp    TTLOG(INFO,13)<<"[Retry="<<GetOrderIDString()<<"] OnChildAdd: limitPrc="<<limitPrice<<".8f OQ="<<orderQuantity<<".8f WQ="<<workingQuantity<<".8f "<<endl;
retry.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] HandleUpdate: "<<reject_msg<<endl;
retry.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] HandleUpdate: result="<<TTSDK_ERROR_STR[result]<<" synth_status="<<TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]<<" childOrdersSize="<<m_childOrders.size()<<"u childPRExists="<<m_childPR?"true":"false"<<" retry_returned="<<m_retry_returned<<" "<<endl;
retry.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildReplace: limitPrc="<<limitPrice<<".8f OQ="<<orderQuantity<<".8f WQ="<<workingQuantity<<".8f Extern="<<external<<" requestsPending="<<requestsPending<<" "<<endl;
retry.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnScheduledEvent: StartTime fired "<<endl;
retry.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"]: OnScheduledEvent: CheckInitializationProgress"<<endl;
retry.cpp        TTLOG(WARNING,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnScheduledEvent: Unexpected ScheduledEvent="<<id<<endl;
retry.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildOrderEvent status="<<TTSDK_OrderStatusToString(order_snap->last_status)<<" attempts="<<instructions.attempts<<"u"<<endl;
retry.cpp            TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] OnChildOrderEvent No retry attempted. OC returns on first shot status="<<TTSDK_OrderStatusToString(order_snap->last_status)<<endl;
retry.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] count="<<m_count<<" interval="<<m_interval<<" "<<endl;
retry.cpp    TTLOG(INFO,13)<<"["<<GetName()<<":"<<GetOrderIDString()<<"] Retry is immune to Price error"<<endl;
retry.cpp    TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: order_qty="<<GetOrderQuantity()<<".8f limit_prc="<<GetLimitPrice()<<".8f synth_status="<<TTSDK_SYNTH_STATUS_STR[GetSynthStatus()]<<" cum_filled_qty="<<GetCumFillQuantity()<<".8f order_type="<<TTSDK_OrderTypeToString(GetType())<<" children_size="<<children_size<<"u "<<endl;
retry.cpp        TTLOG(INFO,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: Child Info: order_ptr="<<static_cast<void*>(childOrder.get())<<" order_id="<<childOrder->GetOrderIDString()<<" order_type="<<TTSDK_OrderTypeToString(childOrder->GetType())<<" order_side="<<childOrder->GetSide()<<" order_qty="<<childOrder->GetOrderQty()<<".8f filled_qty="<<childOrder->GetFilledQty()<<".8f order_working_qty="<<childOrder->GetWorkingQty()<<".8f order_prc="<<childOrder->GetLimitPrice()<<".8f order_trg_prc="<<childOrder->GetTriggerPrice()<<".8f time_sent="<<childOrder->GetTimeSent()<<"lu "<<endl;
retry.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: no working_child found."<<endl;
retry.cpp        TTLOG(ERROR,13)<<"["<<m_name<<":"<<GetOrderIDString()<<"] ResumeWorking: child not working"<<endl;
position_mgr.cpp    TTLOG(INFO,13)<<"PositionMgr::GetOrCreateRiskBucket: order_id="<<ttuuid(order_params->ord_id)<<", required="<<required<<endl;
position_mgr.cpp        TTLOG(ERROR,13)<<"Invalid params to create risk bucket"<<endl;
position_mgr.cpp        TTLOG(INFO,13)<<"PositionMgr: New risk bucket created. bucket="<<(void*)(bucket.get())<<" parent_id="<<bucket->parent_id<<" instr_id="<<bucket->instr_id<<"lu account_id="<<bucket->account_id<<"lu side="<<bucket->side<<endl;
position_mgr.cpp            TTLOG(ERROR,13)<<"PositionMgr: AddOrderHandleToRiskBucket failed - PR order is already attached to this risk bucket. bucket="<<(void*)(bucket.get())<<" current order_handle="<<(void*)(sp.get())<<" request order_handle="<<(void*)(order_handle.get())<<endl;
position_mgr.cpp            TTLOG(ERROR,13)<<"PositionMgr: AddOrderHandleToRiskBucket failed - Risk bucket already tracking position limit. bucket="<<(void*)(bucket.get())<<" order_handle="<<(void*)(order_handle.get())<<endl;
position_mgr.cpp            TTLOG(ERROR,13)<<"PositionMgr: AddOrderHandleToRiskBucket failed - could not emplace into set. bucket="<<(void*)(bucket.get())<<" order_handle_count="<<bucket->order_handles.size()<<"u order_handle="<<(void*)(order_handle.get())<<endl;
position_mgr.cpp        TTLOG(INFO,13)<<"PositionMgr: Attached PR order to risk bucket. bucket="<<(void*)(bucket.get())<<" order_handle_count="<<bucket->order_handles.size()<<"u order_handle="<<(void*)(order_handle.get())<<endl;
position_mgr.cpp        TTLOG(ERROR,13)<<"PositionMgr: AddOrderHandleToRiskBucket failed - could not emplace into set. bucket="<<(void*)(bucket.get())<<" order_handle_count="<<bucket->order_handles.size()<<"u order_handle="<<(void*)(order_handle.get())<<endl;
position_mgr.cpp    TTLOG(INFO,13)<<"PositionMgr: Order handle added to risk bucket. bucket="<<(void*)(bucket.get())<<" order_handle_count="<<bucket->order_handles.size()<<"u order_handle="<<(void*)(order_handle.get())<<endl;
position_mgr.cpp        TTLOG(INFO,13)<<"PositionMgr: Order handle removed from risk bucket. bucket="<<(void*)(bucket.get())<<" order_handle_count="<<bucket->order_handles.size()<<"u order_handle="<<(void*)(order_handle.get())<<endl;
position_mgr.cpp        TTLOG(WARNING,13)<<"PositionMgr: Removing untracked order handle. bucket="<<(void*)(bucket.get())<<" order_handle_count="<<bucket->order_handles.size()<<"u order_handle="<<(void*)(order_handle.get())<<endl;
position_mgr.cpp            TTLOG(INFO,13)<<"PositionMgr: Risk bucket removed. bucket="<<(void*)(bucket.get())<<" parent_id="<<bucket->parent_id<<" instr_id="<<bucket->instr_id<<"lu account_id="<<bucket->account_id<<"lu side="<<bucket->side<<endl;
position_mgr.cpp            TTLOG(WARNING,13)<<"PositionMgr: Removing untracked risk bucket. bucket="<<(void*)(bucket.get())<<" parent_id="<<bucket->parent_id<<" instr_id="<<bucket->instr_id<<"lu account_id="<<bucket->account_id<<"lu side="<<bucket->side<<endl;
position_mgr.cpp    TTLOG(INFO,13)<<"PositionMgr: Starting batch removal for parent_id="<<parent_id<<endl;
position_mgr.cpp            TTLOG(INFO,13)<<"PositionMgr: Risk bucket removed. bucket="<<(void*)((*it).get())<<" parent_id="<<(*it)->parent_id<<" instr_id="<<(*it)->instr_id<<"lu account_id="<<(*it)->account_id<<"lu side="<<(*it)->side<<endl;
position_mgr.cpp        TTLOG(INFO,13)<<"PositionMgr: Order not subject to check"<<endl;
position_mgr.cpp            TTLOG(INFO,13)<<"PositionMgr: Skipping check - PR qty is unchanged or increasing"<<endl;
position_mgr.cpp            TTLOG(INFO,13)<<"PositionMgr: Skipping check - Accrued technical debt"<<endl;
position_mgr.cpp            TTLOG(INFO,13)<<"PositionMgr: Skipping check since qty is unchanged or decreasing"<<endl;
position_mgr.cpp    TTLOG(INFO,13)<<"PositionMgr: Before send. limit_breached="<<limit_breached<<" order_handle="<<(void*)(order_handle.get())<<" bucket="<<(void*)(bucket.get())<<" parent_id="<<bucket->parent_id<<" instr_id="<<bucket->instr_id<<"lu account_id="<<bucket->account_id<<"lu side="<<bucket->side<<" current_logical_ord_qty="<<current_logical_order_qty<<".8f desired_logical_ord_qty="<<desired_logical_order_qty<<".8f most_strict_limit="<<bucket->most_strict_limit<<".8f position_limit="<<bucket->position_limit<<".8f worst_case_position="<<bucket->worst_case_position<<".8f is_delete="<<is_delete<<endl;
position_mgr.cpp    TTLOG(INFO,13)<<"PositionMgr: Updating on receive. limit_breached="<<limit_breached<<" order_handle="<<(void*)(order_handle.get())<<" bucket="<<(void*)(bucket.get())<<" parent_id="<<bucket->parent_id<<" instr_id="<<bucket->instr_id<<"lu account_id="<<bucket->account_id<<"lu side="<<bucket->side<<" previous_logical_order_qty="<<previous_logical_order_qty<<".8f current_logical_ord_qty="<<current_logical_order_qty<<".8f inflight_request_exists="<<inflight_request_exists<<" inflight_logical_order_qty="<<inflight_logical_order_qty<<".8f most_strict_limit="<<bucket->most_strict_limit<<".8f position_limit="<<bucket->position_limit<<".8f worst_case_position="<<bucket->worst_case_position<<".8f is_pr="<<is_pr<<endl;
position_mgr.cpp        TTLOG(INFO,13)<<"PositionMgr: DiscountWorstCasePositionByFill: Order not subject to check"<<endl;
position_mgr.cpp            TTLOG(INFO,13)<<"PositionMgr: New risk bucket created (as sibling). bucket="<<(void*)(sibling.get())<<" parent_id="<<sibling->parent_id<<" instr_id="<<sibling->instr_id<<"lu account_id="<<sibling->account_id<<"lu side="<<sibling->side<<endl;
position_mgr.cpp    TTLOG(INFO,13)<<"PositionMgr: Discounting sibling worst position. bucket="<<(void*)(bucket.get())<<" parent_id="<<bucket->parent_id<<" instr_id="<<bucket->instr_id<<"lu account_id="<<bucket->account_id<<"lu side="<<bucket->side<<" fill_qty="<<fill_qty<<".8f sibling.bucket="<<(void*)(sibling.get())<<" sibling.position_limit="<<sibling->position_limit<<".8f sibling.worst_case_position="<<sibling->worst_case_position<<".8f"<<endl;
position_mgr.cpp        TTLOG(INFO,13)<<"PositionMgr: TryUpdateSenders failed - arguments invalid."<<endl;
position_mgr.cpp        TTLOG(INFO,13)<<"PositionMgr: TryUpdateSenders failed - no order handles in the bucket. bucket="<<(void*)(bucket.get())<<endl;
position_mgr.cpp        TTLOG(INFO,13)<<"PositionMgr: Switched to OC sender for: order_id="<<order_uuid_string<<" bucket="<<(void*)(bucket.get())<<" order_handle="<<(void*)(order_handle.get())<<endl;
orderd.cpp        TTLOG(WARNING,13)<<"~client_order_data order_handle.use_count="<<order_handle.use_count()<<"u ---Check for Leak"<<endl;
orderd.cpp    TTLOG(DEBUG,13)<<"~client_order_data"<<endl;
orderd.cpp    TTLOG(DEBUG,13)<<"~orderd__order_handle"<<endl;
orderd.cpp    TTLOG(INFO,13)<<"OrderD::OrderD Constructor, inst_id: "<<m_instanceId<<", m_instanceIdHash="<<m_instanceIdHash<<"lu (0X"<<m_instanceIdHash<<"8X)"<<endl;
orderd.cpp    TTLOG(INFO,13)<<"HOW BAD IS sizeof(orderd__order_handle)="<<sizeof(orderd__order_handle)<<"u"<<endl;
orderd.cpp    TTLOG(INFO,13)<<"HOW BAD IS sizeof(NewOrderSingle)="<<sizeof(NewOrderSingle)<<"u"<<endl;
orderd.cpp    TTLOG(INFO,13)<<"HOW BAD IS sizeof(OrderCancelReplaceRequest)="<<sizeof(OrderCancelReplaceRequest)<<"u"<<endl;
orderd.cpp    TTLOG(INFO,13)<<"HOW BAD IS sizeof(OrderSmallPriceQtyRequest)="<<sizeof(OrderSmallPriceQtyRequest)<<"u"<<endl;
orderd.cpp    TTLOG(INFO,13)<<"HOW BAD IS sizeof(OrderCancelRequest)="<<sizeof(OrderCancelRequest)<<"u"<<endl;
orderd.cpp    TTLOG(INFO,13)<<"OrderD::Shutdown..."<<endl;
orderd.cpp    TTLOG(INFO,13)<<"OrderD_DestroyClientData"<<endl;
orderd.cpp        TTLOG(INFO,13)<<"OrderD::Shutdown orderd__init_state_process_common"<<endl;
orderd.cpp    TTLOG(INFO,13)<<"OrderD::Shutdown returning"<<endl;
orderd.cpp        TTLOG(INFO,13)<<" Initializing OrderD:\n sender_location_id : "<<m_sender_location_id<<"\n lbm onload : "<<m_lbmOnload<<"\n lbm affinity : "<<m_lbmAffinity<<"\n orderd affinity : "<<m_orderdAffinity<<"\n unsolicited_enabled : "<<m_unsolicited_enabled<<"\n rate_control : "<<(m_rate_control==orderd__rate_control_limited)?"limited":"none"<<"\n risk_senders : "<<risk_senders<<"\n send_child_algo_to_local : "<<m_send_child_algo_to_local<<"\n bookie_dl_batch_size : "<<m_bookieDownloadBatchSize<<"\n"<<endl;
orderd.cpp        TTLOG(INFO,13)<<" ledger topic="<<ossLedger.str()<<endl;
orderd.cpp            TTLOG(INFO,13)<<"Created Risk sender and OU.M receiver market="<<risk_sender.market_id<<" account="<<risk_sender.account_id<<"lu"<<endl;
orderd.cpp         TTLOG(ERROR,13)<<error<<endl;
orderd.cpp                TTLOG(DEBUG,13)<<" Failure decoding received error="<<ORDERD_ERROR_STR[orderd_error]<<", message=\"<<error<<"\"<<endl;
orderd.cpp                TTLOG(WARNING,13)<<" Failure decoding received error="<<ORDERD_ERROR_STR[orderd_error]<<", message="<<error<<endl;
orderd.cpp        TTLOG(DEBUG,13)<<"Beginning of transport session. Topic="<<message.TopicName()<<" lbm_source="<<message.Source()<<endl;
orderd.cpp        TTLOG(DEBUG,13)<<"End of transport session. Topic="<<message.TopicName()<<" lbm_source="<<message.Source()<<endl;
orderd.cpp    TTLOG(INFO,13)<<"OrderD::BookieDataReceived, length="<<message.Length()<<", topicName="<<message.TopicName()<<", source="<<message.Source()<<endl;
orderd.cpp        TTLOG(ERROR,13)<<"Fail to get order_status from ledger data. error="<<ORDERD_ERROR_STR[orderd_error]<<endl;
orderd.cpp            TTLOG(ERROR,13)<<"Failed to find order handle after Ledger download, download requestor will not get any callback: request_id="<<request_id_str<<" order_id="<<order_id<<endl;
orderd.cpp            TTLOG(ERROR,13)<<"CompleteBookieResponse failed: Delivering failure response to listeners: request_id="<<request_id_str<<" order_id="<<order_id<<" error="<<ORDERD_ERROR_STR[error]<<" error_msg="<<error_msg<<endl;
orderd.cpp            TTLOG(INFO,13)<<"CompleteBookieResponse success: Delivering success response to listeners: request_id="<<request_id_str<<" order_id="<<order_id<<endl;
orderd.cpp        TTLOG(ERROR,13)<<"CleanupChildOrderReceived: Decoding failed, dropping message. request_id="<<response.req_id<<endl;
orderd.cpp    TTLOG(INFO,13)<<"CleanupChildOrderReceived: Received Ledger Response: request_id="<<response.req_id<<" num_children="<<response.num_children<<"u"<<endl;
orderd.cpp            TTLOG(WARNING,13)<<"CleanupChildOrderReceived: Cannot find matching request. request_id="<<response.req_id<<endl;
orderd.cpp            TTLOG(INFO,13)<<"CleanupChildOrderReceived: "<<((skip)?"Skipping":"Canceling")<<" child. order_id="<<order_id<<" parent_id="<<child_cleanup_iter->parent_id<<" user_id="<<child_status.params.user_id<<"lu order_status="<<TTSDK_OrderStatusToString(child_status.status_type)<<" leave_on_cancel="<<leave_on_cancel<<" is_pr_order="<<is_pr_order<<" pr_only="<<pr_only<<endl;
orderd.cpp            TTLOG(INFO,13)<<"CleanupChildOrderReceived: No action required, untracking. parent_id="<<child_cleanup_iter->parent_id<<endl;
orderd.cpp        TTLOG(INFO,13)<<"InitPositionReserveOrderHandleFromSnapshot: Initializing PR order from Ledger download: request_id="<<response->req_id<<" order_id="<<download_order_id<<endl;
orderd.cpp        TTLOG(ERROR,13)<<"InitOrderHandlesFromSnapshot: couldn't find class_1_2_fields for parent_order_id="<<algo_inst_id<<endl;
orderd.cpp            TTLOG(ERROR,13)<<"InitOrderHandlesFromSnapshot: Failure - group adoption by Parent Order ID is not supported yet: request_id="<<response->req_id<<endl;
orderd.cpp        TTLOG(INFO,13)<<"InitOrderHandlesFromSnapshot: Initializing order from Ledger download: request_id="<<response->req_id<<" order_id="<<download_order_id<<" parent_order_id="<<algo_inst_id<<" m_classOneTwoForRecoveryByAlgoId_size="<<m_classOneTwoForRecoveryByAlgoId.size()<<"u"<<endl;
orderd.cpp            TTLOG(ERROR,13)<<"CompleteBookieResponse failed: Delivering failure response to requestor: request_id="<<response->req_id<<" order_id="<<download_order_id<<" error="<<ORDERD_ERROR_STR[error]<<" error_msg="<<error_msg<<endl;
orderd.cpp    TTLOG(INFO,13)<<"DiscardRecoveredPROrders: Iterating through recovered child orders to discard PR orders (if any): parent_id="<<parent_order_id<<" num_children="<<response->num_children<<"u"<<endl;
orderd.cpp        TTLOG(INFO,13)<<"DiscardRecoveredPROrders: No child orders found: parent_id="<<parent_order_id<<" "<<endl;
orderd.cpp        TTLOG(ERROR,13)<<"DiscardRecoveredPROrders: Memory allocation failed for new_children_array: parent_id="<<parent_order_id<<" "<<endl;
orderd.cpp        TTLOG(INFO,13)<<"DiscardRecoveredPROrders: Discarding PR child order: pr_order_id="<<pr_order_id<<" parent_id="<<parent_order_id<<" user_id="<<child_status.params.user_id<<"lu order_status="<<TTSDK_OrderStatusToString(child_status.status_type)<<" should_cancel="<<should_cancel?"true":"false"<<endl;
orderd.cpp        TTLOG(INFO,13)<<"DiscardRecoveredPROrders: Sent cancels for PR child orders, tracking pending cleanup for possible retry: parent_id="<<parent_order_id<<endl;
orderd.cpp    TTLOG(INFO,13)<<"DiscardRecoveredPROrders: Finished iteration: parent_id="<<parent_order_id<<" new_num_children="<<response->num_children<<"u"<<endl;
orderd.cpp    TTLOG(INFO,13)<<"RecoverChildOrderReceived: Received Ledger Response: request_id="<<response.req_id<<" num_children="<<response.num_children<<"u result="<<response.result<<endl;
orderd.cpp            TTLOG(ERROR,13)<<"RecoverChildOrderReceived: Request not found: request_id="<<response.req_id<<endl;
orderd.cpp                TTLOG(ERROR,13)<<"InitPositionReserveOrderHandleFromSnapshot failed: request_id="<<response.req_id<<" error="<<ORDERD_ERROR_STR[error]<<endl;
orderd.cpp                TTLOG(ERROR,13)<<"InitOrderHandlesFromSnapshot failed: request_id="<<response.req_id<<" error="<<ORDERD_ERROR_STR[error]<<endl;
orderd.cpp    TTLOG(INFO,13)<<"Added SyntheticSender for topic="<<topic<<endl;
orderd.cpp            TTLOG(INFO,13)<<"Found SyntheticSender for topic="<<topic<<" key="<<found->first<<endl;
orderd.cpp        TTLOG(ERROR,13)<<"Failed to find SyntheticSender for topic="<<topic<<endl;
orderd.cpp            TTLOG(INFO,13)<<"Found SyntheticSender for exch_order_assoc="<<exch_order_assoc<<" key="<<found->first<<endl;
orderd.cpp        TTLOG(ERROR,13)<<"Failed to find SyntheticSender for exch_order_assoc="<<exch_order_assoc<<endl;
orderd.cpp    TTLOG(ERROR,13)<<"Can not find Synthetic sender for params_internal or exch_order_assoc"<<endl;
orderd_client.cpp            TTLOG(ERROR,13)<<" ---------------------------------------------\n ScheduleOrderDThreadEvent NullPtrException for OrderRequestInfo!\n --------------------------------------------- \n"<<endl;
orderd_client.cpp        TTLOG(DEBUG,13)<<"DeleteClientOrder Success key="<<key<<"u user_order_id="<<user_order_id<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"DeleteClientOrder NOT_FOUND key="<<key<<"u user_order_id="<<user_order_id<<endl;
orderd_client.cpp        TTLOG(INFO,13)<<"DeleteClientOrderDataFromAccountIdMap, account_id="<<iter.first<<"lu user_order_id="<<user_order_id<<endl;
orderd_client.cpp                TTLOG(INFO,13)<<"DeleteClientOrderDataFromAccountIdMap, account_id="<<iter.first<<"lu user_order_id="<<user_order_id<<" erased!!"<<endl;
orderd_client.cpp        TTLOG(DEBUG,13)<<"OrderD_DeliverResponse USER_REQ = 0"<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"ProcessNewOrder failed error="<<ORDERD_ERROR_STR[error]<<" "<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"ProcessNewOrder failed error="<<ORDERD_ERROR_STR[error]<<" "<<endl;
orderd_client.cpp            TTLOG(ERROR,13)<<" ProcessNewOrder failed client_ord_data->order_handle will be set to null. error="<<ORDERD_ERROR_STR[error]<<" "<<endl;
orderd_client.cpp        TTLOG(INFO,13)<<" INSERT client_ord_data cli_ord_data="<<(void*)client_ord_data.get()<<" cli_ord_data.use_count="<<client_ord_data.use_count()<<"u user_order_id="<<(void*)client_ord_data->user_order_id<<" (hash="<<UserOrderIDHashValue(client_ord_data->user_order_id)<<"u) order_handle="<<client_ord_data->order_handle.get()<<" ok="<<ok<<" inflight_state=[order_qty="<<inflight.order_state.params.order_qty<<".8f leaves_qty="<<inflight.order_state.params.wrk_qty<<".8f cum_qty="<<inflight.order_state.params.cum_qty<<".8f disp_qty="<<inflight.order_state.params.disp_qty<<".8f]"<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<" ProcessDownloadOrder[order_id="<<order_uuid_string<<"] failed due to [user_order_id="<<user_order_id<<"]["<<std::showbase << std::hex<<UserOrderIDHashValue(user_order_id)<<"16X "<<UserOrderIDHashValue(user_order_id)<<"u] already has a client_ord_data="<<client_ord_data.get()<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<" OrderD_DownloadOrder failed client_ord_data->order_handle will be set to null. error="<<ORDERD_ERROR_STR[error]<<" "<<endl;
orderd_client.cpp    TTLOG(INFO,13)<<" ProcessDownloadOrder: INSERT client_ord_data ok="<<ok<<" client_ord_data="<<reinterpret_cast<void*>(client_ord_data.get())<<" user_order_id(hash)="<<client_ord_data->user_order_id<<"("<<UserOrderIDHashValue(client_ord_data->user_order_id)<<"u) order_handle="<<reinterpret_cast<void*>(client_ord_data->order_handle.get())<<" "<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"ProcessDetachOrphan: failed to find client_ord_data for user_order_id="<<user_order_id<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"ProcessDetachOrphan: No order_handle for user_order_id="<<user_order_id<<endl;
orderd_client.cpp        TTLOG(WARNING,13)<<"ProcessDetachOrphan: Skip: vector_listening_clients.size="<<order_handle->vector_listening_clients.size()<<"u >1 order_handle="<<(void*)(order_handle.get())<<" order_id="<<order_id<<endl;
orderd_client.cpp        TTLOG(WARNING,13)<<"ProcessDetachOrphan: Skip: order_handle="<<(void*)(order_handle.get())<<" order_id="<<order_id<<" state_flags=["<<OrderStateFlagAsStr(order_handle->state_flags)<<"] wrk_qty="<<order_handle->current_state_data.params.wrk_qty<<".8f"<<endl;
orderd_client.cpp    TTLOG(INFO,13)<<"ProcessDetachOrphan: order_id="<<order_id<<" cleanup order_handle="<<(void*)(order_handle.get())<<" AND client_ord_data="<<user_order_id<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"ProcessDetachOrder["<<user_order_id<<"] failed to find order"<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"ProcessDetachOrder["<<user_order_id<<"] order_handle is null"<<endl;
orderd_client.cpp        TTLOG(WARNING,13)<<"PerformDetachOrder: client_ord_data not in vector_listening_clients for order_handle="<<order_handle.get()<<" order_id="<<order_handle->current_order_id()<<endl;
orderd_client.cpp        TTLOG(WARNING,13)<<"ProcessDetachOrder: Detaching "<<what<<" algo_id="<<ttuuid(algo_inst_id)<<" from order_handle="<<order_handle.get()<<" order_id="<<order_handle->current_order_id()<<" vector_listening_clients.size="<<vector_size<<"u keep order_handle alive"<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<" ProcessChangeOrder user_order_id="<<change_order->user_order_id<<" failed due to: can not find client_ord_data"<<endl;
orderd_client.cpp            TTLOG(INFO,13)<<" Request to delete an unknown in-flight order (Add/Download/Attach request is still pending) - the order request probably failed before creation of client_ord_data. Response no-op. [user_order_id="<<change_order->user_order_id<<"] "<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<" ProcessChangeOrder user_order_id="<<change_order->user_order_id<<" failed due to: order_handle is NULL "<<endl;
orderd_client.cpp             TTLOG(ERROR,13)<<" delete_inflight_order failed. order_handle="<<(void*)client_ord_data->order_handle.get()<<" user_order_id="<<client_ord_data->user_order_id<<" state_flags=["<<OrderStateFlagAsStr(client_ord_data->order_handle->state_flags)<<"] "<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<" ProcessChangeOrder user_order_id="<<change_order->user_order_id<<" failed due to: "<<fail_on_external_event_seen?"external_event_seen":""<<" "<<fail_on_external_delete_seen?"external_delete_seen":""<<" "<<fail_on_full_fill_seen?"full_fill_seen":""<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"ProcessChangeOrder user_order_id="<<change_order->user_order_id<<" failed due to risk reject seen"<<endl;
orderd_client.cpp        TTLOG(WARNING,13)<<" ProcessChangeOrder user_order_id="<<change_order->user_order_id<<" failed due to: error="<<ORDERD_ERROR_STR[error]<<" "<<endl;
orderd_client.cpp    TTLOG(INFO,13)<<"---------------------------------------------\n OrderDRegisterThreadSwitch\n --------------------------------------------- \n"<<endl;
orderd_client.cpp            TTLOG(INFO,13)<<"DestroyOrderData client_ord_data="<<(void*)client_ord_data.get()<<" "<<endl;
orderd_client.cpp                    TTLOG(INFO,13)<<"DestroyOrderData: Removing OMA Parent"<<endl;
orderd_client.cpp            TTLOG(INFO,13)<<"Removing references to parent algo. parent_id="<<parent_id<<endl;
orderd_client.cpp            TTLOG(INFO,13)<<"ProcessClientRequest failed due to max_order_rate limit "<<endl;
orderd_client.cpp            TTLOG(ERROR,13)<<" ProcessClientRequest failed: request="<<ORDERD_REQUEST_ID_STR[request->id]<<" user_request_id="<<request->user_request_id<<"lu user_order_id="<<user_order_id<<" error="<<ORDERD_ERROR_STR[error]<<" msg=["<<response.data.request_failure.msg<<"] status_flags="<<response.data.request_failure.status_flags<<" "<<endl;
orderd_client.cpp            TTLOG(ERROR,13)<<"ProcessRequestUnsolicitedOrder failed error="<<ORDERD_ERROR_STR[error]<<" "<<endl;
orderd_client.cpp        TTLOG(INFO,13)<<"ProcessRequestUnsolicitedOrder account_id="<<request->data.unsolicited_order.account_id<<"lu"<<endl;
orderd_client.cpp    TTLOG(INFO,13)<<"ProcessRequestCopyField ["<<algo_inst_ttuuid<<"] "<<class_1_2->ShortDebugString().to_std()<<" m_classOneTwoForRecoveryByAlgoId_size="<<m_classOneTwoForRecoveryByAlgoId.size()<<"u"<<endl;
orderd_client.cpp        TTLOG(INFO,13)<<"DownloadAndCleanupChildOrder: Tracking child cleanup. parent_id="<<cleanup_data.parent_id<<" pr_only="<<cleanup_data.pr_only<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"OrderD::EncodeAndSendChildrenDownloadRequest: Failed to encode LBM request: request_buffer_size="<<std::strlen(request_buffer)<<"u encoded_size="<<buf_size<<"u "<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"OrderD::EncodeAndSendChildrenDownloadRequest: Failed to send LBM request, algo_inst_id="<<ttalgo<<", ledger_request_tid="<<request->data.recover_order.ledger_request_tid<<"lu "<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"OrderD::DownloadAndRecoverChildOrder: Failed to allocate request copy."<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"OrderD::DownloadAndRecoverChildOrder: Failed to encode and send LBM request!"<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"OrderD::DownloadAndRecoverChildOrder: Request is unexpectedly missing TID!"<<endl;
orderd_client.cpp            TTLOG(WARNING,13)<<"OrderD::DownloadAndRecoverChildOrder: Download already in pending list: request_id="<<request_copy->data.recover_order.ledger_request_tid<<" old_request_time="<<(*iter)->data.recover_order.ledger_request_time<<"lu"<<endl;
orderd_client.cpp        TTLOG(INFO,13)<<"OrderD::DownloadAndRecoverChildOrder: Download added to pending list: request_id="<<request_copy->data.recover_order.ledger_request_tid<<" request_time="<<request_copy->data.recover_order.ledger_request_time<<"lu vector_size="<<m_pendingDownloadRequests.size()+1<<"u"<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"UpdateCurrentUserId["<<user_order_id<<"] failed to find order"<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"UpdateCurrentUserId["<<user_order_id<<"] order_handle is null"<<endl;
orderd_client.cpp    TTLOG(INFO,13)<<"UpdateCurrentUserId["<<user_order_id<<"]: "<<client_ord_data->order_handle->current_user_id<<"lu->"<<new_user_id<<"lu"<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"UpdateGroupIds["<<user_order_id<<"] failed to find order"<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"UpdateGroupIds["<<user_order_id<<"] order_handle is null"<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"UpdateGroupIds["<<user_order_id<<"] order_handle has no new_order_single"<<endl;
orderd_client.cpp    TTLOG(INFO,13)<<"UpdateGroupIds["<<user_order_id<<"]: order_id="<<order_id_ours<<" order_handle->current_state_data.params.type="<<order_handle->current_state_data.params.type<<" "<<GroupIDsToString(group_ids)<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"SendChildOrderPass: Failed to send UpdateOrder for order_id="<<order_id<<" (error="<<ORDERD_ERROR_STR[error]<<")"<<endl;
orderd_client.cpp    TTLOG(INFO,13)<<"SendChildOrderPass: Sent UpdateOrder for order_id="<<order_id<<" current_user_id="<<order_handle->current_user_id<<"lu "<<GroupIDsToString(order_handle->group_ids)<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"UpdateClass2Fields: failed to find ttsdk_order="<<ttsdk_order<<endl;
orderd_client.cpp        TTLOG(ERROR,13)<<"UpdateClass2Fields: ttsdk_order="<<ttsdk_order<<" has null order_handle"<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<"AddOrderHandle result="<<(emplaced)?"SUCCESS":"FAILURE"<<" ----- order_id="<<order_id<<" size="<<m_mapOrderHandle.size()<<"u"<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<"DeleteOrderHandle result="<<(erased==0)?"NOT_FOUND":"SUCCESS"<<" order_id="<<order_id<<" size="<<m_mapOrderHandle.size()<<"u"<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"MoveOrderHandle old_order_id="<<old_order_id<<" not exist"<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"orderd: Display quantity greater than order quantity disp_qty="<<disp_qty<<"8f > real_quantity="<<real_quantity<<"8f"<<endl;
orderd_orders.cpp                TTLOG(INFO,13)<<"Place ASE Order: not added to m_setWireHeaderParent"<<endl;
orderd_orders.cpp                TTLOG(INFO,13)<<"PlaceOrder: m_setWireHeaderParent.size="<<m_setWireHeaderParent.size()<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<" PlaceOrder: user_request_id="<<user_request_id<<" [parent_id="<<order_handle->current_parent_order_id()<<" order_id="<<uuid<<"] user_id="<<user_id<<"lu originating_user_id="<<request_params->originating_user_id<<"lu price="<<request_params->price<<".8f order_qty="<<request_params->order_qty<<".8f side="<<request_params->side<<" base_quantity="<<base_quantity<<".8f real_quantity(order_qty-base_quantity)="<<real_quantity<<".8f trg_price="<<isnan(request_params->trg_prc)?NAN:request_params->trg_prc<<"f disp_qty="<<disp_qty<<".8f user_order_id="<<user_order_id<<" price_deviation_data="<<ToString(price_deviation_data)<<" exch_order_assoc="<<order_handle->exch_assoc<<" account_id="<<request_params->account<<"lu broker_id="<<request_params->broker<<"lu best_market_price="<<request_params->best_market_price<<"f non_matching="<<request_params->non_matching<<" instr_id="<<request_params->instr_id<<"lu topic="<<order_handle_to_topic(order_handle)<<" "<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"CancelOrder: user_request_id="<<user_request_id<<" [parent_id="<<order_handle->current_parent_order_id()<<" order_id="<<order_handle->current_order_id()<<"] current_state=["<<order_handle->current_state_data<<"] base_quantity="<<order_handle->base_quantity<<".8f exch_order_assoc="<<order_handle->exch_assoc<<" "<<endl;
orderd_orders.cpp                TTLOG(INFO,13)<<"ChangeOrder Ignored: user_request_id="<<user_request_id<<" [parent_id="<<order_handle->current_parent_order_id()<<" order_id="<<order_handle->current_order_id()<<"] Because leaves_qty==0 and logical order is pinned to original exchange order, so no new order will be placed request_price="<<request_price<<".8f request_qty="<<request_quantity<<".8f state_flags=["<<OrderStateFlagAsStr(order_handle->state_flags)<<"] exch_assoc="<<order_handle->exch_assoc<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"CompleteQueuedChange: order_id="<<order_handle->current_order_id()<<" queued_request=["<<order_handle->queued_state.order_state<<"]"<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"CompleteInflightAction: Position limit violated!"<<endl;
orderd_orders.cpp        TTLOG(WARNING,13)<<"Received xfer_held_change. dropping it!!!!!!!!!!!!!!!!! Expect xfer_replace_cancel and xfer_replace_new soon order_id="<<order_handle->current_order_id()<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"OrderD::CompleteOrderChange: order_id="<<order_handle->current_order_id()<<" synth_type="<<synth_type<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"OrderD::CompleteOrderChange: order_id="<<order_handle->current_order_id()<<" synth_type not available"<<endl;
orderd_orders.cpp                    TTLOG(WARNING,13)<<"OrderD::CompleteOrderChange: Unable to obtain order_handler for order_id="<<order_id_string<<endl;
orderd_orders.cpp                            TTLOG(INFO,13)<<"OrderD::CompleteOrderChange: skipping order_id="<<order_id_string<<" parent_order_id="<<parent_id<<" status_flags="<<order_status->status_flags<<"8x"<<endl;
orderd_orders.cpp                            TTLOG(INFO,13)<<"OrderD::CompleteOrderChange: passing down order_id="<<order_id_string<<" parent_order_id="<<parent_id<<" status_flags="<<order_status->status_flags<<"8x"<<endl;
orderd_orders.cpp            TTLOG(WARNING,13)<<"OrderD::CompleteOrderChange: Unable to obtain synth_status for order_id="<<order_id_string<<endl;
orderd_orders.cpp            TTLOG(WARNING,13)<<"Received PR order without a valid connection_id, future orders placed in the risk bucket will route to Bouncer. connection_id="<<cid<<"lu pr_order_id="<<order_id<<" risk_bucket="<<(void*)(order_handle->risk_bucket.get())<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"Received PR order with a valid connection_id, future orders placed in the risk bucket will route to OC, attempting to switch to OC sender for existing orders. connection_id="<<cid<<"lu pr_order_id="<<order_id<<" risk_bucket="<<(void*)(order_handle->risk_bucket.get())<<endl;
orderd_orders.cpp                TTLOG(WARNING,13)<<"Failed to get sender from lbmResourceMgr, LBM senders for existing orders will not be updated."<<endl;
orderd_orders.cpp                    TTLOG(WARNING,13)<<"Failed to update senders in the risk bucket."<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"Received replace_full_filled, order_id="<<order_handle->current_order_id()<<" will ignore any mismatch of price/qty/trigger_price. will only check is_response_to_submit="<<is_response_to_submit<<" "<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"Can Not CompleteInflightAction: order_id="<<order_handle->current_order_id()<<" is_response_to_submit="<<is_response_to_submit<<" is_qty_match="<<is_qty_match<<" is_price_match="<<is_price_match<<" is_trigger_price_match="<<is_trigger_price_match<<" msg="<<ss.str()<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"CompleteOrderChange(unsolicited): Position limit violated!"<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"CompleteOrderCancel:[parent_id="<<order_handle->current_parent_order_id()<<" ord_id="<<order_handle->current_order_id()<<"] synth_status=failed change response->status_type="<<TTSDK_OrderStatusToString(response->data.order_status.status_type)<<" order_handle->state_flags="<<OrderStateFlagAsStr(order_handle->state_flags)<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"CompleteOrderCancel:[parent_id="<<order_handle->current_parent_order_id()<<" ord_id="<<order_handle->current_order_id()<<"] synth_status=expired"<<endl;
orderd_orders.cpp        TTLOG(WARNING,13)<<"CompleteOrderCancel:[parent_id="<<order_handle->current_parent_order_id()<<" ord_id="<<order_handle->current_order_id()<<"] xfer_replace_cancel. dropping it!!!!!!!!!!!!!!!!!"<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"CompleteOrderCancel(unsolicited): Position limit violated!"<<endl;
orderd_orders.cpp        TTLOG(WARNING,13)<<"HandleOrderReplaced Fail: same order_id="<<ttuuid(order_status->replaced_order_id)<<" "<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<"HandleOrderPendingNew:[parent_id="<<order_handle->current_parent_order_id()<<" ord_id="<<order_handle->current_order_id()<<"] response->status_type="<<TTSDK_OrderStatusToString(response->data.order_status.status_type)<<" Will Drop this ER"<<endl;
orderd_orders.cpp            TTLOG(WARNING,13)<<"HandleOrderPendingNew:[parent_id="<<order_handle->current_parent_order_id()<<" ord_id="<<order_handle->current_order_id()<<"]. Now order_id="<<ttuuid(order_status->replaced_order_id)<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"HandleOrderPendingNew:[parent_id="<<order_handle->current_parent_order_id()<<" ord_id="<<order_handle->current_order_id()<<"] Sth Wrong! Received pending_new without ttsdk_order_xfer_replace_new flag, but order has gone through orderd__xfer_replace_cancel"<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"HandleOrderRestate:[parent_id="<<order_handle->current_parent_order_id()<<" ord_id="<<order_handle->current_order_id()<<"] synth_status=failed change response->status_type="<<TTSDK_OrderStatusToString(response->data.order_status.status_type)<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"HandleOrderRestate:[parent_id="<<order_handle->current_parent_order_id()<<" ord_id="<<order_handle->current_order_id()<<"] change response->status_type="<<TTSDK_OrderStatusToString(response->data.order_status.status_type)<<endl;
orderd_orders.cpp        TTLOG(WARNING,13)<<"HandleOrderRestate:[parent_id="<<order_handle->current_parent_order_id()<<" ord_id="<<order_handle->current_order_id()<<"]: Child order resurrected unexpectedly!"<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"HandleOrderRestate:[parent_id="<<order_handle->current_parent_order_id()<<" ord_id="<<order_handle->current_order_id()<<"] "<<to_log<<"! change response->status_type="<<TTSDK_OrderStatusToString(order_status->status_type)<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"HandleOrderRestate:[parent_id="<<order_handle->current_parent_order_id()<<" ord_id="<<order_handle->current_order_id()<<"] "<<to_log<<"! but order is NOT in pending_new"<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"Changing unsolicited reject to restatement with synth_status set to 'Failed' order_id="<<order_handle->current_order_id()<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"Ignore external reject. order_id="<<order_handle->current_order_id()<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"Received reject for parent_id="<<parent_id<<" order_id="<<order_id<<" reject_detail=["<<reject_detail<<"] message=["<<message<<"] inflight_request=["<<order_handle->inflight_state.order_state<<"] reject_reason="<<REJECT_REASON_STR[reason]<<" state_flag=["<<OrderStateFlagAsStr(order_handle->state_flags)<<"] order_pass_state="<<OrderPassToString(order_pass_state)<<" order_update_reason="<<order_update_reason<<" - ignoring"<<endl;
orderd_orders.cpp    TTLOG(ERROR,13)<<"Received reject for parent_id="<<parent_id<<" order_id="<<order_id<<" reject_detail=["<<reject_detail<<"] message=["<<message<<"] inflight_request=["<<order_handle->inflight_state.order_state<<"] reject_reason="<<REJECT_REASON_STR[reason]<<" state_flag=["<<OrderStateFlagAsStr(order_handle->state_flags)<<"] order_pass_state="<<OrderPassToString(order_pass_state)<<" order_update_reason="<<order_update_reason<<" "<<endl;
orderd_orders.cpp                TTLOG(INFO,13)<<"CompleteOrderReject: parent_id="<<parent_id<<" order_id="<<order_id<<" RetryInflightRequest OK"<<endl;
orderd_orders.cpp                TTLOG(ERROR,13)<<"CompleteOrderReject: RetryInflightRequest Failed parent_id="<<parent_id<<" order_id="<<order_id<<" error="<<ORDERD_ERROR_STR[error]<<" "<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"CompleteOrderReject: No retry. parent_id="<<parent_id<<" order_id="<<order_id<<" inflight retry_count="<<order_handle->inflight_state.retry_count<<" "<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"CompleteOrderReject: Position limit violated!"<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"Risk reject received - queued change rejected as well. parent_id="<<parent_id<<" order_id="<<order_id<<" queued_request=["<<order_handle->queued_state.order_state<<"]"<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<"RetryInflightRequest. order_id="<<order_handle->current_order_id()<<" retry_count="<<retry_count<<" inflight_request=["<<order_handle->inflight_state.order_state<<"]"<<endl;
orderd_orders.cpp                TTLOG(INFO,13)<<"CompleteFill:[parent_id="<<order_handle->current_parent_order_id()<<" ord_id="<<order_handle->current_order_id()<<"] full_fill w xfer_fill last_fill_qty="<<last_fill_qty<<"8f current_wrk_qty="<<current_wrk_qty<<"8f"<<endl;
orderd_orders.cpp                TTLOG(INFO,13)<<"CompleteFill:[parent_id="<<order_handle->current_parent_order_id()<<" ord_id="<<order_handle->current_order_id()<<"] partial_fill w xfer_fill while order in pending_new last_fill_qty="<<last_fill_qty<<"8f current_wrk_qty="<<current_wrk_qty<<"8f"<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"CompleteFill:[parent_id="<<order_handle->current_parent_order_id()<<" ord_id="<<order_handle->current_order_id()<<"] xfer_fill But order NOT in pending_new"<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"CompleteFill: "<<fp_gt(last_fill_qty<<" order_id="<<current_wrk_qty)?"Possibleoverfilldetected":"Orderfullyfilled"<<" last_fill_qty="<<order_uuid_string<<"8f current_wrk_qty="<<last_fill_qty<<"8f qty_diff="<<current_wrk_qty<<"8f new_current_qty="<<qty_diff<<"8f"<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"CompleteFill: with orderd__pending_external fill="<<response->data.order_status.status_type==ttsdk_order_status_full_fill?"Full":"Partial"<<" order_id="<<order_handle->current_order_id()<<" "<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"CompleteOrderTimeout: Position limit violated!"<<endl;
orderd_orders.cpp                TTLOG(WARNING,13)<<"CompleteOrderTimeout: Reject queued change: user_request_id="<<user_request_id<<"lu order_handle="<<(void*)(order_handle.get())<<endl;
orderd_orders.cpp                TTLOG(ERROR,13)<<"CompleteOrderTimeout: Reject queued change but can NOT deliever: user_request_id="<<user_request_id<<"lu order_handle="<<(void*)(order_handle.get())<<endl;
orderd_orders.cpp            TTLOG(DEBUG,13)<<"No parent algo type, skipping. order_id="<<order_id<<endl;
orderd_orders.cpp            TTLOG(DEBUG,13)<<"SSE or ADL child, skipping. order_id="<<order_id<<endl;
orderd_orders.cpp            TTLOG(DEBUG,13)<<"Child order is in middle of download, skipping. order_id="<<order_id<<endl;
orderd_orders.cpp            TTLOG(DEBUG,13)<<"leave_on_cancel=true, skipping. order_id="<<order_id<<endl;
orderd_orders.cpp            TTLOG(DEBUG,13)<<"Order not working, skipping. order_id="<<order_id<<endl;
orderd_orders.cpp            TTLOG(DEBUG,13)<<"CancelAllChildren: Sending fire-and-forget PR cancel. order_id="<<order_id<<endl;
orderd_orders.cpp        TTLOG(DEBUG,13)<<"CancelAllChildren: Sending fire-and-forget cancel. order_id="<<order_id<<endl;
orderd_orders.cpp            TTLOG(WARNING,13)<<"CancelFireAndForget: Failed to encode cancel for order_id="<<order_id<<" parent_id="<<parent_id<<" error="<<ORDERD_ERROR_STR[error]<<endl;
orderd_orders.cpp        TTLOG(WARNING,13)<<"CancelFireAndForget: Failed to send cancel for order_id="<<order_id<<" parent_id="<<parent_id<<" order_type="<<TTSDK_OrderTypeToString(order_type)<<" error="<<ORDERD_ERROR_STR[error]<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"CancelFireAndForget: Successfuly send cancel for order_id="<<order_id<<" parent_id="<<parent_id<<" order_type="<<TTSDK_OrderTypeToString(order_type)<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"DeliverRecoveryResponse: Request is NULL, dropping response"<<endl;
orderd_orders.cpp         TTLOG(ERROR,13)<<error_msg.str()<<endl;
orderd_orders.cpp         TTLOG(ERROR,13)<<error_msg.str()<<endl;
orderd_orders.cpp         TTLOG(INFO,13)<<error_msg.str()<<endl;
orderd_orders.cpp             TTLOG(ERROR,13)<<error_msg.str()<<endl;
orderd_orders.cpp             TTLOG(ERROR,13)<<error_msg.str()<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"CompleteBookieResponse: Inserting downloaded orders Parent ID into Wire Header filter: has_parent="<<has_parent<<" parent_algo_id="<<parent_algo_id<<"lu parent_id="<<tt_parent_id<<" order_id="<<tt_order_id<<" m_setWireHeaderParent.size="<<m_setWireHeaderParent.size()<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"CompleteBookieResponse: has_parent="<<has_parent<<" parent_id="<<tt_parent_id<<" order_id="<<tt_order_id<<" but no algo_id"<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"CompleteBookieResponse: Downloaded order does not have a Parent ID to insert into Wire Header filter: has_parent="<<has_parent<<" parent_id="<<tt_parent_id<<" (invalid) order_id="<<tt_order_id<<" m_setWireHeaderParent.size="<<m_setWireHeaderParent.size()<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"CompleteBookieResponse: Downloaded order is an Algo Order, inserting its Order ID into Wire Header Filter: order_id="<<tt_order_id<<" m_setWireHeaderParent.size="<<m_setWireHeaderParent.size()<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"CompleteLedgerResponse: GetOrCreateRiskBucket failed!"<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"CompleteLedgerResponse: AddOrderHandleToRiskBucket failed!"<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"CompleteLedgerResponse: CheckPositionLimitOnReceive detected violation unexpectedly!"<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"CompleteLedgerResponse: Failed to create LBM Synthetic Sender for ASE or AGG order - not supported yet"<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"CompleteBookieResponse: Using Local Sender. algo order_id="<<tt_order_id<<" will go to myself="<<env::instance().get_instance_identifier()<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"CompleteBookieResponse: Using Synthetic Sender. algo order_id="<<tt_order_id<<" will go to syntheticSenderPtr="<<order_status->exch_assoc<<endl;
orderd_orders.cpp                TTLOG(INFO,13)<<"CompleteLedgerResponse: Using Channel Sender since PR has invalid connection ID. order_id="<<tt_order_id<<" bucket="<<(void*)(risk_bucket.get())<<" order_handle="<<(void*)(order_handle.get())<<endl;
orderd_orders.cpp                TTLOG(INFO,13)<<"CompleteLedgerResponse: Using Direct Sender since PR has valid connection ID. order_id="<<tt_order_id<<" bucket="<<(void*)(risk_bucket.get())<<" order_handle="<<(void*)(order_handle.get())<<" connection_id="<<cid<<"lu"<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"CompleteLedgerResponse: Using Channel Sender. order_id="<<tt_order_id<<" order_handle="<<(void*)(order_handle.get())<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"CompleteLedgerResponse: Failed to create LBM Sender or local sender!"<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"CompleteLedgerResponse: Missing oma parent id when trying to download native order!"<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"CompleteLedgerResponse: EncodeUpdateOrder failed: order_id="<<tt_order_id<<" oma_parent_order_id="<<oma_parent_uuid_string<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"CompleteLedgerResponse: Successfully EncodeUpdateOrder: order_id="<<tt_order_id<<" now should have oma_parent_order_id="<<oma_parent_uuid_string<<" "<<endl;
orderd_orders.cpp            TTLOG(WARNING,13)<<"CompleteBookieResponse: Failed to send UpdateOrder: order_id="<<tt_order_id<<" oma_parent_order_id="<<oma_parent_uuid_string<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"CompleteBookieResponse: Sent UpdateOrder: order_id="<<tt_order_id<<" set oma_parent_id="<<oma_parent_uuid_string<<" send to market_id="<<order_handle->current_state_data.params.mkt_id<<endl;
orderd_orders.cpp        TTLOG(DEBUG,13)<<"class_1_2 "<<class_1_2->ShortDebugString().to_std()<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"Drop Unsolicited order_id="<<order_id<<" status="<<TTSDK_OrderStatusToString(order_status->status_type)<<" status_flags="<<(int)(order_status->status_flags)<<" xfer_held_change="<<order_status->status_flags&ttsdk_order_xfer_held_change?"True":"False"<<" xfer_replace_cancel="<<order_status->status_flags&ttsdk_order_xfer_replace_cancel?"True":"False"<<" xfer_replace_new="<<order_status->status_flags&ttsdk_order_xfer_replace_new?"True":"False"<<" "<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"Delivered Unsolicited order_id="<<order_id<<" status="<<TTSDK_OrderStatusToString(ostatus->status_type)<<" status_flags="<<(int)(ostatus->status_flags)<<" to user_order_id="<<codter->user_order_id<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<" CompOrdRsp() <--------grand_parent_id="<<is_grand_child_order?tt::algoutil::ttuuid(parent_order_handle->current_state_data.params.parent_id).to_st<<", parent_id="<<parent_id<<", order_id="<<order_id<<" "<<(order_status->status_flags&ttsdk_external_order_event)?"(External)":""<<""<<(order_status->status_flags&ttsdk_suspended_order_event)?"(Suspended)":""<<" stauts_type="<<TTSDK_OrderStatusToString(order_status->status_type)<<" order_status=[price="<<order_status->params.price<<".8f order_qty="<<order_status->params.order_qty<<".8f wrk_qty="<<order_status->params.wrk_qty<<".8f trg_prc="<<trigger_price<<".8f disclosed_q="<<disclosed_qty<<".8f last_fill_qty="<<is_fill?order_status->params.last_fill_qty:-1<<".8f last_fill_prc="<<is_fill?order_status->params.last_fill_prc:-1<<".8f] trade_date="<<trade_date<<"lu type="<<TTSDK_OrderTypeToString(type)<<" "<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"Received expected external order event. cancel_submitted="<<cancel_submitted<<" inflight_qty="<<inflight_qty<<".8f inflight_price="<<inflight_price<<".8f"<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"Retry order returned. set retry_time_span(ms) "<<order_handle->retry_time_span<<"lu to 0"<<endl;
orderd_orders.cpp    TTLOG(DEBUG,13)<<"user_id="<<user_id<<"lu effective_user_id="<<effective_user_id<<"lu "<<class_1_2->ShortDebugString().to_std()<<endl;
orderd_orders.cpp        TTLOG(DEBUG,13)<<"Setting broker_id="<<m_accountToBrokerMap[account_id]<<"lu, not found in params!"<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"Unable to add order handle to risk bucket. error="<<ORDERD_ERROR_STR[error]<<endl;
orderd_orders.cpp                TTLOG(INFO,13)<<"PositionMgr: PR order has no connection id, routing to Bouncer bucket="<<(void*)(risk_bucket.get())<<" order_handle="<<(void*)(order_handle.get())<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<"downloading order: order_id="<<download_order_id<<" request_id="<<request_id<<" algo_type="<<downloading_algo_type<<"("<<TTSDK_ALGO_TYPE_STR[downloading_algo_type]<<") download_reason="<<TTSDK_OrderDownloadReasonToString(download_reason)<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"OrderD_DownloadOrder: download_parent_id="<<download_parent_id<<" trying to adopt order_id="<<download_order_id<<" and order_handle already exist - the existing order_handle has following info: parent_id="<<has_parent?tt::algoutil::ttuuid(parent_id).to_st<<" oma_parent_id="<<has_oma?tt::algoutil::ttuuid(oma_parent_id).to_st<<" "<<endl;
orderd_orders.cpp            TTLOG(WARNING,13)<<"OrderD_DownloadOrder: Child order_id="<<download_order_id<<" already has oma_parent_id"<<endl;
orderd_orders.cpp                TTLOG(ERROR,13)<<"OrderD_DownloadOrder: Trying to recover a child order but the child order has no parent_id"<<endl;
orderd_orders.cpp                TTLOG(ERROR,13)<<"OrderD_DownloadOrder: Trying to recover a child order but the child order belongs to another algo"<<endl;
orderd_orders.cpp                TTLOG(ERROR,13)<<"OrderD_DownloadOrder: Trying to recover a child order but the child order is already being downloaded"<<endl;
orderd_orders.cpp                TTLOG(ERROR,13)<<"Failed to Send UpdateOrder: error="<<ORDERD_ERROR_STR[error]<<" order_id="<<download_order_id<<" oma_parent_id="<<download_parent_id<<" "<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"Adopting algo from different user. order_handle.current_user_id="<<order_handle->current_user_id<<"lu->"<<user_id<<"lu"<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"OrderD_DownloadOrder: failed to alloc order_handle"<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"m_lbmLedgerSender->SendRequest() !! Error !! download_order_id="<<download_order_id<<" request_id="<<request_id<<", req_buffer_size="<<buf_size<<", reqPtr=nullptr."<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<"attaching order: order_id="<<order_id<<" parent_order_id="<<parent_order_id<<endl;
orderd_orders.cpp                        TTLOG(INFO,13)<<"failed to create lbm channel sender for order[order_id="<<order_id<<"] market_id="<<current_params->mkt_id<<endl;
orderd_orders.cpp                    TTLOG(INFO,13)<<" Populating newly created order_handle with cached order_status. while attaching order["<<order_id<<"] order_handle->order_id="<<child_id<<" order_handle->parent_id="<<daddy_id<<" order_handle->base_quantity="<<order_handle->base_quantity<<".8f order_handle->current_state_data.params.working_qty="<<order_handle->current_state_data.params.wrk_qty<<".8f order_handle->current_state_data.params.price="<<order_handle->current_state_data.params.price<<".8f order_handle->current_state_data.params.order_qty="<<order_handle->current_state_data.params.order_qty<<".8f "<<endl;
orderd_orders.cpp                TTLOG(INFO,13)<<"attaching order for: order_id="<<order_id<<" order_status="<<TTSDK_OrderStatusToString(cached->order_status.status_type)<<" Now deliver response to the attaching request"<<endl;
orderd_orders.cpp                TTLOG(INFO,13)<<"attaching order for order_id="<<order_id<<" succeeded"<<endl;
orderd_orders.cpp                TTLOG(ERROR,13)<<"attaching order failed for: order_id="<<order_id<<" can not find cached child order status from parent order_handle: parent_order_id="<<parent_order_id<<" "<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"attaching order failed for: order_id="<<order_id<<" can not find parent order_handle for: parent_order_id="<<parent_order_id<<" "<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"attaching order[order_id="<<order_id<<"] has no parent id !"<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"OrderD_DetachOrder: order_handle is null. Skip."<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<" Detaching Order order_id="<<order_uuid_string<<" parent_order_id="<<parent_uuid_string<<" oma_parent_id="<<oma_parent_uuid_string<<" state_flags=["<<OrderStateFlagAsStr(order_handle->state_flags)<<"]"<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"Side cannot be changed change_params->side ="<<change_params->side<<" order_handle->current_state_data.params.side="<<order_handle->current_state_data.params.side<<" "<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"Account cannot be changed change_params->account ="<<change_params->account<<"lu order_handle->current_state_data.params.account="<<order_handle->current_state_data.params.account<<"lu "<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"Type cannot be changed from "<<TTSDK_OrderTypeToString((enumttsdk_order_type)order_handle->current_state_data.params.type)<<" to "<<TTSDK_OrderTypeToString((enumttsdk_order_type)change_params->type)<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"TIF cannot be changed change_params->tif ="<<change_params->tif<<" order_handle->current_state_data.params.tif="<<order_handle->current_state_data.params.tif<<" "<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"Cancelling TT_Retry order_id="<<tt::algoutil::ttuuid(order_handle->current_state_data.params.ord_id)<<" Expecting 2 rejects: 1 for rejecting the original add, 1 (external reject) for rejecting this cancel request"<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"Change request queued with following params: queued_req_type="<<OrderD_ChangeReqTypeToString(order_handle->queued_state.change_req_type)<<" user_request_id="<<user_request_id<<" [parent_id="<<tt::algoutil::ttuuid(order_handle->queued_state.order_state.params.parent_id)<<" order_id="<<tt::algoutil::ttuuid(order_handle->queued_state.order_state.params.ord_id)<<"] user_id="<<user_id<<"lu price="<<order_handle->queued_state.order_state.params.price<<".8f order_qty="<<order_handle->queued_state.order_state.params.order_qty<<".8f side="<<order_handle->queued_state.order_state.params.side<<" trg_price="<<order_handle->queued_state.order_state.params.trg_prc<<"f disp_qty="<<order_handle->queued_state.order_state.params.disp_qty<<".8f user_order_id="<<client_ord_data->user_order_id<<" exch_order_assoc="<<order_handle->exch_assoc<<" account_id="<<order_handle->queued_state.order_state.params.account<<"lu broker_id="<<order_handle->queued_state.order_state.params.broker<<"lu best_market_price="<<order_handle->queued_state.order_state.params.best_market_price<<"f non_matching="<<order_handle->queued_state.order_state.params.non_matching<<" "<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"OrderD::RetryDownloadChildrenRequest: Failed to encode LBM request: request_buffer_size="<<std::strlen(lbm_send_data.request_buffer)<<"u encoded_size="<<lbm_send_data.request_buffer_size<<"u "<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<"OrderD::RetryDownloadChildrenRequest: Queued lbm_send_data: algo_inst_id="<<ttalgo<<" req_id="<<lbm_send_data.request_id<<" req_buffer_size="<<lbm_send_data.request_buffer_size<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<"OrderD::ProcessLbmSendQueueForChildrenDownload: Starting... queueSize="<<m_pendingLbmSendsForChildrenDownload.size()<<"u batchSize="<<batchSize<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"OrderD::ProcessLbmSendQueueForChildrenDownload: Request object is invalid, request_id="<<current->request_id<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"OrderD::ProcessLbmSendQueueForChildrenDownload: Failed to send LBM request, request_id="<<current->request_id<<endl;
orderd_orders.cpp        TTLOG(DEBUG,13)<<"OrderD::ProcessLbmSendQueueForChildrenDownload: Sent LBM request: request_id="<<current->request_id<<" count="<<count<<" "<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<"OrderD::ProcessLbmSendQueueForChildrenDownload: Finished... queue_size="<<m_pendingLbmSendsForChildrenDownload.size()<<"u"<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"OrderD::RetryDownloadOrderRequest: Failed to get Order ID: previous_tid="<<order_handle->request_tid<<" (TID that timed out)"<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"OrderD::RetryDownloadOrderRequest: Failed to encode LBM request: request_buffer_size="<<std::strlen(lbm_send_data.request_buffer)<<"u encoded_size="<<lbm_send_data.request_buffer_size<<"u "<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<"OrderD::RetryDownloadOrderRequest: Queued lbm_send_data: order_id="<<tt_order_id<<" previous_tid="<<order_handle->request_tid<<" (TID that timed out) current_tid="<<lbm_send_data.request_id<<" (TID queued for later send) req_buffer_size="<<lbm_send_data.request_buffer_size<<" "<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<"OrderD::ProcessLbmSendQueueForOrderDownload: Starting... queueSize="<<m_pendingLbmSendsForOrderDownload.size()<<"u batchSize="<<batchSize<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"OrderD::ProcessLbmSendQueueForOrderDownload: Order handle disposed, request_id="<<current->request_id<<endl;
orderd_orders.cpp            TTLOG(ERROR,13)<<"OrderD::ProcessLbmSendQueueForOrderDownload: Failed to send LBM request, request_id="<<current->request_id<<endl;
orderd_orders.cpp        TTLOG(DEBUG,13)<<"OrderD::ProcessLbmSendQueueForOrderDownload: Sent LBM request: request_id="<<current->request_id<<" count="<<count<<" "<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<"OrderD::ProcessLbmSendQueueForOrderDownload: Finished... queue_size="<<m_pendingLbmSendsForOrderDownload.size()<<"u"<<endl;
orderd_orders.cpp        TTLOG(WARNING,13)<<"OrderD::CheckForInflightTimeouts: Order handle timed out on a request: order_handle="<<timedOutOrderHandle.get()<<", request_time="<<timedOutOrderHandle->request_time<<"lu, timeout_threshold="<<timeout_threshold<<"lu retry_time_span="<<timedOutOrderHandle->retry_time_span<<"lu(ms) order_id="<<orderId<<" user_request_id="<<pending_order_state->user_request_id<<"lu state_flags=["<<OrderStateFlagAsStr(timedOutOrderHandle->state_flags)<<"] "<<timedOutOrderHandle->state_flags<<endl;
orderd_orders.cpp            TTLOG(WARNING,13)<<"OrderD::CheckForInflightTimeouts: Retrying download request for order_id="<<orderId<<endl;
orderd_orders.cpp            TTLOG(WARNING,13)<<"OrderD::CheckForInflightTimeoutsOrderD: Retry download failed for order_id="<<orderId<<" - will CompleteOrderTimeout"<<endl;
orderd_orders.cpp        TTLOG(WARNING,13)<<"OrderD::CheckForInflightTimeouts: CompleteOrderTimeout for order_id="<<orderId<<endl;
orderd_orders.cpp                                                       TTLOG(ERROR,13)<<"OrderD::CheckForInflightTimeouts: Download request timed out, retrying: request_id="<<req->data.recover_order.ledger_request_tid<<endl;
orderd_orders.cpp        TTLOG(INFO,13)<<"SendChildOrderCleanupRequest: Request sent. request_id="<<data.req_id<<" algo_inst_id="<<data.parent_id<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"SendChildOrderCleanupRequest: Request failed algo_inst_id="<<data.parent_id<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"OrderD_RemoveOMAParent; Failed to Send UpdateOrder:error="<<ORDERD_ERROR_STR[error]<<" "<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<" OrderD::HandleUserUpdate: user_id="<<user->user_id<<"lu user->account_count="<<user->account_count<<"lu"<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<" OrderD::HandleUserUpdate: user_id="<<user->user_id<<"lu Finished"<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"LbmResourceMgr::SenderPtr->Send() !! Error !!"<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"LbmResourceMgr::ChannelSenderPtr->Send() !! Error !!"<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"Unable to send. Both channelSender and syntheticSenderPtr are null"<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<" UpdatePositionLimit: Attempting to update limit for risk bucket: market_id="<<inner_request->market_id<<"u parent_id="<<parent_id_str<<" instr_id="<<inner_request->instr_id<<"lu account_id="<<inner_request->account_id<<"lu requested_limit_side="<<inner_request->is_long_limit?std::string("long"):std::string("short")<<" requested_limit="<<inner_request->limit<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"UpdatePositionLimit: Failed to update limit - risk bucket could not be located: error="<<ORDERD_ERROR_STR[error]<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"UpdatePositionLimit: Irrelevant for synthetic orders (ASE, AGG, ALGO) - returning success."<<endl;
orderd_orders.cpp            TTLOG(INFO,13)<<"UpdatePositionLimit: Failed to update limit - requested limit is lower than worst case: side="<<side<<" requested_limit="<<inner_request->limit<<" risk_bucket_worst_case="<<risk_bucket->worst_case_position<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<"UpdatePositionLimit: Successfully updated limit!"<<endl;
orderd_orders.cpp        TTLOG(ERROR,13)<<"OrderD_DeliverPositionLimitUpdate: original_request ptr was unexpectedly a nullptr. the requestor will NOT get a response of any sort."<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<" SendNewOrderToEpiqService order_id="<<epiq_order_data.order_id<<", instr_id="<<epiq_order_data.instr_id<<"lu, account_id="<<epiq_order_data.account_id<<"lu"<<endl;
orderd_orders.cpp    TTLOG(INFO,13)<<" SendDeleteOrderToEpiqService order_id="<<del_order.order_id<<endl;
protocol.cpp        TTLOG(INFO,13)<<"Encode for LOOPBACK msg="<<request.ShortDebugString().to_std()<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"lbm::Source Send failed"<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"lbm::ChannelSource Send failed"<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"Unable to send. Both sender and channel_sender are null"<<endl;
protocol.cpp        TTLOG(INFO,13)<<"PositionReserveUpdate="<<msg.ShortDebugString().to_std()<<endl;
protocol.cpp        TTLOG(INFO,13)<<"Invalid PR Message. exec_type="<<ExecType_Name(msg.exec_type()).c_str()<<endl;
protocol.cpp        TTLOG(DEBUG,13)<<"ExecutionReport: "<<order_id_str<<" "<<execution_report->ShortDebugString().to_std()<<endl;
protocol.cpp            TTLOG(WARNING,13)<<" DecodeOrderUpdate: Unknown order_type="<<execution_report->ord_type()<<" order_id="<<order_uuid_string<<" Order will default to limit"<<endl;
protocol.cpp            TTLOG(WARNING,13)<<" DecodeOrderUpdate: Unknown time_in_force="<<execution_report->time_in_force()<<" order_id="<<order_uuid_string<<" "<<endl;
protocol.cpp            TTLOG(DEBUG,13)<<"ExecutionReport "<<order_id_str<<" fills_grp_size="<<fills_grp.fills_grp_size<<"u serialized_size="<<fills_grp.struct_size<<"u"<<endl;
protocol.cpp            TTLOG(ERROR,13)<<"ExecutionReport "<<order_id_str<<" fills_grp_size="<<execution_report->fills_grp_size()<<"u serialized_size="<<fills_grp.struct_size<<"u serialization failed"<<endl;
protocol.cpp        TTLOG(DEBUG,13)<<"Setting trade_date="<<trade_date<<"lu"<<endl;
protocol.cpp                TTLOG(INFO,13)<<"STAGED: orderd: From OC::ExecReport SET_StagedAccountId="<<(int)party.party_tt_id()<<endl;
protocol.cpp            TTLOG(INFO,13)<<""<<ss.str()<<endl;
protocol.cpp                TTLOG(INFO,13)<<"ER=Restate: found xfer_released_order"<<endl;
protocol.cpp                TTLOG(INFO,13)<<"ER=Restate: found xfer_reduced_order"<<endl;
protocol.cpp                TTLOG(WARNING,13)<<"ER=Restate: unhandled AOTC action_type= "<<CrossingOrderPreventionActionType_Name(execution_report->crossing_order_prevention_action_type()).c_str()<<". "<<endl;
protocol.cpp                TTLOG(INFO,13)<<"ER=Replace: found xfer_held_change"<<endl;
protocol.cpp                TTLOG(INFO,13)<<"ER=Replace: Unhandled AOTC action_type= "<<CrossingOrderPreventionActionType_Name(execution_report->crossing_order_prevention_action_type()).c_str()<<". "<<endl;
protocol.cpp                TTLOG(INFO,13)<<"ER=Cancel: found xfer_replace_cancel"<<endl;
protocol.cpp                TTLOG(INFO,13)<<"ER=Cancel: Unhandled AOTC action_type= "<<CrossingOrderPreventionActionType_Name(execution_report->crossing_order_prevention_action_type()).c_str()<<". "<<endl;
protocol.cpp                    TTLOG(INFO,13)<<"ER=Trade: found xfer_fill"<<endl;
protocol.cpp                    TTLOG(INFO,13)<<"ER=Trade: unhandled AOTC action_type= "<<CrossingOrderPreventionActionType_Name(execution_report->crossing_order_prevention_action_type()).c_str()<<". "<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"STAGED protocol: SET_staged_order_id="<<staged_order_uuid_string<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"UpdateOrderHandleClassTwo: incoming fields is null. order_handle="<<order_handle.get()<<endl;
protocol.cpp    TTLOG(INFO,13)<<"UpdateOrderHandleClassTwo to New/Change/Cancel: order_handle="<<order_handle.get()<<" class_2=["<<class_2->ShortDebugString().to_std()<<"]"<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"SetClassTwoFields: incoming fields is null. order_handle="<<order_handle.get()<<endl;
protocol.cpp    TTLOG(INFO,13)<<"SetClassTwoFields to Change/Cancel: order_handle="<<order_handle.get()<<" class_2=["<<class_1_2->class_2().ShortDebugString().to_std()<<"]"<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"SetASEOrderInfo: incoming fields is null. order_handle="<<order_handle.get()<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"SetASEOrderInfo instrument_block_guid="<<instrument_block_guid<<", no autotool_order_infos available"<<endl;
protocol.cpp        TTLOG(INFO,13)<<"SetASEOrderInfo instrument_block_guid="<<instrument_block_guid<<" size="<<size<<" use first="<<autotool_order_info.ShortDebugString().to_std()<<endl;
protocol.cpp                TTLOG(INFO,13)<<"SetASEOrderInfo instrument_block_guid="<<instrument_block_guid<<" size="<<size<<" found match index="<<index<<", a="<<autotool_order_info.ShortDebugString().to_std()<<endl;
protocol.cpp            TTLOG(ERROR,13)<<"SetASEOrderInfo instrument_block_guid="<<instrument_block_guid<<" found no match. class_1="<<class_1_2->class_1().ShortDebugString().to_std()<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"SetClassOneTwoFields: incoming fields is null. order_handle="<<order_handle.get()<<endl;
protocol.cpp    TTLOG(INFO,13)<<"SetClassOneTwoFields to NOS: order_handle="<<order_handle.get()<<" class_1_2=["<<class_1_2->ShortDebugString().to_std()<<"]"<<endl;
protocol.cpp        TTLOG(DEBUG,13)<<"PrePopulateProtoBufObjects; Organization="<<organization<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"STAGED protocol: SET_staged_account_type="<<stagedAccountType<<endl;
protocol.cpp            TTLOG(ERROR,13)<<"PrePopulateProtoBufObjects: algo_type is UNKNOWN, so algo_type will NOT be set!"<<endl;
protocol.cpp        TTLOG(DEBUG,13)<<"PrePopulateProtoBufObjects: Setting current_group_id="<<current_group_id<<"lu on order_handle="<<static_cast<void*>(order_handle.get())<<endl;
protocol.cpp        TTLOG(DEBUG,13)<<"PrePopulateProtoBufObjects: Setting original_group_id="<<original_group_id<<"lu on order_handle="<<static_cast<void*>(order_handle.get())<<endl;
protocol.cpp        TTLOG(INFO,13)<<"PrePopulate (1): ["<<parent_order_id_str<<"] state_flags="<<order_handle->state_flags<<" new_order_single="<<order_handle->new_order_single->ShortDebugString().to_std()<<endl;
protocol.cpp        TTLOG(INFO,13)<<"PrePopulate (1): ["<<parent_order_id_str<<"] change_request="<<order_handle->change_request->ShortDebugString().to_std()<<endl;
protocol.cpp        TTLOG(INFO,13)<<"PrePopulate (1): ["<<parent_order_id_str<<"] cancel_request="<<order_handle->cancel_request->ShortDebugString().to_std()<<endl;
protocol.cpp        TTLOG(INFO,13)<<"PrePopulate (2): ["<<parent_order_id_str<<"] new_order_single="<<order_handle->new_order_single->ShortDebugString().to_std()<<endl;
protocol.cpp        TTLOG(INFO,13)<<"PrePopulate (2): ["<<parent_order_id_str<<"] change_request="<<order_handle->change_request->ShortDebugString().to_std()<<endl;
protocol.cpp        TTLOG(INFO,13)<<"PrePopulate (2): ["<<parent_order_id_str<<"] cancel_request="<<order_handle->cancel_request->ShortDebugString().to_std()<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"CheckSenderLocationId: order_id="<<order_handle->current_order_id()<<" message="<<typeid(T).name()<<" is missing sender_location_id. set default="<<locationId<<endl;
protocol.cpp                TTLOG(INFO,13)<<"OrderCancelReject=["<<tt_order_id<<"] "<<cancel_reject.ShortDebugString().to_std()<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"Received BookieResponse without request_id"<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"BookieResponse has an error: what="<<msg.parent_order().error().to_std()<<endl;
protocol.cpp    TTLOG(INFO,13)<<"BookieResponse: "<<msg.ShortDebugString().to_std()<<endl;
protocol.cpp        TTLOG(INFO,13)<<"No child orders found while decoding BookieResponse"<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"Memory allocation failed decoding BookieResponse"<<endl;
protocol.cpp            TTLOG(INFO,13)<<"ParentOrderDownloadResponse drop leg fill for "<<error<<endl;
protocol.cpp            TTLOG(WARNING,13)<<"ParentOrderDownloadResponse ER parsing failed. error="<<ORDERD_ERROR_STR[error_code]<<" message="<<error<<endl;
protocol.cpp        TTLOG(INFO,13)<<"ParentOrderDownloadResponse decoded child. order_id="<<order_id<<" ord_status="<<TTSDK_OrderStatusToString(status.status_type)<<" exec_type="<<ExecType_Name(er.exec_type()).c_str()<<endl;
protocol.cpp            TTLOG(ERROR,13)<<"ParentOrderDownloadResponse PR parsing failed."<<endl;
protocol.cpp        TTLOG(INFO,13)<<"ParentOrderDownloadResponse decoded PR. order_id="<<order_id<<" ord_status="<<TTSDK_OrderStatusToString(status.status_type)<<" exec_type="<<ExecType_Name(pr.exec_type()).c_str()<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"receive response from Ledger without request_id"<<endl;
protocol.cpp        TTLOG(ERROR,13)<<" Ledger does not return a valid OrderDownloadResponse for order download request[request_id="<<response.request_id().to_std()<<"]"<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"receive response from Ledger with error="<<response.orders().error().to_std()<<endl;
protocol.cpp        TTLOG(ERROR,13)<<" Ledger return "<<response.orders().orders_size()<<" order(s) for order download request[request_id="<<response.request_id().to_std()<<"]"<<endl;
protocol.cpp    TTLOG(INFO,13)<<"BookieResponse: "<<response.ShortDebugString().to_std()<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"OrderD_DecodeBookieMessage has error="<<ORDERD_ERROR_STR[error_code]<<", message="<<error<<endl;
protocol.cpp        TTLOG(ERROR,13)<<"EncodeAndSendNewOrder cannot submit PR orders"<<endl;
protocol.cpp            TTLOG(ERROR,13)<<"Trying to encode non-null terminated string. value="<<account_overrid<<endl;
protocol.cpp            TTLOG(INFO,13)<<"accountoverride="<<new_request->account_override().c_str()<<endl;
protocol.cpp        TTLOG(DEBUG,13)<<"EncodeAndSendNewOrder: Setting exec_inst to: "<<TTSDK_ExecInstToString(exec_inst)<<endl;
protocol.cpp        TTLOG(DEBUG,13)<<"EncodeAndSendNewOrder: Clearing exec_inst"<<endl;
protocol.cpp    TTLOG(INFO,13)<<"EncodeAndSendNewOrder: "<<new_request->ShortDebugString().to_std()<<endl;
protocol.cpp        TTLOG(WARNING,13)<<"OrderD_EncodeUpdateOrder could not get connection_id - given order_handle is likely an algo order"<<endl;
protocol.cpp            TTLOG(ERROR,13)<<"OrderD_EncodeUpdateOrder set_oma_parent_id failed. No oma_parent_id"<<endl;
protocol.cpp    TTLOG(INFO,13)<<"["<<order_id_str<<"] OrderUpdate: "<<message.ShortDebugString().to_std()<<endl;
protocol.cpp            TTLOG(ERROR,13)<<"AccountOverrider:Trying to encode non-null terminated string. value="<<account_overrid<<endl;
protocol.cpp            TTLOG(DEBUG,13)<<"AccountOverride="<<change_request->account_override().c_str()<<endl;
protocol.cpp        TTLOG(DEBUG,13)<<"AccountOverride not SET"<<endl;
protocol.cpp        TTLOG(DEBUG,13)<<"EncodeAndSendChangeOrder: Setting exec_inst to: "<<TTSDK_ExecInstToString(exec_inst)<<endl;
protocol.cpp        TTLOG(DEBUG,13)<<"EncodeAndSendChangeOrder: Clearing exec_inst"<<endl;
protocol.cpp        TTLOG(INFO,13)<<"EncodeAndSendChangeOrder: ["<<order_id<<"] "<<change_request->ShortDebugString().to_std()<<endl;
protocol.cpp        TTLOG(INFO,13)<<""<<msg.ShortDebugString().to_std()<<" params->user_id="<<params->user_id<<"lu params->originating_user_id="<<params->originating_user_id<<"lu"<<endl;
protocol.cpp        TTLOG(INFO,13)<<""<<msg.ShortDebugString().to_std()<<" params->user_id="<<params->user_id<<"lu params->originating_user_id="<<params->originating_user_id<<"lu"<<endl;
protocol.cpp        TTLOG(INFO,13)<<"PositionReserveCancelOrder="<<msg.ShortDebugString().to_std()<<" params->user_id="<<params->user_id<<"lu params->originating_user_id="<<params->originating_user_id<<"lu"<<endl;
protocol.cpp        TTLOG(INFO,13)<<"EncodeAndSendCancelOrder: "<<toPrint.to_std()<<endl;
protocol.cpp        TTLOG(INFO,13)<<"EncodeAndSendChangeOrder: ["<<order_id<<"] "<<message.ShortDebugString().to_std()<<endl;
protocol.cpp    TTLOG(INFO,13)<<"OrderD_EncodeTTUSAccountDownloadRequest request_id="<<request_id_string<<endl;
protocol.cpp    TTLOG(INFO,13)<<"OrderD_EncodeTTUSUserDownloadRequest request_id="<<request_id_string<<" user_id="<<user_id<<endl;
protocol.cpp    TTLOG(INFO,13)<<"OrderD_EncodeTTUSConnectionDownloadRequest request_id="<<request_id_string<<endl;
protocol.cpp    TTLOG(INFO,13)<<" OrderD_EncodeOrderDownloadRequest ledger_request_id="<<request_id<<" for order_id="<<order_uuid_string<<endl;
protocol.cpp        TTLOG(INFO,13)<<"BookieRequest: "<<toPrint.to_std()<<endl;
protocol.cpp    TTLOG(INFO,13)<<" OrderD_ReportStatistics \n m_wasted_decoded_order="<<m_wasted_decoded_order<<"lu, \n s_wire_head_no_filter_id="<<s_wire_head_no_filter_id<<"lu, \n s_wire_head_match_orderd_hash="<<s_wire_head_match_orderd_hash<<"lu, \n s_wire_head_match_parent_order_id="<<s_wire_head_match_parent_order_id<<"lu, \n s_dropped_wire_msg="<<s_dropped_wire_msg<<"lu, \n new_count ="<<s_new_count<<"lu, \n new_proto ="<<s_new_count==0?0L:s_new_proto/s_new_count<<"lu, \n new_wire_lbm ="<<s_new_count==0?0L:s_new_encode_wire_send/s_new_count<<"lu, \n new_lbm ="<<s_new_count==0?0L:s_new_lbm_send/s_new_count<<"lu, \n change_count ="<<s_change_count<<"lu, \n change_proto ="<<s_change_count==0?0L:s_change_proto/s_change_count<<"lu, \n change_wire_lbm="<<s_change_count==0?0L:s_change_encode_wire_send/s_change_count<<"lu, \n change_lbm ="<<s_change_count==0?0L:s_change_lbm_send/s_change_count<<"lu, \n spq_count ="<<s_spq_count<<"lu, \n spq_proto ="<<s_spq_count==0?0L:s_spq_proto/s_spq_count<<"lu, \n spq_wire_lbm ="<<s_spq_count==0?0L:s_spq_encode_wire_send/s_spq_count<<"lu, \n spq_lbm ="<<s_spq_count==0?0L:s_spq_lbm_send/s_spq_count<<"lu, \n"<<endl;
instrument_cache.cpp        TTLOG(ERROR,13)<<"PDS JSON msg is invalid: size="<<size<<" "<<pay_load<<" "<<endl;
instrument_cache.cpp            TTLOG(INFO,13)<<"ParsePDSUpdate() datap="<<datap<<endl;
instrument_cache.cpp    TTLOG(INFO,13)<<"PDS JSON msg: size="<<size<<" et="<<et<<", dt="<<dt<<", market="<<market<<" id="<<id<<" compliance="<<compliance<<" "<<endl;
instrument_cache.cpp        TTLOG(ERROR,13)<<"PDS JSON msg missing eventType or dataType or instrument_id"<<endl;
instrument_cache.cpp    TTLOG(INFO,13)<<"InstrumentCache pds_notification_lbm_affinity="<<pds_notification_lbm_affinity<<endl;
instrument_cache.cpp        TTLOG(ERROR,13)<<"SubscribePDSNotification: InstrumentCache has not been started yet. Subscribe to instrument_id="<<instrument_id<<"lu ignored"<<endl;
instrument_cache.cpp            TTLOG(INFO,13)<<"SubscribePDSNotification: Subscribe to ASE/AGG instrument notification: topic="<<pds_topic_name<<" for instrument_id="<<instrument_id<<"lu market_id="<<market_id<<" user_id="<<user_id<<"lu"<<endl;
instrument_cache.cpp            TTLOG(WARNING,13)<<"SubscribePDSNotification: PDS Sub already exists for ASE/AGG instrument notification: instrument_id="<<instrument_id<<"lu market_id="<<market_id<<" user_id="<<user_id<<"lu"<<endl;
instrument_cache.cpp        TTLOG(INFO,13)<<"SubscribePDSNotification: Subscribe to topic="<<pds_topic_name<<" for instrument_id="<<instrument_id<<"lu market_id="<<market_id<<" product_id="<<product_id<<"lu user_id="<<user_id<<"lu"<<endl;
instrument_cache.cpp        TTLOG(WARNING,13)<<"SubscribePDSNotification: PDS Sub already exists for instrument_id="<<instrument_id<<"lu market_id="<<market_id<<" product_id="<<product_id<<"lu user_id="<<user_id<<"lu"<<endl;
instrument_cache.cpp        TTLOG(ERROR,13)<<"PDSNotificationRecvd: failed to parse ["<<data<<"]"<<endl;
instrument_cache.cpp    TTLOG(INFO,13)<<"PDSNotificationRecvd: market_id="<<market_id<<"u instrument_id="<<instrument_id<<"lu compliance_id="<<compliance_id<<"lu is_delete="<<is_delete<<" is_update="<<is_update<<" tick_size="<<tick_size<<".6f"<<endl;
instrument_cache.cpp        TTLOG(DEBUG,13)<<"Beginning of transport session. Topic="<<message.TopicName()<<" lbm_source="<<message.Source()<<endl;
instrument_cache.cpp        TTLOG(DEBUG,13)<<"End of transport session. Topic="<<message.TopicName()<<" lbm_source="<<message.Source()<<endl;
instrument_cache.cpp    TTLOG(INFO,13)<<"InstrumentCache Stopping"<<endl;
instrument_cache.cpp        TTLOG(INFO,13)<<"FindNative "<<found->second->name<<"["<<found->second->alias<<"] in cache that equal to "<<name<<endl;
instrument_cache.cpp        TTLOG(WARNING,13)<<"FindNative "<<found->second->name<<"["<<found->second->alias<<"] in cache like "<<name<<". Ignore..."<<endl;
instrument_cache.cpp    TTLOG(INFO,13)<<"AddProduct: prod_id="<<product_id<<"lu, symbol="<<product->symbol<<endl;
instrument_cache.cpp        TTLOG(INFO,13)<<"Added Native: instr_id="<<downloaded->instr_snap.instr_id<<"lu, alias="<<downloaded->alias<<" name="<<downloaded->name<<". Subscribing TTNotify with market_id="<<downloaded->instr_snap.market_id<<" product_id="<<downloaded->instr_snap.product_id<<"lu"<<endl;
instrument_cache.cpp        TTLOG(INFO,13)<<"Added Synthetic: instr_id="<<downloaded->instr_snap.instr_id<<"lu, alias="<<downloaded->alias<<" name="<<downloaded->name<<". Subscribing TTNotify with market_id="<<downloaded->instr_snap.market_id<<" product_id="<<downloaded->instr_snap.product_id<<"lu"<<endl;
instrument_cache.cpp        TTLOG(WARNING,13)<<"InstrumentCache Clear whole native instruments and products!!!!!!!!!!!!!!!!!!!!!!!!"<<endl;
instrument_cache.cpp                TTLOG(WARNING,13)<<"InstrumentCache Remove instrument_id="<<id<<"lu"<<endl;
instrument_cache.cpp                TTLOG(WARNING,13)<<"InstrumentCache Remove product_id="<<id<<"lu"<<endl;
instrument_cache.cpp        TTLOG(ERROR,13)<<"RemoveSyntheticInstrument: instrument="<<instrument_id<<"lu not found in cache"<<endl;
instrument_cache.cpp        TTLOG(INFO,13)<<"RemoveSyntheticInstrument: instrument="<<instrument_id<<"lu removed from cache"<<endl;
instrument_cache.cpp        TTLOG(ERROR,13)<<"RemoveIfTickSizeChanged: invalid instrument_id="<<instrument_id<<"lu, tickSize="<<tickSize<<endl;
instrument_cache.cpp            TTLOG(INFO,13)<<"RemoveIfTickSizeChanged: No change. instrument="<<instrument_id<<"lu, tickSize="<<tickSize<<endl;
instrument_cache.cpp            TTLOG(INFO,13)<<"RemoveIfTickSizeChanged: Revmoed. instrument="<<instrument_id<<"lu, tickSize="<<tickSize<<", old_tickSize="<<instrDataPtr->instr_snap.tick_size<<endl;
analytics_sub_mgr.cpp    TTLOG(INFO,13)<<"OpenPriceSub instr="<<instr<<" instr_id="<<instr_id<<"lu interests="<<filter<<", subscribe_to_implies="<<subscribe_to_implies<<endl;
analytics_sub_mgr.cpp        TTLOG(INFO,13)<<"OpenPriceSub succeeded instr="<<instr<<" instr_id="<<instr_id<<"lu user_id="<<user_id<<"lu price_sub="<<*price_sub_id<<"lu interests="<<filter<<endl;
analytics_sub_mgr.cpp        TTLOG(ERROR,13)<<"OpenPriceSub failed instr="<<instr<<" instr_id="<<instr_id<<"lu user_id="<<user_id<<"lu price_sub="<<*price_sub_id<<"lu interests="<<filter<<endl;
pdsman.cpp        TTLOG(INFO,13)<<"BuildInstrData instr_id="<<snap.instr_id<<"lu underlying_instr_id="<<snap.underlying_instr_id<<"lu product_id="<<snap.product_id<<"lu market_id="<<snap.market_id<<" name="<<instr_data->name<<" alias="<<instr_data->alias<<" symbol="<<instr_data->symbol<<" security_exchange_id="<<instr_data->security_exchange_id<<" round_lot_quantity="<<snap.round_lot_quantity<<" decimal_shift_quantity="<<snap.decimal_shift_quantity<<" price_display_decimals="<<snap.price_display_decimals<<" decimal_shift_price="<<snap.decimal_shift_price<<" calculated_min_qty="<<snap.calculated_min_qty<<".8f"<<endl;
pdsman.cpp            TTLOG(INFO,13)<<"OpqueueData: "<<opaque_data<<endl;
pdsman.cpp                TTLOG(ERROR,13)<<"BuildInstrumentData: Parsing JSON failed error="<<ALGOUTIL_ERROR_STR[error]<<endl;
pdsman.cpp                TTLOG(ERROR,13)<<"BuildInstrumentData: Invalid JSON data found_flags="<<found_flags<<endl;
pdsman.cpp                TTLOG(ERROR,13)<<"GetInstrument failed instr_id="<<m_instr_id<<"lu error=invalid_token user_id="<<m_user_id<<"lu"<<endl;
pdsman.cpp            TTLOG(ERROR,13)<<"GetInstrument failed instr_id="<<m_instr_id<<"lu error="<<tt::sdk::internal::to_string(rt)<<endl;
pdsman.cpp                TTLOG(INFO,13)<<"OnInstrumentDataReady. instr_id="<<m_instr_id<<"lu found prod_id="<<prod_id<<"lu in cache"<<endl;
pdsman.cpp                            TTLOG(INFO,13)<<"Ottif downloaded for prod_id="<<prod_id<<"lu"<<endl;
pdsman.cpp                            TTLOG(ERROR,13)<<"Product downloaded, but failed to get ottif info! prod_id="<<prod_id<<"lu"<<endl;
pdsman.cpp                TTLOG(INFO,13)<<"OnInstrumentDataReady. instr_id="<<m_instr_id<<"lu about to download prod_id="<<prod_id<<"lu"<<endl;
pdsman.cpp                    TTLOG(ERROR,13)<<"GetProduct failed product_id="<<prod_id<<"lu error="<<tt::sdk::internal::to_string(rt)<<endl;
pdsman.cpp                    TTLOG(ERROR,13)<<"Product cached in PDS consumer, but not ttsdk: prod_id="<<prod_id<<"lu. Racing condiction???"<<endl;
pdsman.cpp            TTLOG(INFO,13)<<"OnInstrumentDataReady. instr_id="<<m_instr_id<<"lu prod_id=0 "<<endl;
pdsman.cpp            TTLOG(ERROR,13)<<"GetProduct failed product_id="<<instr->GetProductId()<<"lu error="<<tt::sdk::internal::to_string(result)<<endl;
pdsman.cpp        TTLOG(INFO,13)<<"OnInstrumentDataReady and OnProductDataReady instr_id="<<m_instr_id<<"lu prod_id="<<prod_id<<"lu "<<endl;
pdsman.cpp                    TTLOG(ERROR,13)<<"GetTickTable failed product_id="<<prod_id<<"lu tick_table_id="<<tick_table_id<<"u error="<<tt::sdk::internal::to_string(static_cast<PDSDownloadResult>(rt.GetValue()))<<endl;
pdsman.cpp            TTLOG(ERROR,13)<<"ProcessLegs: Invalid Leg Count leg_count="<<count<<"u instr_id="<<pds_instr_data->GetId()<<"lu"<<endl;
pdsman.cpp            TTLOG(ERROR,13)<<"ProcessLegs: leg_count="<<count<<"u instr_id="<<pds_instr_data->GetId()<<"lu the Leg Count exceeds the max ("<<TTSDK_MAX_LEG_COUNT<<"zu)"<<endl;
pdsman.cpp             TTLOG(INFO,13)<<"OnInstrumentDataReady and ProcessLegs instr_id="<<m_instr_id<<"lu leg_count="<<count<<" "<<endl;
pdsman.cpp            TTLOG(INFO,13)<<"OnInstrumentDataReady and ProcessLegs instr_id="<<m_instr_id<<"lu leg_instrument_Id="<<out_right_id<<"lu "<<endl;
pdsman.cpp                TTLOG(ERROR,13)<<"The number of instrument legs exceeds the max ("<<TTSDK_MAX_LEG_COUNT<<"u). instr_id="<<m_instr_id<<"lu leg_instrument_Id="<<out_right_id<<"lu "<<endl;
pdsman.cpp        TTLOG(ERROR,13)<<"InitializePDS failed url="<<url<<" error="<<ex.what()<<endl;
pdsman.cpp        TTLOG(INFO,13)<<"Initialize PDS succeeded"<<endl;
pdsman.cpp    TTLOG(ERROR,13)<<"Initialize PDS failed url="<<url<<" error="<<error.What()<<endl;
pdsman.cpp        TTLOG(INFO,13)<<"Hit "<<url<<" "<<count<<" times. All good"<<endl;
pdsman.cpp    TTLOG(ERROR,13)<<"Hit "<<url<<" "<<count<<" times. At least one failed"<<endl;
pdsman.cpp        TTLOG(ERROR,13)<<"DownloadInstrument Failed: instr_id=0"<<endl;
pdsman.cpp            TTLOG(INFO,13)<<"DownloadInstrument: instr_id="<<instr_id<<"lu found in InstrumentCache"<<endl;
pdsman.cpp            TTLOG(INFO,13)<<"DownloadInstrument starting instr_id="<<instr_id<<"lu, use_token="<<use_token<<endl;
pdsman.cpp            TTLOG(ERROR,13)<<"Instrument download timeout instr_id="<<instr_id<<"lu user_id="<<user_id<<"lu. Try one more time., use_token="<<use_token<<", retry="<<retry<<", retry_delay="<<retry_delay<<endl;
pdsman.cpp        TTLOG(ERROR,13)<<"DownloadInstrument failed instr_id="<<instr_id<<"lu, use_token="<<use_token<<", retry="<<retry<<", retry_delay="<<retry_delay<<endl;
pdsman.cpp        TTLOG(ERROR,13)<<"DownloadInstrument succeeded. But instr_id="<<instr_id<<"lu invalid"<<endl;
pdsman.cpp        TTLOG(INFO,13)<<"DownloadInstrument succeeded instr_id="<<instr_id<<"lu, use_token="<<use_token<<", retry="<<retry<<", retry_delay="<<retry_delay<<endl;
pdsman.cpp            TTLOG(WARNING,13)<<"DownloadInstrumentByName FAILED - invalid token. name="<<name<<" user_id="<<user_id<<"lu, retry="<<retry<<", retry_delay="<<retry_delay<<endl;
pdsman.cpp                TTLOG(INFO,13)<<"SearchInstruments found "<<name<<" and its id="<<item->GetId()<<"lu. Downloading..."<<endl;
pdsman.cpp        TTLOG(ERROR,13)<<"SearchInstruments failed name="<<name<<" error="<<error.What()<<endl;
pdsman.cpp    TTLOG(WARNING,13)<<"DownloadInstrumentByName FAILED - Unknown Instrument name="<<name<<", retry="<<retry<<", retry_delay="<<retry_delay<<endl;
pdsman.cpp        TTLOG(ERROR,13)<<"SearchInstruments FAILED - PDSConsumer is not initialized"<<endl;
pdsman.cpp            TTLOG(WARNING,13)<<"SearchInstruments FAILED - invalid token. name="<<name<<" user_id="<<user_id<<"lu"<<endl;
pdsman.cpp        TTLOG(ERROR,13)<<"SearchInstruments failed name="<<name<<" error="<<error.What()<<endl;
pdsman.cpp        TTLOG(INFO,13)<<"SearchInstruments worked! name="<<name<<endl;
pdsman.cpp            TTLOG(WARNING,13)<<"DownloadResourceFile failed - invalid token. resource_name="<<resource_name<<" user_id="<<user_id<<"lu"<<endl;
pdsman.cpp        TTLOG(ERROR,13)<<"DownloadResourceFile failed - Memory allocation"<<endl;
pdsman.cpp        TTLOG(ERROR,13)<<"DownloadResourceFile failed - Failed to open file. file="<<dest_path<<endl;
pdsman.cpp        TTLOG(ERROR,13)<<"DownloadResourceFile failed - Failed to write to file. file="<<dest_path<<endl;
pdsman.cpp            TTLOG(WARNING,13)<<"DownloadResourceFile failed - invalid token. resource_name="<<resource_name<<" user_id="<<user_id<<"lu"<<endl;
pdsman.cpp    TTLOG(INFO,13)<<"DownloadResourceString() name="<<resource_name<<endl;
pdsman.cpp        TTLOG(ERROR,13)<<"GetCurrencyRate failed error="<<error.What()<<endl;
pdsman.cpp        TTLOG(ERROR,13)<<"GetAllSecurityExchange failed error="<<error.What()<<endl;
pdsman.cpp        TTLOG(INFO,13)<<"Building SecurityExchange Map: ["<<key.market_id<<","<<key.name<<"]="<<security_exchange_id<<endl;
pdsman.cpp        TTLOG(ERROR,13)<<"GetMarketName failed market_id="<<market_id<<" error="<<error.What()<<endl;
pdsman.cpp    TTLOG(INFO,13)<<"AliasOrName=["<<name_or_alias<<"] user_id="<<user_id<<"lu, "<<endl;
pdsman.cpp        TTLOG(ERROR,13)<<"GetInstrumentByAlias=["<<name_or_alias<<"] Failed"<<endl;
pdsman.cpp            TTLOG(ERROR,13)<<"GetInstrumentByName=["<<name_or_alias<<"] Failed"<<endl;
pdsman.cpp    TTLOG(INFO,13)<<"AliasOrName=["<<name_or_alias<<"] downloaded instr_id="<<result->instr_snap.instr_id<<"lu. About to download prod_id="<<prod_id<<"lu"<<endl;
pdsman.cpp            TTLOG(INFO,13)<<"AliasOrName=["<<name_or_alias<<"] found prod_id="<<prod_id<<"lu in cache"<<endl;
pdsman.cpp                    TTLOG(ERROR,13)<<"AliasOrName=["<<name_or_alias<<"] GetProduct failed product_id="<<prod_id<<"lu product_ptr is null "<<endl;
pdsman.cpp                TTLOG(ERROR,13)<<"AliasOrName=["<<name_or_alias<<"] GetProduct failed product_id="<<prod_id<<"lu error="<<tt::sdk::internal::to_string(rt)<<endl;
pdsman.cpp        TTLOG(INFO,13)<<"AliasOrName=["<<name_or_alias<<"] About to get ticket_table_id="<<result->tick_table_id<<"lu"<<endl;
pdsman.cpp            TTLOG(ERROR,13)<<"AliasOrName=["<<name_or_alias<<"] GetTickTable failed tick_table_id="<<result->tick_table_id<<"u error="<<tt::sdk::internal::to_string(static_cast<PDSDownloadResult>(rt.GetValue()))<<endl;
pdsman.cpp        TTLOG(INFO,13)<<"AliasOrName=["<<name_or_alias<<"] About to get legs_size="<<leg_size<<"lu"<<endl;
pdsman.cpp                    TTLOG(INFO,13)<<"AliasOrName=["<<name_or_alias<<"] Sucessful get leg("<<result->legs.size()<<"/"<<leg_size<<") out_right_id="<<leg.out_right_id<<"lu"<<endl;
pdsman.cpp                    TTLOG(ERROR,13)<<"AliasOrName=["<<name_or_alias<<"] Sucessful get leg("<<result->legs.size()<<"/"<<leg_size<<") out_right_id="<<leg.out_right_id<<"lu, but the number of instrument legs exceeds the max ("<<TTSDK_MAX_LEG_COUNT<<"u)"<<endl;
pdsman.cpp                TTLOG(ERROR,13)<<"AliasOrName=["<<name_or_alias<<"]Failed to get leg("<<result->legs.size()+1<<"/"<<leg_size<<") out_right_id="<<leg.out_right_id<<"lu error="<<tt::sdk::internal::to_string(leg_result.first)<<endl;
pdsman.cpp        TTLOG(ERROR,13)<<"PreloadSseInstruments failed - could not get names and ids for the environment"<<endl;
pdsman.cpp                    TTLOG(ERROR,13)<<"ERROR - count="<<count<<" id="<<id.instr_id<<"lu - should be 0\n"<<endl;
pdsman.cpp                TTLOG(INFO,13)<<"PreloadSseInstruments OK. count="<<count<<" instr_id="<<id.instr_id<<"lu"<<endl;
pdsman.cpp                TTLOG(ERROR,13)<<"PreloadSseInstruments Failed. count="<<count<<" instr_id="<<id.instr_id<<"lu error="<<endl;
algo_store.cpp             TTLOG(ERROR,13)<<"Requesting url="<<url.c_str()<<" failed. code="<<code<<"d response="<<output<<endl;
algo_store.cpp                TTLOG(INFO,13)<<"Got Ottif data! url="<<endpoint<<endl;
algo_store.cpp                    TTLOG(INFO,13)<<"ottif: ot="<<ottif.ot<<" tif="<<ottif.tif<<endl;
algo_store.cpp                TTLOG(INFO,13)<<"DownloadProductOttifSync failed url="<<endpoint<<" http_code="<<observer.http_code<<"d reason="<<observer.failure_reason<<endl;
algo_store.cpp        TTLOG(INFO,13)<<"DownloadProductOttifSync: Exception caught. url="<<endpoint<<" error="<<ex.what()<<endl;
algo_store.cpp         TTLOG(INFO,13)<<"DownloadProductOttifSync failed: Unknown exception caught. url="<<endpoint<<endl;
algo_store.cpp    TTLOG(INFO,13)<<"DownloadPDSSystemDataSync "<<endl;
algo_store.cpp                TTLOG(INFO,13)<<"Got PDS system data"<<endl;
algo_store.cpp                    TTLOG(INFO,13)<<"OrderType: i="<<ot.i<<" n="<<ot.n<<" d="<<ot.d<<endl;
algo_store.cpp                    TTLOG(INFO,13)<<"TimeInForce: i="<<tif.i<<" n="<<tif.n<<" d="<<tif.d<<endl;
algo_store.cpp                TTLOG(INFO,13)<<"DownloadPDSSystemDataSync failed url="<<systemdata_endpoint<<" http_code="<<observer.http_code<<"d reason="<<observer.failure_reason<<endl;
algo_store.cpp        TTLOG(INFO,13)<<"DownloadPDSSystemDataSync: Exception caught. url="<<systemdata_endpoint<<" error="<<ex.what()<<endl;
algo_store.cpp         TTLOG(INFO,13)<<"DownloadPDSSystemDataSync failed: Unknown exception caught. url="<<systemdata_endpoint<<endl;
algo_store.cpp    TTLOG(INFO,13)<<"Sending AlgoStore def request. url="<<request_url<<endl;
algo_store.cpp                TTLOG(ERROR,13)<<"AlgoStore algo def request failed. url="<<request_url<<" http_code="<<observer.http_code<<"d reason="<<observer.failure_reason<<endl;
algo_store.cpp        TTLOG(ERROR,13)<<"AlgoStore algo def request failed: Exception caught. url="<<request_url<<" error="<<error<<endl;
algo_store.cpp        TTLOG(ERROR,13)<<"AlgoStore algo def request failed: Unknown exception caught. url="<<request_url<<endl;
algo_store.cpp        TTLOG(INFO,13)<<"Sending algo resource request. url="<<url<<endl;
algo_store.cpp                TTLOG(ERROR,13)<<"Algo resource request failed. url="<<url<<" http_code="<<observer.http_code<<"d reason="<<observer.failure_reason<<endl;
algo_store.cpp        TTLOG(ERROR,13)<<"Algo resource request failed: Exception caught. url="<<url<<" error="<<error<<endl;
algo_store.cpp        TTLOG(ERROR,13)<<"Algo resource request failed: Unknown exception caught. url="<<url<<endl;
algo_store.cpp    TTLOG(INFO,13)<<"GetInstrumentFromEndPoint request_url="<<request_url<<" is_retry="<<is_retry<<endl;
algo_store.cpp                TTLOG(ERROR,13)<<"GetInstrumentFromEndPoint failed. url="<<request_url<<" http_code="<<observer.http_code<<"d reason="<<observer.failure_reason<<endl;
algo_store.cpp                    TTLOG(ERROR,13)<<"GetInstrumentFromEndPoint: No instrument! url="<<request_url<<endl;
algo_store.cpp                    TTLOG(ERROR,13)<<"GetInstrumentFromEndPoint: Ambiguity!. url="<<request_url<<" return size="<<observer.response.instruments.size()<<endl;
algo_store.cpp        TTLOG(ERROR,13)<<"GetInstrumentFromEndPoint failed: Exception caught. url="<<request_url<<" error="<<ex.what()<<endl;
algo_store.cpp        TTLOG(ERROR,13)<<"GetInstrumentFromEndPoint failed: Unknown exception caught. url="<<request_url<<endl;
algoinstmgr.cpp    TTLOG(WARNING,13)<<"TTSDKNullptrEventCallback -------------- user_request_id="<<user_request_id<<endl;
algoinstmgr.cpp            TTLOG(WARNING,13)<<"ProcessOrderEvent received a response for an order whose parent_id does NOT match algo_inst_id: order_data="<<static_cast<void*>(order_data)<<" order_snap->order_id="<<order_snap_order_id_str<<" algo_inst_mgr="<<static_cast<void*>(algo_mgr.get())<<" algo_inst_mgr->parent_id="<<algo_mgr->GetAlgoInstanceId()<<endl;
algoinstmgr.cpp                TTLOG(WARNING,13)<<"ProcessOrderEvent received downloaded. order_data="<<static_cast<void*>(order_data)<<" [AlgoSDK]algo_order_id="<<algo_mgr->GetAlgoInstanceId()<<endl;
algoinstmgr.cpp            TTLOG(WARNING,13)<<"ProcessOrderEvent: order_snap == nullptr, event="<<TTSDK_OrderEventToString(event)<<", user_request_id="<<user_request_id<<", order_data="<<(void*)order_data<<", algo_inst_id="<<algo_mgr->GetAlgoInstanceId()<<" "<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<" ProcessUnsolicitedOrderEvent(): AlgoInstMgr no longer available or active"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"ProcessPositionLimitUpdatedEvent: Callback function ptr was unexpectedly a nullptr, the requestor will NOT get a response of any sort."<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"CheckMarketDataPermission: can not find user_id="<<user_id<<"lu in s_usersMap [market_id="<<instr_snap->market_id<<" symbol="<<instr_snap->symbol<<" name="<<instr_snap->name<<" alias=["<<instr_snap->alias<<"] security_exchange_id="<<instr_data->security_exchange_id<<" update_source="<<instr_data->update_source<<"]"<<endl;
algoinstmgr.cpp                    TTLOG(WARNING,13)<<"CheckMarketDataPermission: found user_id="<<user_id<<"lu but permission NOT allowed: [market_id="<<instr_snap->market_id<<" symbol="<<instr_snap->symbol<<" name="<<instr_snap->name<<" alias=["<<instr_snap->alias<<"] security_exchange_id="<<instr_data->security_exchange_id<<" update_source="<<instr_data->update_source<<"]"<<endl;
algoinstmgr.cpp    TTLOG(ERROR,13)<<"CheckMarketDataPermission: can not find matching exchange_id and security_exchange_id for user_id="<<user_id<<"lu in s_usersMap [market_id="<<instr_snap->market_id<<" symbol="<<instr_snap->symbol<<" name="<<instr_snap->name<<" alias=["<<instr_snap->alias<<"] security_exchange_id="<<instr_data->security_exchange_id<<" update_source="<<instr_data->update_source<<"]"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<algo_inst_id<<"] GetEnableNearFarTouchPriceReasonabilityFromUsersMap: Failed to find user_id="<<user_id<<"lu in s_usersMap - defaulting to false!"<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<algo_inst_id<<"] GetEnableNearFarTouchPriceReasonabilityFromUsersMap: Found user_id="<<user_id<<"lu in s_usersMap - setting="<<itr->second->company_enable_near_far_touch_price_reasonability?"true":"false"<<"!"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<algo_inst_id<<"] GetEnableAlgoRiskChecksFromUsersMap: can not find user_id="<<user_id<<"lu in s_usersMap. Default to false "<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<algo_inst_id<<"] GetEnableAlgoRiskChecksFromUsersMap: Found user_id="<<user_id<<"lu in s_usersMap - setting="<<itr->second->company_enable_algo_risk_checks?"true":"false"<<"!"<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] ~AlgoInstMgr. this="<<this<<" active="<<(bool)m_active<<" About to delete ttsdk_order_data size="<<m_to_delete.size()<<"u "<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] Removing algo_mgr["<<this<<"] from collection collection_size="<<s_algoInstMgrs.size()<<endl;
algoinstmgr.cpp            TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] m_loopCount="<<m_loopCount<<"lu, m_loopElapse="<<m_loopElapse<<"f"<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<"[algo:"<<GetAlgoInstanceId()<<"] TrackChildOrder: Child order already in track order_id="<<child_id<<endl;
algoinstmgr.cpp        TTLOG(WARNING,13)<<"[algo:"<<GetAlgoInstanceId()<<"] TrackChildOrder: logical_child_order_size="<<m_childOrders.size()<<"u"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] OnChildOrderEvent: RiskReject, all subsequent orders will be rejected user_request_id= "<<user_request_id<<"lu order_id="<<child_id<<" order_data="<<static_cast<void*>(order_data)<<" rejectDetails="<<m_childRejectDetails<<endl;
algoinstmgr.cpp                TTLOG(WARNING,13)<<"[algo:"<<GetAlgoInstanceId()<<"] OnChildOrderEvent: CXL rejected due to already pending, Order moved to pending list! order_id="<<childIdInMap<<" user_request_id="<<user_request_id<<", remaining m_mapWaitChildDeletes.size="<<m_mapWaitChildDeletes.size()<<" "<<endl;
algoinstmgr.cpp                TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] OnChildOrderEvent: Request time out! user_request_id="<<user_request_id<<"lu "<<endl;
algoinstmgr.cpp                        TTLOG(WARNING,13)<<"[algo:"<<GetAlgoInstanceId()<<"] OnChildOrderEvent: First PurgChildOrder failure user_request_id="<<user_request_id<<"lu status="<<TTSDK_OrderStatusToString(order_snap->last_status)<<" "<<endl;
algoinstmgr.cpp            TTLOG(INFO,13)<<"[algo:"<<GetAlgoInstanceId()<<"] OnChildOrderEvent: Remove user_request_id="<<user_request_id<<", remaining m_mapWaitChildDeletes.size="<<m_mapWaitChildDeletes.size()<<" "<<endl;
algoinstmgr.cpp                TTLOG(WARNING,13)<<"[algo:"<<GetAlgoInstanceId()<<"] OnChildOrderEvent: Unsolcited CXL received. Remove from pending delete list! order_id="<<child_id<<" m_listPendingDeletes.size()="<<m_listPendingDeletes.size()<<endl;
algoinstmgr.cpp                TTLOG(WARNING,13)<<"[algo:"<<GetAlgoInstanceId()<<"] OnChildOrderEvent respond_to_adlhost purgeChildOrdersSucceed="<<m_purgeChildOrdersSucceed<<endl;
algoinstmgr.cpp        TTLOG(WARNING,13)<<"[algo:"<<GetAlgoInstanceId()<<"] OnDetachOrder: logical_child_order_size="<<m_childOrders.size()<<"u"<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<GetAlgoInstanceId()<<"] PurgeChildOrders("<<(action==AlgoInstMgrAction::Cancel)?"Cancel/Fail":"Pause"<<") START"<<endl;
algoinstmgr.cpp                TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] PurgeChildOrders: Detected in-flight child. Sending delete. user_request_id="<<user_request_id<<"u parent_id="<<child->parent_id<<" action="<<(action==AlgoInstMgrAction::Cancel)?"Cancel":"Pause"<<" order_data="<<static_cast<void*>(child)<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] PurgeChildOrders: ("<<iteration<<" of "<<m_childOrders.size()<<"), oma_parent_id="<<(oma_exists)?oma_parent_id_tt.to_string<<" parent_id="<<(parent_exists)?parent_id_tt.to_string<<" order_id="<<child_id<<" am_I_oma_algo="<<(am_I_oma_algo)?"yes":"no"<<", am_I_parent_algo="<<(am_I_parent_algo)?"yes":"no"<<" action="<<(action==AlgoInstMgrAction::Cancel)?"Cancel":"Pause"<<" leave_on_cancel="<<(leave_on&ttsdk_leave_on_cancel)?"true":"false"<<" leave_on_pause="<<(leave_on&ttsdk_leave_on_pause)?"true":"false"<<" "<<endl;
algoinstmgr.cpp                TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] PurgeChildOrders: MarshallDetachOrder(OMA): request_id="<<requestId<<", order_id="<<child_id<<", parent_order_id="<<(parent_exists)?parent_id_tt.to_string<<", oma_parent_order_id="<<(oma_exists)?oma_parent_id_tt.to_string<<" "<<endl;
algoinstmgr.cpp                    TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] PurgeChildOrders: MarshallDetachOrder(parent): request_id="<<requestId<<", order_id="<<child_id<<", parent_order_id="<<(parent_exists)?child->parent_id.to_string<<endl;
algoinstmgr.cpp            TTLOG(DEBUG,13)<<"[algo:"<<m_instanceId<<"] PurgeChildOrders: CancelRequest: user_request_id="<<user_request_id<<" parent_id="<<(parent_exists)?child->parent_id.to_string<<" order_id="<<child_id<<" "<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] PurgeChildOrders: waitForChildOrderDeletes="<<m_waitForChildOrderDeletes<<", m_mapWaitChildDeletes.size="<<m_mapWaitChildDeletes.size()<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] DetachChildOrders START"<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<" [algo:"<<m_instanceId<<"] DetachChildOrders: ("<<iteration<<" of "<<numChildren<<"), order_id="<<child_id<<" "<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<" [algo:"<<m_instanceId<<"] DetachChildOrders: request_id="<<requestId<<", order_id="<<child_id<<", "<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] DownloadInstrument succeeded, but the instrument is invalid (deleted, inactive, or invalid_upload_source in PDS) instr_id="<<instr_id<<"lu use_token="<<use_token<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] DownloadInstrument failed instr_id="<<instr_id<<"lu error="<<to_string(dl_result.first)<<" use_token="<<use_token<<" "<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] DownloadInstrumentByName failed. name=nullptr"<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] DownloadInstrumentByName starting. name="<<std_name<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] DownloadInstrumentByName succeeded, but instrument is invalid (deleted, inactive, or invalid_upload_source in PDS) name="<<std_name<<" use_token="<<use_token<<" "<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] DownloadInstrumentByName failed name="<<std_name<<" error="<<to_string(dl_result.first)<<" use_token="<<use_token<<" "<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] DownloadInstrumentByName succeeded name="<<std_name<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<"[Algo:"<<m_instanceId<<"] SearchInstruments failed query="<<query==nullptr?NULL_STR:std::string(query)<<" error="<<to_string(error)<<" "<<endl;
algoinstmgr.cpp            TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] OpenPriceSub failed, requested subscription exceeds max allowed instr="<<instr<<" instr_id="<<instr_id<<"lu user_id="<<m_userId<<"lu max_allowed="<<env::instance().max_allowed_price_sub()<<" "<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<" [algo:"<<m_instanceId<<"] OpenPriceSub: Widened price interests to accomodate PnL calculations: instr="<<instr<<" instr_id="<<instr_id<<"lu original_interests="<<Filter(interests)<<" widened_interests="<<Filter(interests|ttsdk_interests_pnl)<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] OpenPriceSub instr="<<instr<<" instr_id="<<instr_id<<"lu interests="<<filter<<", subscribe_to_implies="<<subscribe_to_implies<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] OpenPriceSub succeeded instr="<<instr<<" instr_id="<<instr_id<<"lu user_id="<<m_userId<<"lu price_sub="<<*price_sub<<"lu interests="<<filter<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<" [algo:"<<m_instanceId<<"] CheckPriceSnap: user_request_id="<<request_id<<" instr_id="<<instr_id<<"lu address="<<address<<" ref_count="<<it->second->ref_count()<<" PriceSnap:seq_no="<<p->seq_no<<"lu, exchange_tm="<<p->exchange_time<<"lu, //[ 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 ] ["<<p->mdrc_recv_time<<"lu->"<<//1eReceivedByServerp->client_recv_time<<"lu->"<<//2eReceivedp->queue_up_time<<"lu->"<<//3eQueuedUpp->dequeue_time<<"lu->"<<//4eDequeuedp->before_parse_time<<"lu->"<<//5eBeforeParsep->after_parse_time<<"lu->"<<//6eAfterParsep->after_cache_time<<"lu->"<<//7eAfterCachep->after_merge_time<<"lu->"<<//8eAfterMergep->before_callback_time<<"lu] algo_recv_tm="<<//9eBeforeUnifierCallbackp->order_stimulus_received_algo<<"lu conflate_no="<<p->conflation_no<<"lu b1=["<<b1<<"f @ "<<b1_q<<".8f("<<b1_implied<<".8f)] b0=["<<b0<<"f @ "<<b0_q<<".8f("<<b0_implied<<".8f)] a0=["<<a0<<"f @ "<<a0_q<<".8f("<<a0_implied<<".8f)] a1=["<<a1<<"f @ "<<a1_q<<".8f("<<a1_implied<<".8f)] non_matching="<<params_internal->non_matching<<"("<<params_internal->non_matching?"NOinternalmatch":"TTINTwilldointernalmatch"<<") best_market_price="<<params_internal->best_market_price<<"f crossing_levels=["<<crossing_levels_string<<"]"<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] CheckPriceSnap: user_request_id="<<request_id<<" instr_id="<<instr_id<<"lu, non_matching=true(NO internal match) No PriceSnap!"<<endl;
algoinstmgr.cpp        TTLOG(DEBUG,13)<<"[algo:"<<m_instanceId<<"] CalculateCrossingLevels: Exempting cancel request: user_request_id="<<request_id<<endl;
algoinstmgr.cpp            TTLOG(DEBUG,13)<<"[algo:"<<m_instanceId<<"] CalculateCrossingLevels: Market Order with no opposite side qty --> crossing_level=-1: user_request_id="<<request_id<<endl;
algoinstmgr.cpp        TTLOG(DEBUG,13)<<"[algo:"<<m_instanceId<<"] CalculateCrossingLevels: Limit Order with no opposite side qty --> crossing_level=0: user_request_id="<<request_id<<endl;
algoinstmgr.cpp        TTLOG(DEBUG,13)<<"[algo:"<<m_instanceId<<"] CalculateCrossingLevels: Order price will not cross opposite side market --> crossing_level=0: user_request_id="<<request_id<<endl;
algoinstmgr.cpp            TTLOG(DEBUG,13)<<"[algo:"<<m_instanceId<<"] CalculateCrossingLevels: Incoming order qty satisfied: user_request_id="<<request_id<<endl;
algoinstmgr.cpp            TTLOG(DEBUG,13)<<"[algo:"<<m_instanceId<<"] CalculateCrossingLevels: Incoming order will cross this price level: user_request_id="<<request_id<<" price_level="<<opposite_market.levels[i].price<<" how_many_crossed_so_far="<<crossing_level<<" remaining_qty_to_match="<<remaining_qty_to_match<<endl;
algoinstmgr.cpp            TTLOG(DEBUG,13)<<"[algo:"<<m_instanceId<<"] CalculateCrossingLevels: Incoming order price satisfied: user_request_id="<<request_id<<endl;
algoinstmgr.cpp        TTLOG(DEBUG,13)<<"[algo:"<<m_instanceId<<"] CalculateCrossingLevels: crossing_level="<<crossing_level<<": user_request_id="<<request_id<<endl;
algoinstmgr.cpp        TTLOG(DEBUG,13)<<"[algo:"<<m_instanceId<<"] CalculateCrossingLevels: crossing_level="<<crossing_level<<": user_request_id="<<request_id<<endl;
algoinstmgr.cpp    TTLOG(DEBUG,13)<<"[algo:"<<m_instanceId<<"] CalculateCrossingLevels: Incoming order will exhaust entire opposite market qty: user_request_id="<<request_id<<endl;
algoinstmgr.cpp        TTLOG(DEBUG,13)<<"[algo:"<<m_instanceId<<"] CalculateCrossingLevels: Market Order will exhaust entire opposite market --> crossing_level=-1: user_request_id="<<request_id<<endl;
algoinstmgr.cpp    TTLOG(DEBUG,13)<<"[algo:"<<m_instanceId<<"] CalculateCrossingLevels: Limit Order will exhaust entire opposite market --> crossing_level="<<crossing_level<<": user_request_id="<<request_id<<endl;
algoinstmgr.cpp            TTLOG(INFO,13)<<" [algo:"<<m_instanceId<<"] UpdatePriceInterests: Widened price interests to accomodate PnL calculations: price_sub="<<price_sub<<"lu original_interests="<<Filter(interests)<<" widened_interests="<<Filter(interests|ttsdk_interests_pnl)<<endl;
algoinstmgr.cpp                TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] UpdatePriceInterests price_sub="<<price_sub<<"lu interests="<<Filter(interests)<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] ReActivatePriceSubscriber ttsdk_price_sub="<<price_sub<<"lu"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] ReActivatePriceSubscriber ttsdk_price_sub="<<price_sub<<"lu, but not found in s_priceSubscribers"<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] DeActivatePriceSubscriber ttsdk_price_sub="<<price_sub<<"lu"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] DeActivatePriceSubscriber ttsdk_price_sub="<<price_sub<<"lu, but not found in s_priceSubscribers"<<endl;
algoinstmgr.cpp        TTLOG(WARNING,13)<<"[algo:"<<m_instanceId<<"] PlaceOrder: Rejecting request - PurgeChildOrders is waiting for child delete acknowledgements request_id="<<request_id<<endl;
algoinstmgr.cpp            TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] PlaceOrder: params has at least one GDAX instrument"<<endl;
algoinstmgr.cpp                TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] PlaceOrder: params has no primary_market_id. Value will be set from first leg market_id="<<static_cast<int>(primary_market_id)<<endl;
algoinstmgr.cpp            TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] PlaceOrder: sending PR order on synthetic instrument"<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<"Will route synthetic order(market_id="<<market_id<<") to "<<answer<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<"Will route algo order to myself="<<myself<<endl;
algoinstmgr.cpp        TTLOG(DEBUG,13)<<"[algo:"<<m_instanceId<<"] PlaceOrder: request_id="<<request_id<<" price_deviation_data="<<DebugDumpPriceDeviationData(price_deviation_data)<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] RegisterForUnsolicitedOrders() request_id="<<request_id<<", callback="<<(void*)unsolicited_cb<<", user_id="<<GetUserId()<<"lu, account_id="<<account_id<<"lu"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] ChangeOrder: Failed to find instr_data for order_data="<<static_cast<void*>(order_data)<<endl;
algoinstmgr.cpp            TTLOG(WARNING,13)<<"[algo:"<<m_instanceId<<"] ChangeOrder: Rejecting request - PurgeChildOrders is waiting for child delete acknowledgements request_id="<<request_id<<endl;
algoinstmgr.cpp        TTLOG(DEBUG,13)<<"[algo:"<<m_instanceId<<"] ChangeOrder: request_id="<<request_id<<" price_deviation_data="<<DebugDumpPriceDeviationData(price_deviation_data)<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] RegisterProfitLossSub: refused to start a REDUNDANT p&l subscription: algo_inst_mgr="<<(void*)this<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] RegisterProfitLossSub: FAILED - event_cb was null: algo_inst_mgr="<<(void*)this<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] RegisterProfitLossSub: algo_inst_mgr="<<(void*)this<<" currency="<<preferred_currency==ttsdk_currency_code_USD?"USD":std::to_string(preferred_currency)<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] UpdateProfitLoss (order): failed to get INSTR ID from order_snap: error="<<TTSDK_ERROR_STR[error]<<" order_snap->last_status="<<order_snap->last_status<<" order_snap="<<order_snap.get()<<endl;
algoinstmgr.cpp            TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] UpdateProfitLoss (order): failed to retrieve CURRENCY CONVERSION RATE: error="<<ex.what()<<" product_id="<<instr_snap.product_id<<"lu order_snap->last_status="<<order_snap->last_status<<" order_snap="<<order_snap.get()<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] UpdateProfitLoss (order): failed to retrieve FILL SIDE out of order_snap: error="<<TTSDK_ERROR_STR[error]<<" order_snap->last_status="<<order_snap->last_status<<" order_snap->instr_id="<<instr_id<<"lu order_snap="<<order_snap.get()<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] UpdateProfitLoss (order): failed to retrieve FILL QTY out of order_snap: error="<<TTSDK_ERROR_STR[error]<<" order_snap->last_status="<<order_snap->last_status<<" order_snap->instr_id="<<instr_id<<"lu order_snap="<<order_snap.get()<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] UpdateProfitLoss (order): failed to retrieve FILL PRC out of order_snap: error="<<TTSDK_ERROR_STR[error]<<" order_snap->last_status="<<order_snap->last_status<<" order_snap->instr_id="<<instr_id<<"lu order_snap="<<order_snap.get()<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] UpdateProfitLoss (order): failed to derive THEO EXIT PRC: error="<<TTSDK_ERROR_STR[error]<<" order_snap->last_status="<<order_snap->last_status<<" order_snap->instr_id="<<instr_id<<"lu order_snap="<<order_snap.get()<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] UpdateProfitLoss (price): failed to derive THEO EXIT PRC: error="<<TTSDK_ERROR_STR[error]<<" instr_id="<<instr_id<<"lu"<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] current_user_id "<<m_userId<<"lu->"<<new_current_user_id<<"lu "<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] "<<GroupIDsToString(group_ids)<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] GetAlgoSettings: can not find user_id="<<m_userId<<"lu in s_usersMap "<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] GetAlgoSettings: Internal Error. userobjPtr->ptr_accounts==nullptr; can not find matching account="<<account_id<<"lu "<<endl;
algoinstmgr.cpp    TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] GetAlgoSettings: can not find matching account="<<account_id<<"lu "<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] CheckSSEPermission: using originating_user_id="<<effective_user_id<<"lu (user_id="<<m_userId<<"lu)"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] CheckSSEPermission: can not find user_id="<<effective_user_id<<"lu in s_usersMap "<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] CheckSSEPermission: Internal Error. userobjPtr->ptr_accounts==nullptr; account="<<account_id<<"lu "<<endl;
algoinstmgr.cpp                    TTLOG(ERROR,13)<<"[algo:"<<env::instance().algo_obv_access()<<"] CheckSSEPermission: algo_obv_access denied, %d"<<endl;
algoinstmgr.cpp                TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] CheckSSEPermission: "<<TTSDK_ORDER_SYNTHETIC_TYPE_STR[sse_type]<<" is not set in TTUS."<<endl;
algoinstmgr.cpp                TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] CheckSSEPermission: found matching account="<<account_id<<"lu , but "<<TTSDK_ORDER_SYNTHETIC_TYPE_STR[sse_type]<<" disallowed"<<endl;
algoinstmgr.cpp    TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] CheckSSEPermission: can not find matching account="<<account_id<<"lu for user_id="<<effective_user_id<<"lu"<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] CheckSSEPermission: using originating_user_id="<<effective_user_id<<"lu (user_id="<<m_userId<<"lu)"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] CheckADLPermission: can not find user_id="<<effective_user_id<<"lu in s_usersMap "<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] CheckADLPermission: Internal Error. userobjPtr->ptr_accounts==nullptr"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] CheckADLPermission: No account specified for algo. And user_id="<<m_userId<<"lu has no ADL permission from any account"<<endl;
algoinstmgr.cpp                    TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] CheckADLPermission: account="<<account_id<<"lu does not allow ADL"<<endl;
algoinstmgr.cpp            TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] CheckADLPermission: can not find matching account="<<account_id<<"lu "<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<"AlgoInstMgr::ScheduleOBVGreekEvent() active="<<this->Active()<<" algo_inst_mgr="<<(void*)this<<" url="<<url<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<"[algo:"<<algo_inst_id<<"] Create new algo_mgr["<<static_cast<void*>(algo_mgr.get())<<"]"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<algo_inst_id<<"] CreateAlgoInstMgr failed to allocate memory"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<algo_inst_id<<"] CreateAlgoInstMgr exception="<<what?what:"unknown"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<algo_inst_id<<"] DetermineEnableNearFarTouchPriceReasonability: Failed to retrieve EnableNearFarTouchPriceReasonability param for user_id="<<user_id<<"lu during recovery - defaulting to false!"<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<algo_inst_id<<"] DetermineEnableNearFarTouchPriceReasonability: "<<value==1?"true":"false"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<algo_inst_id<<"] DetermineEnableAlgoRiskChecks: Failed to retrieve EnableAlgoRiskChecks param for user_id="<<user_id<<"lu during recovery - defaulting to false!"<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<algo_inst_id<<"] DetermineEnableAlgoRiskChecks: "<<value==1?"true":"false"<<endl;
algoinstmgr.cpp                TTLOG(ERROR,13)<<"Receive synthetic order of type "<<TTSDK_ORDER_SYNTHETIC_TYPE_STR[synth_type]<<". Ignoring it!"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"TTSDKUtil_ThreadSwitchOrderEvent error="<<TTSDK_ERROR_STR[error]<<" event="<<TTSDK_OrderEventToString(event)<<" order_data="<<order_data<<" user_request_id="<<user_request_id<<"lu "<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"RecoveryEvent: AlgoInstMgr is invalid or inactive, dropping response"<<endl;
algoinstmgr.cpp            TTLOG(ERROR,13)<<"RecoveryEvent: Callback cannot be invoked. callback="<<(void*)cb<<" active="<<mgr->Active()<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"Enqueue recovery response: algo_inst_mgr="<<static_cast<void*>(algo_inst_mgr)<<" inst_id="<<algo_mgr->GetAlgoInstanceId()<<endl;
algoinstmgr.cpp    TTLOG(DEBUG,13)<<"TTSDKUtil_ThreadSwitchPositionLimitUpdate: Delivering position limit updated response from OrderD Thread to Algojob Thread: result="<<result?std::string("true"):std::string("false")<<" is_long_limit="<<is_long_limit?std::string("true"):std::string("false")<<" limit="<<limit<<" algo_inst_mgr="<<static_cast<void*>(algo_inst_mgr)<<" user_data="<<user_data<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"TTSDKUtil_ThreadSwitchPositionLimitUpdate: AlgoInstMgr is invalid or inactive, the requestor will NOT get a response of any sort."<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"TTSDKUtil_ThreadSwitchPositionLimitUpdate: Enqueue position limit updated event: algo_inst_mgr="<<static_cast<void*>(algo_inst_mgr)<<" inst_id="<<algo_mgr->GetAlgoInstanceId()<<" "<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"ClosePriceSub price_sub="<<price_sub<<"lu"<<endl;
algoinstmgr.cpp            TTLOG(INFO,13)<<"ClosePriceSub. Did not find in s_jobInstrPriceSubCount instr_id="<<instr_id<<"lu user_id="<<user_id<<"lu"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<algo_mgr->GetAlgoInstanceId()<<"] TTSDK_DownloadInstrByAliasOrName instrument is invalid name_or_alias=["<<name_or_alias<<"] "<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<algo_mgr->GetAlgoInstanceId()<<"] TTSDK_DownloadInstrByAliasOrName failed name_or_alias=["<<name_or_alias<<"] error="<<to_string(dl_result.first)<<" "<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<algo_mgr->GetAlgoInstanceId()<<"] TTSDK_DownloadInstrByAliasOrName succeeded name_or_alias=["<<name_or_alias<<"]"<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"TTSDKUtil_UpdateUser: user_id="<<user_id<<"lu user_company_id="<<user->user_company_id<<"lu account_count="<<user->account_count<<"u market_data_count="<<user->market_data_count<<"u sim_party_id="<<user->sim_party_id<<"lu [AlgoJob: thread_id= "<<syscall(SYS_gettid)<<"]"<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<" TTSDKUtil_UpdateOrderD: user_id="<<user_id<<"lu [OrderD: thread_id= "<<syscall(SYS_gettid)<<"]"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<" TTSDKUtil_UpdateOrderD: Can not find user_id="<<user_id<<"lu"<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"CheckUserRequireApprova: can not find user_id="<<user_id<<"lu in s_usersMap "<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"GetPersonId: can not find user_id="<<user_id<<"lu in s_usersMap "<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] UpdatePositionLimit: Failed - user_data or cb or was null!"<<endl;
algoinstmgr.cpp        TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] isGdaxMarketIdSet() Found gdax recursion="<<level<<", instr_id="<<instr_data->instr_snap.instr_id<<"lu, market_id="<<instr_data->instr_snap.market_id<<", name="<<((instr_data->instr_snap.name!=nullptr)?std::string(instr_data->instr_snap.name):"")<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] isGdaxMarketIdSet() recursion="<<level<<", instr_id="<<instr_data->instr_snap.instr_id<<"lu, market_id="<<instr_data->instr_snap.market_id<<", name="<<((instr_data->instr_snap.name!=nullptr)?std::string(instr_data->instr_snap.name):"")<<endl;
algoinstmgr.cpp        TTLOG(DEBUG,13)<<"EpiqSwitch order_id="<<tt::algoutil::ttuuid(order_id)<<", instr_id="<<instr_id<<"lu, epiq="<<epiq_value<<endl;
algoinstmgr.cpp                    TTLOG(ERROR,13)<<" TTSDKUtil_ThreadSwitchEpiqEvent(): AlgoInstMgr no longer available or active"<<endl;
algoinstmgr.cpp    TTLOG(INFO,13)<<"[algo:"<<m_instanceId<<"] OnClass2FieldsChanged "<<endl;
algoinstmgr.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instanceId<<"] CollectToDelete. order_data="<<order_data<<" exist already (Detached twice?) "<<endl;
position_downloader.cpp    TTLOG(INFO,13)<<"PositionDownloader created: id="<<m_id<<"u, user_id="<<m_userId<<"lu, account_id="<<m_accountId<<"lu, product_id="<<m_productId<<"lu host_algo="<<m_host_algo<<" url="<<m_positionServiceUrl<<" "<<endl;
position_downloader.cpp         TTLOG(INFO,13)<<"PositionDownloader OnDownloadCompleted. m_host_algo="<<m_host_algo<<" no longer valid"<<endl;
position_downloader.cpp      TTLOG(INFO,13)<<"raw="<<j.dump()<<endl;
position_downloader.cpp          TTLOG(INFO,13)<<"PositionDownloader httpCode="<<httpCode<<"lu, id="<<m_id<<"u, user_id="<<m_userId<<"lu request_id="<<request_id<<" no position!"<<endl;
position_downloader.cpp          TTLOG(INFO,13)<<"PositionDownloader request_id="<<request_id<<endl;
position_downloader.cpp                  TTLOG(INFO,13)<<"No position for market_id="<<market_id<<"lu account_id="<<account_id<<"lu "<<endl;
position_downloader.cpp                          TTLOG(INFO,13)<<"instrument_data with no quantity_total. raw="<<i.dump()<<endl;
position_downloader.cpp                          TTLOG(INFO,13)<<"Add position count="<<count<<"lu instrument_id="<<p.instrument_id<<"lu net_pos="<<p.net_pos<<"f sod_net="<<p.sod_net<<"f wrk_buy="<<p.wrk_buy<<"f wrk_sell="<<p.wrk_sell<<"f filled_buy="<<p.buy_qty<<"f filled_sell="<<p.sell_qty<<"f"<<endl;
position_downloader.cpp          TTLOG(INFO,13)<<"PositionDownloader: totally delievered count="<<count<<"u "<<endl;
position_downloader.cpp        TTLOG(ERROR,13)<<"PositionDownloader OnDownloadCompleted failed: id="<<m_id<<"u exception="<<e.what()<<" count="<<count<<"lu record="<<r.dump()<<" "<<endl;
position_downloader.cpp    TTLOG(ERROR,13)<<"PositionDownloader fail: "<<errorBuffer.c_str()<<endl;
position_downloader.cpp    TTLOG(INFO,13)<<"PositionDownloader Run: id="<<m_id<<"u, user_id="<<m_userId<<"lu product_id="<<m_productId<<"lu request_id="<<request_id<<endl;
position_downloader.cpp            TTLOG(ERROR,13)<<"PositionDownloader RUn failed: no account"<<endl;
position_downloader.cpp        TTLOG(INFO,13)<<"PositionDownloader DownloadAsync "<<url<<endl;
position_downloader.cpp        TTLOG(ERROR,13)<<"PositionDownloader Run failed: id="<<m_id<<"u exception="<<e.what()<<endl;
position_downloader.cpp        TTLOG(INFO,13)<<"PositionDownloader Run failed: id="<<m_id<<"u, unknown exception"<<endl;
service.cpp        TTLOG(WARNING,13)<<"[algo:"<<m_instance_id<<"] Stop called, but InValid algo"<<endl;
service.cpp        TTLOG(ERROR,13)<<"[algo:"<<m_instance_id<<"] Stop. error="<<TTSDK_ERROR_STR[error]<<endl;
service.cpp        TTLOG(INFO,13)<<"[algo:"<<m_instance_id<<"] Stop request queued"<<endl;
service.cpp        TTLOG(INFO,13)<<"Downloader "<<m_id<<"u removed"<<endl;
service.cpp    TTLOG(INFO,13)<<"-------------------------> ~RestfulAPI: m_downloaders.size()="<<m_downloaders.size()<<endl;
service.cpp        TTLOG(INFO,13)<<"-------------------------> ~RestfulAPI(): finished"<<endl;
service.cpp        TTLOG(WARNING,13)<<"-------------------------> ~RestfulAPI(): still unfinished downloads: m_downloaders.size()="<<m_downloaders.size()<<endl;
service.cpp        TTLOG(INFO,13)<<"[algo:"<<algo->m_instance_id<<" this="<<(void*)algo<<"] About to OnStartAlgo"<<endl;
service.cpp        TTLOG(INFO,13)<<"[algo:"<<UILD_COMMIT<<" this="<<algo->m_instance_id<<"] OnStartAlgo error="<<(void*)algo<<" ttsdk_build_date= BUILD_DATE ttsdk_build_commit="<<endl;
service.cpp        TTLOG(ERROR,13)<<"[algo:"<<algo->m_instance_id<<" this="<<(void*)algo<<"] OnStartAlgo Failed"<<endl;
service.cpp        TTLOG(INFO,13)<<"[algo:"<<algo->m_instance_id<<" this="<<(void*)algo<<"] OnUpdateAlgo error="<<to_string(error)<<endl;
service.cpp        TTLOG(ERROR,13)<<"[algo:"<<algo->m_instance_id<<" this="<<(void*)algo<<"] OnUpdateAlgo Failed ex="<<ex.what()<<endl;
service.cpp        TTLOG(ERROR,13)<<"[algo:"<<algo->m_instance_id<<" this="<<(void*)algo<<"] OnUpdateAlgo Failed"<<endl;
service.cpp        TTLOG(INFO,13)<<"[algo:"<<algo->m_instance_id<<" this="<<(void*)algo<<"] OnPauseAlgo error="<<to_string(error)<<endl;
service.cpp        TTLOG(ERROR,13)<<"[algo:"<<algo->m_instance_id<<" this="<<(void*)algo<<"] OnPauseAlgo Failed ex="<<ex.what()<<endl;
service.cpp        TTLOG(ERROR,13)<<"[algo:"<<algo->m_instance_id<<" this="<<(void*)algo<<"] OnPauseAlgo Failed"<<endl;
service.cpp        TTLOG(WARNING,13)<<"[algo="<<algo<<"] OnStopAlgo, but InValid algo"<<endl;
service.cpp        TTLOG(INFO,13)<<"[algo:"<<algo->m_instance_id<<" this="<<(void*)algo<<"] OnStopAlgo error="<<to_string(error)<<endl;
service.cpp        TTLOG(ERROR,13)<<"[algo:"<<algo->m_instance_id<<" this="<<(void*)algo<<"] OnStopAlgo Failed ex="<<ex.what()<<endl;
service.cpp        TTLOG(ERROR,13)<<"[algo:"<<algo->m_instance_id<<" this="<<(void*)algo<<"] OnStopAlgo Failed"<<endl;
service.cpp        TTLOG(WARNING,13)<<"[algo="<<algo<<"] OnScheduledEvent, but InValid algo"<<endl;
service.cpp        TTLOG(INFO,13)<<"[algo:"<<algo->m_instance_id<<" this="<<(void*)algo<<"] OnScheduledEvent Failed"<<endl;
service.cpp        TTLOG(WARNING,13)<<"[algo="<<algo<<"] OnDestroyAlgo, but InValid algo"<<endl;
service.cpp    TTLOG(INFO,13)<<"[algo:"<<algo->m_instance_id<<" this="<<(void*)algo<<"] OnDestroyAlgo"<<endl;
service.cpp    TTLOG(INFO,13)<<"[algo:"<<m_instance_id<<"] Registor For Epiq Updates"<<endl;
algo_order.cpp        TTLOG(WARNING,13)<<"[AlgoOrder: "<<(void*)this<<"] Can not Detach while m_order is null"<<endl;
algo_order.cpp        TTLOG(WARNING,13)<<"[algo="<<m_algo->GetInstanceIdString()<<"] Cannot DownloadOrder synthetic_status="<<to_string(synstatus)<<endl;
algo_order.cpp        TTLOG(WARNING,13)<<"[algo="<<m_algo->GetInstanceIdString()<<"] Downloading: order_id="<<order_id<<" request_id="<<request_id<<"lu order_data="<<order_data<<endl;
algo_order.cpp                TTLOG(WARNING,13)<<"[AlgoOrderManager: "<<(void*)this<<"] Pausing Algo. Risk reject received while working. user_request_id="<<user_request_id<<endl;
algo_instrument.cpp    TTLOG(INFO,13)<<"[algo:"<<algo<<"] successfully create AlgoInstrument by id="<<instrument_id<<"lu: name="<<data->name<<" leg_count="<<data->instr_snap.instr_legs.count<<"u"<<endl;
algo_instrument.cpp    TTLOG(INFO,13)<<"[algo:"<<algo<<"] successfully create AlgoInstrument by name/alias="<<instr_name<<": id="<<data->instr_snap.instr_id<<"lu leg_count="<<data->instr_snap.instr_legs.count<<"u"<<endl;
live_data_provider_via_pricelib.cpp    TTLOG(INFO,13)<<" ["<<m_name<<"] LiveDataProviderViaPriceLib ctor @"<<this<<endl;
live_data_provider_via_pricelib.cpp    TTLOG(INFO,13)<<" ["<<m_name<<"] LiveDataProviderViaPriceLib dtor @"<<this<<endl;
live_data_provider_via_pricelib.cpp    TTLOG(INFO,13)<<" ["<<m_name<<"] LiveDataProviderViaPriceLib::Init @"<<this<<endl;
live_data_provider_via_pricelib.cpp    TTLOG(INFO,13)<<" ["<<m_name<<"] LiveDataProviderViaPriceLib::Reset @"<<this<<endl;
live_data_provider_via_pricelib.cpp    TTLOG(INFO,13)<<" ["<<m_name<<"] LiveDataProviderViaPriceLib::Shutdown @"<<this<<endl;
live_data_provider_via_pricelib.cpp    TTLOG(INFO,13)<<" ["<<m_name<<"] LiveDataProviderViaPriceLib::SubscribeTrades for instrument_id="<<instr_id<<"lu @"<<this<<endl;
live_data_provider_via_pricelib.cpp        TTLOG(ERROR,13)<<" ["<<m_name<<"] LiveDataProviderViaPriceLib::SubscribeTrades failed for instrument_id="<<instr_id<<"lu @"<<this<<" result="<<result<<endl;
live_data_provider_via_pricelib.cpp    TTLOG(INFO,13)<<" ["<<m_name<<"] LiveDataProviderViaPriceLib::UnsubscribeTrades for instrument_id="<<instr_id<<"lu @"<<this<<" "<<(m_priceSub==nullptr?"m_priceSub==nullptr":"")<<endl;
live_data_provider_via_pricelib.cpp    TTLOG(DEBUG,13)<<" ["<<m_name<<"] LiveDataProviderViaPriceLib::OnTimeSalesUpdate @"<<this<<endl;
live_data_provider_via_pricelib.cpp    TTLOG(INFO,13)<<" ["<<m_name<<"] LiveDataProviderViaPriceLib::OnPriceUpdate for "<<m_instr_name<<" @"<<this<<endl;
live_data_provider_via_pricelib.cpp    TTLOG(INFO,13)<<" ["<<m_name<<"] LiveDataProviderViaPriceLib::OnError @"<<this<<" error="<<error<<endl;
